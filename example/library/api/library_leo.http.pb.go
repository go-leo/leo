// Code generated by protoc-gen-leo. DO NOT EDIT.

package library

import (
	bytes "bytes"
	context "context"
	errors "errors"
	fmt "fmt"
	endpoint "github.com/go-kit/kit/endpoint"
	http1 "github.com/go-kit/kit/transport/http"
	httpx1 "github.com/go-leo/gox/netx/httpx"
	urlx "github.com/go-leo/gox/netx/urlx"
	strconvx "github.com/go-leo/gox/strconvx"
	endpointx "github.com/go-leo/leo/v3/endpointx"
	httpx "github.com/go-leo/leo/v3/transportx/httpx"
	coder "github.com/go-leo/leo/v3/transportx/httpx/coder"
	mux "github.com/gorilla/mux"
	protojson "google.golang.org/protobuf/encoding/protojson"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	io "io"
	http "net/http"
	url "net/url"
	strings "strings"
)

func appendLibraryServiceHttpRoutes(router *mux.Router) *mux.Router {
	router.NewRoute().
		Name("/google.example.library.v1.LibraryService/CreateShelf").
		Methods(http.MethodPost).
		Path("/v1/shelves")
	router.NewRoute().
		Name("/google.example.library.v1.LibraryService/GetShelf").
		Methods(http.MethodGet).
		Path("/v1/shelves/{shelf}")
	router.NewRoute().
		Name("/google.example.library.v1.LibraryService/ListShelves").
		Methods(http.MethodGet).
		Path("/v1/shelves")
	router.NewRoute().
		Name("/google.example.library.v1.LibraryService/DeleteShelf").
		Methods(http.MethodDelete).
		Path("/v1/shelves/{shelf}")
	router.NewRoute().
		Name("/google.example.library.v1.LibraryService/MergeShelves").
		Methods(http.MethodPost).
		Path("/v1/shelves/{shelf}:merge")
	router.NewRoute().
		Name("/google.example.library.v1.LibraryService/CreateBook").
		Methods(http.MethodPost).
		Path("/v1/shelves/{shelf}/books")
	router.NewRoute().
		Name("/google.example.library.v1.LibraryService/GetBook").
		Methods(http.MethodGet).
		Path("/v1/shelves/{shelf}/books/{book}")
	router.NewRoute().
		Name("/google.example.library.v1.LibraryService/ListBooks").
		Methods(http.MethodGet).
		Path("/v1/shelves/{shelf}/books")
	router.NewRoute().
		Name("/google.example.library.v1.LibraryService/DeleteBook").
		Methods(http.MethodDelete).
		Path("/v1/shelves/{shelf}/books/{book}")
	router.NewRoute().
		Name("/google.example.library.v1.LibraryService/UpdateBook").
		Methods(http.MethodPatch).
		Path("/v1/shelves/{shelf}/books/{book}")
	router.NewRoute().
		Name("/google.example.library.v1.LibraryService/MoveBook").
		Methods(http.MethodPost).
		Path("/v1/shelves/{shelf}/books/{book}:move")
	return router
}
func AppendLibraryServiceHttpServerRoutes(router *mux.Router, svc LibraryServiceService, middlewares ...endpoint.Middleware) *mux.Router {
	endpoints := &libraryServiceServerEndpoints{
		svc:         svc,
		middlewares: middlewares,
	}
	transports := &libraryServiceHttpServerTransports{
		endpoints:       endpoints,
		requestDecoder:  libraryServiceHttpServerRequestDecoder{},
		responseEncoder: libraryServiceHttpServerResponseEncoder{},
	}
	router = appendLibraryServiceHttpRoutes(router)
	router.Get("/google.example.library.v1.LibraryService/CreateShelf").Handler(transports.CreateShelf())
	router.Get("/google.example.library.v1.LibraryService/GetShelf").Handler(transports.GetShelf())
	router.Get("/google.example.library.v1.LibraryService/ListShelves").Handler(transports.ListShelves())
	router.Get("/google.example.library.v1.LibraryService/DeleteShelf").Handler(transports.DeleteShelf())
	router.Get("/google.example.library.v1.LibraryService/MergeShelves").Handler(transports.MergeShelves())
	router.Get("/google.example.library.v1.LibraryService/CreateBook").Handler(transports.CreateBook())
	router.Get("/google.example.library.v1.LibraryService/GetBook").Handler(transports.GetBook())
	router.Get("/google.example.library.v1.LibraryService/ListBooks").Handler(transports.ListBooks())
	router.Get("/google.example.library.v1.LibraryService/DeleteBook").Handler(transports.DeleteBook())
	router.Get("/google.example.library.v1.LibraryService/UpdateBook").Handler(transports.UpdateBook())
	router.Get("/google.example.library.v1.LibraryService/MoveBook").Handler(transports.MoveBook())
	return router
}

func NewLibraryServiceHttpClient(target string, opts ...httpx.ClientOption) LibraryServiceService {
	options := httpx.NewClientOptions(opts...)
	requestEncoder := &libraryServiceHttpClientRequestEncoder{
		marshalOptions:   protojson.MarshalOptions{},
		unmarshalOptions: protojson.UnmarshalOptions{},
		router:           appendLibraryServiceHttpRoutes(mux.NewRouter()),
		scheme:           options.Scheme(),
	}
	responseDecoder := &libraryServiceHttpClientResponseDecoder{}
	transports := &libraryServiceHttpClientTransports{
		clientOptions:   options.ClientTransportOptions(),
		middlewares:     options.Middlewares(),
		requestEncoder:  requestEncoder,
		responseDecoder: responseDecoder,
	}
	factories := &libraryServiceFactories{
		transports: transports,
	}
	endpointer := &libraryServiceEndpointers{
		target:    target,
		builder:   options.Builder(),
		factories: factories,
		logger:    options.Logger(),
		options:   options.EndpointerOptions(),
	}
	balancers := &libraryServiceBalancers{
		factory:    options.BalancerFactory(),
		endpointer: endpointer,
	}
	endpoints := &libraryServiceClientEndpoints{
		balancers: balancers,
	}
	return &libraryServiceClientService{
		endpoints:     endpoints,
		transportName: httpx.HttpClient,
	}
}

type LibraryServiceHttpServerTransports interface {
	CreateShelf() http.Handler
	GetShelf() http.Handler
	ListShelves() http.Handler
	DeleteShelf() http.Handler
	MergeShelves() http.Handler
	CreateBook() http.Handler
	GetBook() http.Handler
	ListBooks() http.Handler
	DeleteBook() http.Handler
	UpdateBook() http.Handler
	MoveBook() http.Handler
}

type LibraryServiceHttpServerRequestDecoder interface {
	CreateShelf() http1.DecodeRequestFunc
	GetShelf() http1.DecodeRequestFunc
	ListShelves() http1.DecodeRequestFunc
	DeleteShelf() http1.DecodeRequestFunc
	MergeShelves() http1.DecodeRequestFunc
	CreateBook() http1.DecodeRequestFunc
	GetBook() http1.DecodeRequestFunc
	ListBooks() http1.DecodeRequestFunc
	DeleteBook() http1.DecodeRequestFunc
	UpdateBook() http1.DecodeRequestFunc
	MoveBook() http1.DecodeRequestFunc
}

type LibraryServiceHttpServerResponseEncoder interface {
	CreateShelf() http1.EncodeResponseFunc
	GetShelf() http1.EncodeResponseFunc
	ListShelves() http1.EncodeResponseFunc
	DeleteShelf() http1.EncodeResponseFunc
	MergeShelves() http1.EncodeResponseFunc
	CreateBook() http1.EncodeResponseFunc
	GetBook() http1.EncodeResponseFunc
	ListBooks() http1.EncodeResponseFunc
	DeleteBook() http1.EncodeResponseFunc
	UpdateBook() http1.EncodeResponseFunc
	MoveBook() http1.EncodeResponseFunc
}

type LibraryServiceHttpClientRequestEncoder interface {
	CreateShelf(instance string) http1.CreateRequestFunc
	GetShelf(instance string) http1.CreateRequestFunc
	ListShelves(instance string) http1.CreateRequestFunc
	DeleteShelf(instance string) http1.CreateRequestFunc
	MergeShelves(instance string) http1.CreateRequestFunc
	CreateBook(instance string) http1.CreateRequestFunc
	GetBook(instance string) http1.CreateRequestFunc
	ListBooks(instance string) http1.CreateRequestFunc
	DeleteBook(instance string) http1.CreateRequestFunc
	UpdateBook(instance string) http1.CreateRequestFunc
	MoveBook(instance string) http1.CreateRequestFunc
}

type LibraryServiceHttpClientResponseDecoder interface {
	CreateShelf() http1.DecodeResponseFunc
	GetShelf() http1.DecodeResponseFunc
	ListShelves() http1.DecodeResponseFunc
	DeleteShelf() http1.DecodeResponseFunc
	MergeShelves() http1.DecodeResponseFunc
	CreateBook() http1.DecodeResponseFunc
	GetBook() http1.DecodeResponseFunc
	ListBooks() http1.DecodeResponseFunc
	DeleteBook() http1.DecodeResponseFunc
	UpdateBook() http1.DecodeResponseFunc
	MoveBook() http1.DecodeResponseFunc
}

type libraryServiceHttpServerTransports struct {
	endpoints       LibraryServiceServerEndpoints
	requestDecoder  LibraryServiceHttpServerRequestDecoder
	responseEncoder LibraryServiceHttpServerResponseEncoder
}

func (t *libraryServiceHttpServerTransports) CreateShelf() http.Handler {
	return http1.NewServer(
		t.endpoints.CreateShelf(context.TODO()),
		t.requestDecoder.CreateShelf(),
		t.responseEncoder.CreateShelf(),
		http1.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/CreateShelf")),
		http1.ServerBefore(httpx.ServerTransportInjector),
		http1.ServerBefore(httpx.IncomingMetadataInjector),
		http1.ServerBefore(httpx.IncomingTimeLimitInjector),
		http1.ServerBefore(httpx.IncomingStainInjector),
		http1.ServerFinalizer(httpx.CancelInvoker),
	)
}

func (t *libraryServiceHttpServerTransports) GetShelf() http.Handler {
	return http1.NewServer(
		t.endpoints.GetShelf(context.TODO()),
		t.requestDecoder.GetShelf(),
		t.responseEncoder.GetShelf(),
		http1.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/GetShelf")),
		http1.ServerBefore(httpx.ServerTransportInjector),
		http1.ServerBefore(httpx.IncomingMetadataInjector),
		http1.ServerBefore(httpx.IncomingTimeLimitInjector),
		http1.ServerBefore(httpx.IncomingStainInjector),
		http1.ServerFinalizer(httpx.CancelInvoker),
	)
}

func (t *libraryServiceHttpServerTransports) ListShelves() http.Handler {
	return http1.NewServer(
		t.endpoints.ListShelves(context.TODO()),
		t.requestDecoder.ListShelves(),
		t.responseEncoder.ListShelves(),
		http1.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/ListShelves")),
		http1.ServerBefore(httpx.ServerTransportInjector),
		http1.ServerBefore(httpx.IncomingMetadataInjector),
		http1.ServerBefore(httpx.IncomingTimeLimitInjector),
		http1.ServerBefore(httpx.IncomingStainInjector),
		http1.ServerFinalizer(httpx.CancelInvoker),
	)
}

func (t *libraryServiceHttpServerTransports) DeleteShelf() http.Handler {
	return http1.NewServer(
		t.endpoints.DeleteShelf(context.TODO()),
		t.requestDecoder.DeleteShelf(),
		t.responseEncoder.DeleteShelf(),
		http1.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/DeleteShelf")),
		http1.ServerBefore(httpx.ServerTransportInjector),
		http1.ServerBefore(httpx.IncomingMetadataInjector),
		http1.ServerBefore(httpx.IncomingTimeLimitInjector),
		http1.ServerBefore(httpx.IncomingStainInjector),
		http1.ServerFinalizer(httpx.CancelInvoker),
	)
}

func (t *libraryServiceHttpServerTransports) MergeShelves() http.Handler {
	return http1.NewServer(
		t.endpoints.MergeShelves(context.TODO()),
		t.requestDecoder.MergeShelves(),
		t.responseEncoder.MergeShelves(),
		http1.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/MergeShelves")),
		http1.ServerBefore(httpx.ServerTransportInjector),
		http1.ServerBefore(httpx.IncomingMetadataInjector),
		http1.ServerBefore(httpx.IncomingTimeLimitInjector),
		http1.ServerBefore(httpx.IncomingStainInjector),
		http1.ServerFinalizer(httpx.CancelInvoker),
	)
}

func (t *libraryServiceHttpServerTransports) CreateBook() http.Handler {
	return http1.NewServer(
		t.endpoints.CreateBook(context.TODO()),
		t.requestDecoder.CreateBook(),
		t.responseEncoder.CreateBook(),
		http1.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/CreateBook")),
		http1.ServerBefore(httpx.ServerTransportInjector),
		http1.ServerBefore(httpx.IncomingMetadataInjector),
		http1.ServerBefore(httpx.IncomingTimeLimitInjector),
		http1.ServerBefore(httpx.IncomingStainInjector),
		http1.ServerFinalizer(httpx.CancelInvoker),
	)
}

func (t *libraryServiceHttpServerTransports) GetBook() http.Handler {
	return http1.NewServer(
		t.endpoints.GetBook(context.TODO()),
		t.requestDecoder.GetBook(),
		t.responseEncoder.GetBook(),
		http1.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/GetBook")),
		http1.ServerBefore(httpx.ServerTransportInjector),
		http1.ServerBefore(httpx.IncomingMetadataInjector),
		http1.ServerBefore(httpx.IncomingTimeLimitInjector),
		http1.ServerBefore(httpx.IncomingStainInjector),
		http1.ServerFinalizer(httpx.CancelInvoker),
	)
}

func (t *libraryServiceHttpServerTransports) ListBooks() http.Handler {
	return http1.NewServer(
		t.endpoints.ListBooks(context.TODO()),
		t.requestDecoder.ListBooks(),
		t.responseEncoder.ListBooks(),
		http1.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/ListBooks")),
		http1.ServerBefore(httpx.ServerTransportInjector),
		http1.ServerBefore(httpx.IncomingMetadataInjector),
		http1.ServerBefore(httpx.IncomingTimeLimitInjector),
		http1.ServerBefore(httpx.IncomingStainInjector),
		http1.ServerFinalizer(httpx.CancelInvoker),
	)
}

func (t *libraryServiceHttpServerTransports) DeleteBook() http.Handler {
	return http1.NewServer(
		t.endpoints.DeleteBook(context.TODO()),
		t.requestDecoder.DeleteBook(),
		t.responseEncoder.DeleteBook(),
		http1.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/DeleteBook")),
		http1.ServerBefore(httpx.ServerTransportInjector),
		http1.ServerBefore(httpx.IncomingMetadataInjector),
		http1.ServerBefore(httpx.IncomingTimeLimitInjector),
		http1.ServerBefore(httpx.IncomingStainInjector),
		http1.ServerFinalizer(httpx.CancelInvoker),
	)
}

func (t *libraryServiceHttpServerTransports) UpdateBook() http.Handler {
	return http1.NewServer(
		t.endpoints.UpdateBook(context.TODO()),
		t.requestDecoder.UpdateBook(),
		t.responseEncoder.UpdateBook(),
		http1.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/UpdateBook")),
		http1.ServerBefore(httpx.ServerTransportInjector),
		http1.ServerBefore(httpx.IncomingMetadataInjector),
		http1.ServerBefore(httpx.IncomingTimeLimitInjector),
		http1.ServerBefore(httpx.IncomingStainInjector),
		http1.ServerFinalizer(httpx.CancelInvoker),
	)
}

func (t *libraryServiceHttpServerTransports) MoveBook() http.Handler {
	return http1.NewServer(
		t.endpoints.MoveBook(context.TODO()),
		t.requestDecoder.MoveBook(),
		t.responseEncoder.MoveBook(),
		http1.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/MoveBook")),
		http1.ServerBefore(httpx.ServerTransportInjector),
		http1.ServerBefore(httpx.IncomingMetadataInjector),
		http1.ServerBefore(httpx.IncomingTimeLimitInjector),
		http1.ServerBefore(httpx.IncomingStainInjector),
		http1.ServerFinalizer(httpx.CancelInvoker),
	)
}

type libraryServiceHttpServerRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder libraryServiceHttpServerRequestDecoder) CreateShelf() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &CreateShelfRequest{}
		req.Shelf = &Shelf{}
		if err := coder.DecodeMessageFromRequest(ctx, r, req.GetShelf(), decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return req, nil
	}
}
func (decoder libraryServiceHttpServerRequestDecoder) GetShelf() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &GetShelfRequest{}
		vars := urlx.FormFromMap(mux.Vars(r))
		req.Name = fmt.Sprintf("shelves/%s", vars.Get("shelf"))
		return req, nil
	}
}
func (decoder libraryServiceHttpServerRequestDecoder) ListShelves() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &ListShelvesRequest{}
		queries := r.URL.Query()
		var queryErr error
		req.PageSize, queryErr = coder.DecodeForm[int32](queryErr, queries, "page_size", urlx.GetInt[int32])
		req.PageToken = queries.Get("page_token")
		if queryErr != nil {
			return nil, queryErr
		}
		return req, nil
	}
}
func (decoder libraryServiceHttpServerRequestDecoder) DeleteShelf() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &DeleteShelfRequest{}
		vars := urlx.FormFromMap(mux.Vars(r))
		req.Name = fmt.Sprintf("shelves/%s", vars.Get("shelf"))
		return req, nil
	}
}
func (decoder libraryServiceHttpServerRequestDecoder) MergeShelves() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &MergeShelvesRequest{}
		if err := coder.DecodeMessageFromRequest(ctx, r, req, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		vars := urlx.FormFromMap(mux.Vars(r))
		req.Name = fmt.Sprintf("shelves/%s", vars.Get("shelf"))
		return req, nil
	}
}
func (decoder libraryServiceHttpServerRequestDecoder) CreateBook() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &CreateBookRequest{}
		req.Book = &Book{}
		if err := coder.DecodeMessageFromRequest(ctx, r, req.GetBook(), decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		vars := urlx.FormFromMap(mux.Vars(r))
		req.Parent = fmt.Sprintf("shelves/%s", vars.Get("shelf"))
		return req, nil
	}
}
func (decoder libraryServiceHttpServerRequestDecoder) GetBook() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &GetBookRequest{}
		vars := urlx.FormFromMap(mux.Vars(r))
		req.Name = fmt.Sprintf("shelves/%s/books/%s", vars.Get("shelf"), vars.Get("book"))
		return req, nil
	}
}
func (decoder libraryServiceHttpServerRequestDecoder) ListBooks() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &ListBooksRequest{}
		vars := urlx.FormFromMap(mux.Vars(r))
		req.Parent = fmt.Sprintf("shelves/%s", vars.Get("shelf"))
		queries := r.URL.Query()
		var queryErr error
		req.PageSize, queryErr = coder.DecodeForm[int32](queryErr, queries, "page_size", urlx.GetInt[int32])
		req.PageToken = queries.Get("page_token")
		if queryErr != nil {
			return nil, queryErr
		}
		return req, nil
	}
}
func (decoder libraryServiceHttpServerRequestDecoder) DeleteBook() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &DeleteBookRequest{}
		vars := urlx.FormFromMap(mux.Vars(r))
		req.Name = fmt.Sprintf("shelves/%s/books/%s", vars.Get("shelf"), vars.Get("book"))
		return req, nil
	}
}
func (decoder libraryServiceHttpServerRequestDecoder) UpdateBook() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &UpdateBookRequest{}
		req.Book = &Book{}
		if err := coder.DecodeMessageFromRequest(ctx, r, req.GetBook(), decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		vars := urlx.FormFromMap(mux.Vars(r))
		if req.Book == nil {
			req.Book = &Book{}
		}
		req.Book.Name = fmt.Sprintf("shelves/%s/books/%s", vars.Get("shelf"), vars.Get("book"))
		return req, nil
	}
}
func (decoder libraryServiceHttpServerRequestDecoder) MoveBook() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &MoveBookRequest{}
		if err := coder.DecodeMessageFromRequest(ctx, r, req, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		vars := urlx.FormFromMap(mux.Vars(r))
		req.Name = fmt.Sprintf("shelves/%s/books/%s", vars.Get("shelf"), vars.Get("book"))
		return req, nil
	}
}

type libraryServiceHttpServerResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer coder.ResponseTransformer
}

func (encoder libraryServiceHttpServerResponseEncoder) CreateShelf() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*Shelf)
		return coder.EncodeMessageToResponse(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
	}
}
func (encoder libraryServiceHttpServerResponseEncoder) GetShelf() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*Shelf)
		return coder.EncodeMessageToResponse(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
	}
}
func (encoder libraryServiceHttpServerResponseEncoder) ListShelves() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*ListShelvesResponse)
		return coder.EncodeMessageToResponse(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
	}
}
func (encoder libraryServiceHttpServerResponseEncoder) DeleteShelf() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*emptypb.Empty)
		return coder.EncodeMessageToResponse(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
	}
}
func (encoder libraryServiceHttpServerResponseEncoder) MergeShelves() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*Shelf)
		return coder.EncodeMessageToResponse(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
	}
}
func (encoder libraryServiceHttpServerResponseEncoder) CreateBook() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*Book)
		return coder.EncodeMessageToResponse(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
	}
}
func (encoder libraryServiceHttpServerResponseEncoder) GetBook() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*Book)
		return coder.EncodeMessageToResponse(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
	}
}
func (encoder libraryServiceHttpServerResponseEncoder) ListBooks() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*ListBooksResponse)
		return coder.EncodeMessageToResponse(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
	}
}
func (encoder libraryServiceHttpServerResponseEncoder) DeleteBook() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*emptypb.Empty)
		return coder.EncodeMessageToResponse(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
	}
}
func (encoder libraryServiceHttpServerResponseEncoder) UpdateBook() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*Book)
		return coder.EncodeMessageToResponse(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
	}
}
func (encoder libraryServiceHttpServerResponseEncoder) MoveBook() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*Book)
		return coder.EncodeMessageToResponse(ctx, w, encoder.responseTransformer(ctx, resp), encoder.marshalOptions)
	}
}

type libraryServiceHttpClientTransports struct {
	clientOptions   []http1.ClientOption
	middlewares     []endpoint.Middleware
	requestEncoder  LibraryServiceHttpClientRequestEncoder
	responseDecoder LibraryServiceHttpClientResponseDecoder
}

func (t *libraryServiceHttpClientTransports) CreateShelf(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(httpx.OutgoingMetadataInjector),
		http1.ClientBefore(httpx.OutgoingTimeLimitInjector),
		http1.ClientBefore(httpx.OutgoingStainInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.CreateShelf(instance),
		t.responseDecoder.CreateShelf(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func (t *libraryServiceHttpClientTransports) GetShelf(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(httpx.OutgoingMetadataInjector),
		http1.ClientBefore(httpx.OutgoingTimeLimitInjector),
		http1.ClientBefore(httpx.OutgoingStainInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.GetShelf(instance),
		t.responseDecoder.GetShelf(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func (t *libraryServiceHttpClientTransports) ListShelves(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(httpx.OutgoingMetadataInjector),
		http1.ClientBefore(httpx.OutgoingTimeLimitInjector),
		http1.ClientBefore(httpx.OutgoingStainInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.ListShelves(instance),
		t.responseDecoder.ListShelves(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func (t *libraryServiceHttpClientTransports) DeleteShelf(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(httpx.OutgoingMetadataInjector),
		http1.ClientBefore(httpx.OutgoingTimeLimitInjector),
		http1.ClientBefore(httpx.OutgoingStainInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.DeleteShelf(instance),
		t.responseDecoder.DeleteShelf(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func (t *libraryServiceHttpClientTransports) MergeShelves(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(httpx.OutgoingMetadataInjector),
		http1.ClientBefore(httpx.OutgoingTimeLimitInjector),
		http1.ClientBefore(httpx.OutgoingStainInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.MergeShelves(instance),
		t.responseDecoder.MergeShelves(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func (t *libraryServiceHttpClientTransports) CreateBook(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(httpx.OutgoingMetadataInjector),
		http1.ClientBefore(httpx.OutgoingTimeLimitInjector),
		http1.ClientBefore(httpx.OutgoingStainInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.CreateBook(instance),
		t.responseDecoder.CreateBook(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func (t *libraryServiceHttpClientTransports) GetBook(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(httpx.OutgoingMetadataInjector),
		http1.ClientBefore(httpx.OutgoingTimeLimitInjector),
		http1.ClientBefore(httpx.OutgoingStainInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.GetBook(instance),
		t.responseDecoder.GetBook(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func (t *libraryServiceHttpClientTransports) ListBooks(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(httpx.OutgoingMetadataInjector),
		http1.ClientBefore(httpx.OutgoingTimeLimitInjector),
		http1.ClientBefore(httpx.OutgoingStainInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.ListBooks(instance),
		t.responseDecoder.ListBooks(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func (t *libraryServiceHttpClientTransports) DeleteBook(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(httpx.OutgoingMetadataInjector),
		http1.ClientBefore(httpx.OutgoingTimeLimitInjector),
		http1.ClientBefore(httpx.OutgoingStainInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.DeleteBook(instance),
		t.responseDecoder.DeleteBook(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func (t *libraryServiceHttpClientTransports) UpdateBook(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(httpx.OutgoingMetadataInjector),
		http1.ClientBefore(httpx.OutgoingTimeLimitInjector),
		http1.ClientBefore(httpx.OutgoingStainInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.UpdateBook(instance),
		t.responseDecoder.UpdateBook(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func (t *libraryServiceHttpClientTransports) MoveBook(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(httpx.OutgoingMetadataInjector),
		http1.ClientBefore(httpx.OutgoingTimeLimitInjector),
		http1.ClientBefore(httpx.OutgoingStainInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.MoveBook(instance),
		t.responseDecoder.MoveBook(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

type libraryServiceHttpClientRequestEncoder struct {
	marshalOptions   protojson.MarshalOptions
	unmarshalOptions protojson.UnmarshalOptions
	router           *mux.Router
	scheme           string
}

func (encoder libraryServiceHttpClientRequestEncoder) CreateShelf(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*CreateShelfRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodPost
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		if err := coder.EncodeMessageToRequest(ctx, req.GetShelf(), header, &body, encoder.marshalOptions); err != nil {
			return nil, err
		}
		var pairs []string
		path, err := encoder.router.Get("/google.example.library.v1.LibraryService/CreateShelf").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx1.CopyHeader(r.Header, header)
		return r, nil
	}
}
func (encoder libraryServiceHttpClientRequestEncoder) GetShelf(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*GetShelfRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodGet
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		var pairs []string
		namedPathParameter := req.GetName()
		namedPathValues := strings.Split(namedPathParameter, "/")
		if len(namedPathValues) != 2 {
			return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
		}
		pairs = append(pairs,
			"shelf", namedPathValues[1],
		)
		path, err := encoder.router.Get("/google.example.library.v1.LibraryService/GetShelf").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx1.CopyHeader(r.Header, header)
		return r, nil
	}
}
func (encoder libraryServiceHttpClientRequestEncoder) ListShelves(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*ListShelvesRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodGet
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		var pairs []string
		path, err := encoder.router.Get("/google.example.library.v1.LibraryService/ListShelves").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		queries := url.Values{}
		queries["page_size"] = append(queries["page_size"], strconvx.FormatInt(req.GetPageSize(), 10))
		queries["page_token"] = append(queries["page_token"], req.GetPageToken())
		target.RawQuery = queries.Encode()
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx1.CopyHeader(r.Header, header)
		return r, nil
	}
}
func (encoder libraryServiceHttpClientRequestEncoder) DeleteShelf(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*DeleteShelfRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodDelete
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		var pairs []string
		namedPathParameter := req.GetName()
		namedPathValues := strings.Split(namedPathParameter, "/")
		if len(namedPathValues) != 2 {
			return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
		}
		pairs = append(pairs,
			"shelf", namedPathValues[1],
		)
		path, err := encoder.router.Get("/google.example.library.v1.LibraryService/DeleteShelf").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx1.CopyHeader(r.Header, header)
		return r, nil
	}
}
func (encoder libraryServiceHttpClientRequestEncoder) MergeShelves(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*MergeShelvesRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodPost
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		if err := coder.EncodeMessageToRequest(ctx, req, header, &body, encoder.marshalOptions); err != nil {
			return nil, err
		}
		var pairs []string
		namedPathParameter := req.GetName()
		namedPathValues := strings.Split(namedPathParameter, "/")
		if len(namedPathValues) != 2 {
			return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
		}
		pairs = append(pairs,
			"shelf", namedPathValues[1],
		)
		path, err := encoder.router.Get("/google.example.library.v1.LibraryService/MergeShelves").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx1.CopyHeader(r.Header, header)
		return r, nil
	}
}
func (encoder libraryServiceHttpClientRequestEncoder) CreateBook(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*CreateBookRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodPost
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		if err := coder.EncodeMessageToRequest(ctx, req.GetBook(), header, &body, encoder.marshalOptions); err != nil {
			return nil, err
		}
		var pairs []string
		namedPathParameter := req.GetParent()
		namedPathValues := strings.Split(namedPathParameter, "/")
		if len(namedPathValues) != 2 {
			return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
		}
		pairs = append(pairs,
			"shelf", namedPathValues[1],
		)
		path, err := encoder.router.Get("/google.example.library.v1.LibraryService/CreateBook").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx1.CopyHeader(r.Header, header)
		return r, nil
	}
}
func (encoder libraryServiceHttpClientRequestEncoder) GetBook(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*GetBookRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodGet
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		var pairs []string
		namedPathParameter := req.GetName()
		namedPathValues := strings.Split(namedPathParameter, "/")
		if len(namedPathValues) != 4 {
			return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
		}
		pairs = append(pairs,
			"shelf", namedPathValues[1],
			"book", namedPathValues[3],
		)
		path, err := encoder.router.Get("/google.example.library.v1.LibraryService/GetBook").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx1.CopyHeader(r.Header, header)
		return r, nil
	}
}
func (encoder libraryServiceHttpClientRequestEncoder) ListBooks(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*ListBooksRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodGet
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		var pairs []string
		namedPathParameter := req.GetParent()
		namedPathValues := strings.Split(namedPathParameter, "/")
		if len(namedPathValues) != 2 {
			return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
		}
		pairs = append(pairs,
			"shelf", namedPathValues[1],
		)
		path, err := encoder.router.Get("/google.example.library.v1.LibraryService/ListBooks").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		queries := url.Values{}
		queries["page_size"] = append(queries["page_size"], strconvx.FormatInt(req.GetPageSize(), 10))
		queries["page_token"] = append(queries["page_token"], req.GetPageToken())
		target.RawQuery = queries.Encode()
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx1.CopyHeader(r.Header, header)
		return r, nil
	}
}
func (encoder libraryServiceHttpClientRequestEncoder) DeleteBook(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*DeleteBookRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodDelete
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		var pairs []string
		namedPathParameter := req.GetName()
		namedPathValues := strings.Split(namedPathParameter, "/")
		if len(namedPathValues) != 4 {
			return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
		}
		pairs = append(pairs,
			"shelf", namedPathValues[1],
			"book", namedPathValues[3],
		)
		path, err := encoder.router.Get("/google.example.library.v1.LibraryService/DeleteBook").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx1.CopyHeader(r.Header, header)
		return r, nil
	}
}
func (encoder libraryServiceHttpClientRequestEncoder) UpdateBook(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*UpdateBookRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodPatch
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		if err := coder.EncodeMessageToRequest(ctx, req.GetBook(), header, &body, encoder.marshalOptions); err != nil {
			return nil, err
		}
		var pairs []string
		namedPathParameter := req.GetBook().GetName()
		namedPathValues := strings.Split(namedPathParameter, "/")
		if len(namedPathValues) != 4 {
			return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
		}
		pairs = append(pairs,
			"shelf", namedPathValues[1],
			"book", namedPathValues[3],
		)
		path, err := encoder.router.Get("/google.example.library.v1.LibraryService/UpdateBook").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx1.CopyHeader(r.Header, header)
		return r, nil
	}
}
func (encoder libraryServiceHttpClientRequestEncoder) MoveBook(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*MoveBookRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodPost
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		if err := coder.EncodeMessageToRequest(ctx, req, header, &body, encoder.marshalOptions); err != nil {
			return nil, err
		}
		var pairs []string
		namedPathParameter := req.GetName()
		namedPathValues := strings.Split(namedPathParameter, "/")
		if len(namedPathValues) != 4 {
			return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
		}
		pairs = append(pairs,
			"shelf", namedPathValues[1],
			"book", namedPathValues[3],
		)
		path, err := encoder.router.Get("/google.example.library.v1.LibraryService/MoveBook").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx1.CopyHeader(r.Header, header)
		return r, nil
	}
}

type libraryServiceHttpClientResponseDecoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer coder.ResponseTransformer
}

func (decoder libraryServiceHttpClientResponseDecoder) CreateShelf() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		resp := &Shelf{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}
func (decoder libraryServiceHttpClientResponseDecoder) GetShelf() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		resp := &Shelf{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}
func (decoder libraryServiceHttpClientResponseDecoder) ListShelves() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		resp := &ListShelvesResponse{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}
func (decoder libraryServiceHttpClientResponseDecoder) DeleteShelf() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		resp := &emptypb.Empty{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}
func (decoder libraryServiceHttpClientResponseDecoder) MergeShelves() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		resp := &Shelf{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}
func (decoder libraryServiceHttpClientResponseDecoder) CreateBook() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		resp := &Book{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}
func (decoder libraryServiceHttpClientResponseDecoder) GetBook() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		resp := &Book{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}
func (decoder libraryServiceHttpClientResponseDecoder) ListBooks() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		resp := &ListBooksResponse{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}
func (decoder libraryServiceHttpClientResponseDecoder) DeleteBook() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		resp := &emptypb.Empty{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}
func (decoder libraryServiceHttpClientResponseDecoder) UpdateBook() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		resp := &Book{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}
func (decoder libraryServiceHttpClientResponseDecoder) MoveBook() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		resp := &Book{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}
