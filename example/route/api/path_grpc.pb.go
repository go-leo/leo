// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.24.3
// source: api/path.proto

package api

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	BoolPath_BoolPath_FullMethodName = "/leo.example.route.path.BoolPath/BoolPath"
)

// BoolPathClient is the client API for BoolPath service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BoolPathClient interface {
	BoolPath(ctx context.Context, in *BoolPathRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type boolPathClient struct {
	cc grpc.ClientConnInterface
}

func NewBoolPathClient(cc grpc.ClientConnInterface) BoolPathClient {
	return &boolPathClient{cc}
}

func (c *boolPathClient) BoolPath(ctx context.Context, in *BoolPathRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, BoolPath_BoolPath_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BoolPathServer is the server API for BoolPath service.
// All implementations must embed UnimplementedBoolPathServer
// for forward compatibility
type BoolPathServer interface {
	BoolPath(context.Context, *BoolPathRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedBoolPathServer()
}

// UnimplementedBoolPathServer must be embedded to have forward compatible implementations.
type UnimplementedBoolPathServer struct {
}

func (UnimplementedBoolPathServer) BoolPath(context.Context, *BoolPathRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoolPath not implemented")
}
func (UnimplementedBoolPathServer) mustEmbedUnimplementedBoolPathServer() {}

// UnsafeBoolPathServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BoolPathServer will
// result in compilation errors.
type UnsafeBoolPathServer interface {
	mustEmbedUnimplementedBoolPathServer()
}

func RegisterBoolPathServer(s grpc.ServiceRegistrar, srv BoolPathServer) {
	s.RegisterService(&BoolPath_ServiceDesc, srv)
}

func _BoolPath_BoolPath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoolPathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoolPathServer).BoolPath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BoolPath_BoolPath_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoolPathServer).BoolPath(ctx, req.(*BoolPathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BoolPath_ServiceDesc is the grpc.ServiceDesc for BoolPath service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BoolPath_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "leo.example.route.path.BoolPath",
	HandlerType: (*BoolPathServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BoolPath",
			Handler:    _BoolPath_BoolPath_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/path.proto",
}

const (
	Int32Path_Int32Path_FullMethodName = "/leo.example.route.path.Int32Path/Int32Path"
)

// Int32PathClient is the client API for Int32Path service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Int32PathClient interface {
	Int32Path(ctx context.Context, in *Int32PathRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type int32PathClient struct {
	cc grpc.ClientConnInterface
}

func NewInt32PathClient(cc grpc.ClientConnInterface) Int32PathClient {
	return &int32PathClient{cc}
}

func (c *int32PathClient) Int32Path(ctx context.Context, in *Int32PathRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Int32Path_Int32Path_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Int32PathServer is the server API for Int32Path service.
// All implementations must embed UnimplementedInt32PathServer
// for forward compatibility
type Int32PathServer interface {
	Int32Path(context.Context, *Int32PathRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedInt32PathServer()
}

// UnimplementedInt32PathServer must be embedded to have forward compatible implementations.
type UnimplementedInt32PathServer struct {
}

func (UnimplementedInt32PathServer) Int32Path(context.Context, *Int32PathRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Int32Path not implemented")
}
func (UnimplementedInt32PathServer) mustEmbedUnimplementedInt32PathServer() {}

// UnsafeInt32PathServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Int32PathServer will
// result in compilation errors.
type UnsafeInt32PathServer interface {
	mustEmbedUnimplementedInt32PathServer()
}

func RegisterInt32PathServer(s grpc.ServiceRegistrar, srv Int32PathServer) {
	s.RegisterService(&Int32Path_ServiceDesc, srv)
}

func _Int32Path_Int32Path_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Int32PathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Int32PathServer).Int32Path(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Int32Path_Int32Path_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Int32PathServer).Int32Path(ctx, req.(*Int32PathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Int32Path_ServiceDesc is the grpc.ServiceDesc for Int32Path service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Int32Path_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "leo.example.route.path.Int32Path",
	HandlerType: (*Int32PathServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Int32Path",
			Handler:    _Int32Path_Int32Path_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/path.proto",
}

const (
	Int64Path_Int64Path_FullMethodName = "/leo.example.route.path.Int64Path/Int64Path"
)

// Int64PathClient is the client API for Int64Path service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Int64PathClient interface {
	Int64Path(ctx context.Context, in *Int64PathRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type int64PathClient struct {
	cc grpc.ClientConnInterface
}

func NewInt64PathClient(cc grpc.ClientConnInterface) Int64PathClient {
	return &int64PathClient{cc}
}

func (c *int64PathClient) Int64Path(ctx context.Context, in *Int64PathRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Int64Path_Int64Path_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Int64PathServer is the server API for Int64Path service.
// All implementations must embed UnimplementedInt64PathServer
// for forward compatibility
type Int64PathServer interface {
	Int64Path(context.Context, *Int64PathRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedInt64PathServer()
}

// UnimplementedInt64PathServer must be embedded to have forward compatible implementations.
type UnimplementedInt64PathServer struct {
}

func (UnimplementedInt64PathServer) Int64Path(context.Context, *Int64PathRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Int64Path not implemented")
}
func (UnimplementedInt64PathServer) mustEmbedUnimplementedInt64PathServer() {}

// UnsafeInt64PathServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Int64PathServer will
// result in compilation errors.
type UnsafeInt64PathServer interface {
	mustEmbedUnimplementedInt64PathServer()
}

func RegisterInt64PathServer(s grpc.ServiceRegistrar, srv Int64PathServer) {
	s.RegisterService(&Int64Path_ServiceDesc, srv)
}

func _Int64Path_Int64Path_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Int64PathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Int64PathServer).Int64Path(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Int64Path_Int64Path_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Int64PathServer).Int64Path(ctx, req.(*Int64PathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Int64Path_ServiceDesc is the grpc.ServiceDesc for Int64Path service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Int64Path_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "leo.example.route.path.Int64Path",
	HandlerType: (*Int64PathServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Int64Path",
			Handler:    _Int64Path_Int64Path_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/path.proto",
}

const (
	Uint32Path_Uint32Path_FullMethodName = "/leo.example.route.path.Uint32Path/Uint32Path"
)

// Uint32PathClient is the client API for Uint32Path service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Uint32PathClient interface {
	Uint32Path(ctx context.Context, in *Uint32PathRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type uint32PathClient struct {
	cc grpc.ClientConnInterface
}

func NewUint32PathClient(cc grpc.ClientConnInterface) Uint32PathClient {
	return &uint32PathClient{cc}
}

func (c *uint32PathClient) Uint32Path(ctx context.Context, in *Uint32PathRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Uint32Path_Uint32Path_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Uint32PathServer is the server API for Uint32Path service.
// All implementations must embed UnimplementedUint32PathServer
// for forward compatibility
type Uint32PathServer interface {
	Uint32Path(context.Context, *Uint32PathRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedUint32PathServer()
}

// UnimplementedUint32PathServer must be embedded to have forward compatible implementations.
type UnimplementedUint32PathServer struct {
}

func (UnimplementedUint32PathServer) Uint32Path(context.Context, *Uint32PathRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Uint32Path not implemented")
}
func (UnimplementedUint32PathServer) mustEmbedUnimplementedUint32PathServer() {}

// UnsafeUint32PathServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Uint32PathServer will
// result in compilation errors.
type UnsafeUint32PathServer interface {
	mustEmbedUnimplementedUint32PathServer()
}

func RegisterUint32PathServer(s grpc.ServiceRegistrar, srv Uint32PathServer) {
	s.RegisterService(&Uint32Path_ServiceDesc, srv)
}

func _Uint32Path_Uint32Path_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Uint32PathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Uint32PathServer).Uint32Path(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Uint32Path_Uint32Path_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Uint32PathServer).Uint32Path(ctx, req.(*Uint32PathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Uint32Path_ServiceDesc is the grpc.ServiceDesc for Uint32Path service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Uint32Path_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "leo.example.route.path.Uint32Path",
	HandlerType: (*Uint32PathServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Uint32Path",
			Handler:    _Uint32Path_Uint32Path_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/path.proto",
}

const (
	Uint64Path_Uint64Path_FullMethodName = "/leo.example.route.path.Uint64Path/Uint64Path"
)

// Uint64PathClient is the client API for Uint64Path service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Uint64PathClient interface {
	Uint64Path(ctx context.Context, in *Uint64PathRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type uint64PathClient struct {
	cc grpc.ClientConnInterface
}

func NewUint64PathClient(cc grpc.ClientConnInterface) Uint64PathClient {
	return &uint64PathClient{cc}
}

func (c *uint64PathClient) Uint64Path(ctx context.Context, in *Uint64PathRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Uint64Path_Uint64Path_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Uint64PathServer is the server API for Uint64Path service.
// All implementations must embed UnimplementedUint64PathServer
// for forward compatibility
type Uint64PathServer interface {
	Uint64Path(context.Context, *Uint64PathRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedUint64PathServer()
}

// UnimplementedUint64PathServer must be embedded to have forward compatible implementations.
type UnimplementedUint64PathServer struct {
}

func (UnimplementedUint64PathServer) Uint64Path(context.Context, *Uint64PathRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Uint64Path not implemented")
}
func (UnimplementedUint64PathServer) mustEmbedUnimplementedUint64PathServer() {}

// UnsafeUint64PathServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Uint64PathServer will
// result in compilation errors.
type UnsafeUint64PathServer interface {
	mustEmbedUnimplementedUint64PathServer()
}

func RegisterUint64PathServer(s grpc.ServiceRegistrar, srv Uint64PathServer) {
	s.RegisterService(&Uint64Path_ServiceDesc, srv)
}

func _Uint64Path_Uint64Path_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Uint64PathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Uint64PathServer).Uint64Path(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Uint64Path_Uint64Path_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Uint64PathServer).Uint64Path(ctx, req.(*Uint64PathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Uint64Path_ServiceDesc is the grpc.ServiceDesc for Uint64Path service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Uint64Path_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "leo.example.route.path.Uint64Path",
	HandlerType: (*Uint64PathServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Uint64Path",
			Handler:    _Uint64Path_Uint64Path_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/path.proto",
}

const (
	FloatPath_FloatPath_FullMethodName = "/leo.example.route.path.FloatPath/FloatPath"
)

// FloatPathClient is the client API for FloatPath service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FloatPathClient interface {
	FloatPath(ctx context.Context, in *FloatPathRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type floatPathClient struct {
	cc grpc.ClientConnInterface
}

func NewFloatPathClient(cc grpc.ClientConnInterface) FloatPathClient {
	return &floatPathClient{cc}
}

func (c *floatPathClient) FloatPath(ctx context.Context, in *FloatPathRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FloatPath_FloatPath_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FloatPathServer is the server API for FloatPath service.
// All implementations must embed UnimplementedFloatPathServer
// for forward compatibility
type FloatPathServer interface {
	FloatPath(context.Context, *FloatPathRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedFloatPathServer()
}

// UnimplementedFloatPathServer must be embedded to have forward compatible implementations.
type UnimplementedFloatPathServer struct {
}

func (UnimplementedFloatPathServer) FloatPath(context.Context, *FloatPathRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FloatPath not implemented")
}
func (UnimplementedFloatPathServer) mustEmbedUnimplementedFloatPathServer() {}

// UnsafeFloatPathServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FloatPathServer will
// result in compilation errors.
type UnsafeFloatPathServer interface {
	mustEmbedUnimplementedFloatPathServer()
}

func RegisterFloatPathServer(s grpc.ServiceRegistrar, srv FloatPathServer) {
	s.RegisterService(&FloatPath_ServiceDesc, srv)
}

func _FloatPath_FloatPath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FloatPathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FloatPathServer).FloatPath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FloatPath_FloatPath_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FloatPathServer).FloatPath(ctx, req.(*FloatPathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FloatPath_ServiceDesc is the grpc.ServiceDesc for FloatPath service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FloatPath_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "leo.example.route.path.FloatPath",
	HandlerType: (*FloatPathServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FloatPath",
			Handler:    _FloatPath_FloatPath_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/path.proto",
}

const (
	DoublePath_DoublePath_FullMethodName = "/leo.example.route.path.DoublePath/DoublePath"
)

// DoublePathClient is the client API for DoublePath service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DoublePathClient interface {
	DoublePath(ctx context.Context, in *DoublePathRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type doublePathClient struct {
	cc grpc.ClientConnInterface
}

func NewDoublePathClient(cc grpc.ClientConnInterface) DoublePathClient {
	return &doublePathClient{cc}
}

func (c *doublePathClient) DoublePath(ctx context.Context, in *DoublePathRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, DoublePath_DoublePath_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DoublePathServer is the server API for DoublePath service.
// All implementations must embed UnimplementedDoublePathServer
// for forward compatibility
type DoublePathServer interface {
	DoublePath(context.Context, *DoublePathRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedDoublePathServer()
}

// UnimplementedDoublePathServer must be embedded to have forward compatible implementations.
type UnimplementedDoublePathServer struct {
}

func (UnimplementedDoublePathServer) DoublePath(context.Context, *DoublePathRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DoublePath not implemented")
}
func (UnimplementedDoublePathServer) mustEmbedUnimplementedDoublePathServer() {}

// UnsafeDoublePathServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DoublePathServer will
// result in compilation errors.
type UnsafeDoublePathServer interface {
	mustEmbedUnimplementedDoublePathServer()
}

func RegisterDoublePathServer(s grpc.ServiceRegistrar, srv DoublePathServer) {
	s.RegisterService(&DoublePath_ServiceDesc, srv)
}

func _DoublePath_DoublePath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DoublePathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DoublePathServer).DoublePath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DoublePath_DoublePath_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DoublePathServer).DoublePath(ctx, req.(*DoublePathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DoublePath_ServiceDesc is the grpc.ServiceDesc for DoublePath service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DoublePath_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "leo.example.route.path.DoublePath",
	HandlerType: (*DoublePathServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DoublePath",
			Handler:    _DoublePath_DoublePath_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/path.proto",
}

const (
	StringPath_StringPath_FullMethodName = "/leo.example.route.path.StringPath/StringPath"
)

// StringPathClient is the client API for StringPath service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StringPathClient interface {
	StringPath(ctx context.Context, in *StringPathRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type stringPathClient struct {
	cc grpc.ClientConnInterface
}

func NewStringPathClient(cc grpc.ClientConnInterface) StringPathClient {
	return &stringPathClient{cc}
}

func (c *stringPathClient) StringPath(ctx context.Context, in *StringPathRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, StringPath_StringPath_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StringPathServer is the server API for StringPath service.
// All implementations must embed UnimplementedStringPathServer
// for forward compatibility
type StringPathServer interface {
	StringPath(context.Context, *StringPathRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedStringPathServer()
}

// UnimplementedStringPathServer must be embedded to have forward compatible implementations.
type UnimplementedStringPathServer struct {
}

func (UnimplementedStringPathServer) StringPath(context.Context, *StringPathRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StringPath not implemented")
}
func (UnimplementedStringPathServer) mustEmbedUnimplementedStringPathServer() {}

// UnsafeStringPathServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StringPathServer will
// result in compilation errors.
type UnsafeStringPathServer interface {
	mustEmbedUnimplementedStringPathServer()
}

func RegisterStringPathServer(s grpc.ServiceRegistrar, srv StringPathServer) {
	s.RegisterService(&StringPath_ServiceDesc, srv)
}

func _StringPath_StringPath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StringPathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StringPathServer).StringPath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StringPath_StringPath_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StringPathServer).StringPath(ctx, req.(*StringPathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// StringPath_ServiceDesc is the grpc.ServiceDesc for StringPath service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StringPath_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "leo.example.route.path.StringPath",
	HandlerType: (*StringPathServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StringPath",
			Handler:    _StringPath_StringPath_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/path.proto",
}

const (
	EnumPath_EnumPath_FullMethodName = "/leo.example.route.path.EnumPath/EnumPath"
)

// EnumPathClient is the client API for EnumPath service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EnumPathClient interface {
	EnumPath(ctx context.Context, in *EnumPathRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type enumPathClient struct {
	cc grpc.ClientConnInterface
}

func NewEnumPathClient(cc grpc.ClientConnInterface) EnumPathClient {
	return &enumPathClient{cc}
}

func (c *enumPathClient) EnumPath(ctx context.Context, in *EnumPathRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, EnumPath_EnumPath_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EnumPathServer is the server API for EnumPath service.
// All implementations must embed UnimplementedEnumPathServer
// for forward compatibility
type EnumPathServer interface {
	EnumPath(context.Context, *EnumPathRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedEnumPathServer()
}

// UnimplementedEnumPathServer must be embedded to have forward compatible implementations.
type UnimplementedEnumPathServer struct {
}

func (UnimplementedEnumPathServer) EnumPath(context.Context, *EnumPathRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnumPath not implemented")
}
func (UnimplementedEnumPathServer) mustEmbedUnimplementedEnumPathServer() {}

// UnsafeEnumPathServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EnumPathServer will
// result in compilation errors.
type UnsafeEnumPathServer interface {
	mustEmbedUnimplementedEnumPathServer()
}

func RegisterEnumPathServer(s grpc.ServiceRegistrar, srv EnumPathServer) {
	s.RegisterService(&EnumPath_ServiceDesc, srv)
}

func _EnumPath_EnumPath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnumPathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnumPathServer).EnumPath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnumPath_EnumPath_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnumPathServer).EnumPath(ctx, req.(*EnumPathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EnumPath_ServiceDesc is the grpc.ServiceDesc for EnumPath service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EnumPath_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "leo.example.route.path.EnumPath",
	HandlerType: (*EnumPathServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "EnumPath",
			Handler:    _EnumPath_EnumPath_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/path.proto",
}

const (
	NamedPath_NamedPathString_FullMethodName          = "/leo.example.route.path.NamedPath/NamedPathString"
	NamedPath_NamedPathOptString_FullMethodName       = "/leo.example.route.path.NamedPath/NamedPathOptString"
	NamedPath_NamedPathWrapString_FullMethodName      = "/leo.example.route.path.NamedPath/NamedPathWrapString"
	NamedPath_EmbedNamedPathString_FullMethodName     = "/leo.example.route.path.NamedPath/EmbedNamedPathString"
	NamedPath_EmbedNamedPathOptString_FullMethodName  = "/leo.example.route.path.NamedPath/EmbedNamedPathOptString"
	NamedPath_EmbedNamedPathWrapString_FullMethodName = "/leo.example.route.path.NamedPath/EmbedNamedPathWrapString"
)

// NamedPathClient is the client API for NamedPath service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NamedPathClient interface {
	NamedPathString(ctx context.Context, in *NamedPathRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	NamedPathOptString(ctx context.Context, in *NamedPathRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	NamedPathWrapString(ctx context.Context, in *NamedPathRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	EmbedNamedPathString(ctx context.Context, in *EmbedNamedPathRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	EmbedNamedPathOptString(ctx context.Context, in *EmbedNamedPathRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	EmbedNamedPathWrapString(ctx context.Context, in *EmbedNamedPathRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type namedPathClient struct {
	cc grpc.ClientConnInterface
}

func NewNamedPathClient(cc grpc.ClientConnInterface) NamedPathClient {
	return &namedPathClient{cc}
}

func (c *namedPathClient) NamedPathString(ctx context.Context, in *NamedPathRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, NamedPath_NamedPathString_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *namedPathClient) NamedPathOptString(ctx context.Context, in *NamedPathRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, NamedPath_NamedPathOptString_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *namedPathClient) NamedPathWrapString(ctx context.Context, in *NamedPathRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, NamedPath_NamedPathWrapString_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *namedPathClient) EmbedNamedPathString(ctx context.Context, in *EmbedNamedPathRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, NamedPath_EmbedNamedPathString_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *namedPathClient) EmbedNamedPathOptString(ctx context.Context, in *EmbedNamedPathRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, NamedPath_EmbedNamedPathOptString_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *namedPathClient) EmbedNamedPathWrapString(ctx context.Context, in *EmbedNamedPathRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, NamedPath_EmbedNamedPathWrapString_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NamedPathServer is the server API for NamedPath service.
// All implementations must embed UnimplementedNamedPathServer
// for forward compatibility
type NamedPathServer interface {
	NamedPathString(context.Context, *NamedPathRequest) (*emptypb.Empty, error)
	NamedPathOptString(context.Context, *NamedPathRequest) (*emptypb.Empty, error)
	NamedPathWrapString(context.Context, *NamedPathRequest) (*emptypb.Empty, error)
	EmbedNamedPathString(context.Context, *EmbedNamedPathRequest) (*emptypb.Empty, error)
	EmbedNamedPathOptString(context.Context, *EmbedNamedPathRequest) (*emptypb.Empty, error)
	EmbedNamedPathWrapString(context.Context, *EmbedNamedPathRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedNamedPathServer()
}

// UnimplementedNamedPathServer must be embedded to have forward compatible implementations.
type UnimplementedNamedPathServer struct {
}

func (UnimplementedNamedPathServer) NamedPathString(context.Context, *NamedPathRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NamedPathString not implemented")
}
func (UnimplementedNamedPathServer) NamedPathOptString(context.Context, *NamedPathRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NamedPathOptString not implemented")
}
func (UnimplementedNamedPathServer) NamedPathWrapString(context.Context, *NamedPathRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NamedPathWrapString not implemented")
}
func (UnimplementedNamedPathServer) EmbedNamedPathString(context.Context, *EmbedNamedPathRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EmbedNamedPathString not implemented")
}
func (UnimplementedNamedPathServer) EmbedNamedPathOptString(context.Context, *EmbedNamedPathRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EmbedNamedPathOptString not implemented")
}
func (UnimplementedNamedPathServer) EmbedNamedPathWrapString(context.Context, *EmbedNamedPathRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EmbedNamedPathWrapString not implemented")
}
func (UnimplementedNamedPathServer) mustEmbedUnimplementedNamedPathServer() {}

// UnsafeNamedPathServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NamedPathServer will
// result in compilation errors.
type UnsafeNamedPathServer interface {
	mustEmbedUnimplementedNamedPathServer()
}

func RegisterNamedPathServer(s grpc.ServiceRegistrar, srv NamedPathServer) {
	s.RegisterService(&NamedPath_ServiceDesc, srv)
}

func _NamedPath_NamedPathString_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NamedPathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NamedPathServer).NamedPathString(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NamedPath_NamedPathString_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NamedPathServer).NamedPathString(ctx, req.(*NamedPathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NamedPath_NamedPathOptString_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NamedPathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NamedPathServer).NamedPathOptString(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NamedPath_NamedPathOptString_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NamedPathServer).NamedPathOptString(ctx, req.(*NamedPathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NamedPath_NamedPathWrapString_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NamedPathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NamedPathServer).NamedPathWrapString(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NamedPath_NamedPathWrapString_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NamedPathServer).NamedPathWrapString(ctx, req.(*NamedPathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NamedPath_EmbedNamedPathString_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmbedNamedPathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NamedPathServer).EmbedNamedPathString(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NamedPath_EmbedNamedPathString_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NamedPathServer).EmbedNamedPathString(ctx, req.(*EmbedNamedPathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NamedPath_EmbedNamedPathOptString_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmbedNamedPathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NamedPathServer).EmbedNamedPathOptString(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NamedPath_EmbedNamedPathOptString_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NamedPathServer).EmbedNamedPathOptString(ctx, req.(*EmbedNamedPathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NamedPath_EmbedNamedPathWrapString_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmbedNamedPathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NamedPathServer).EmbedNamedPathWrapString(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NamedPath_EmbedNamedPathWrapString_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NamedPathServer).EmbedNamedPathWrapString(ctx, req.(*EmbedNamedPathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NamedPath_ServiceDesc is the grpc.ServiceDesc for NamedPath service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NamedPath_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "leo.example.route.path.NamedPath",
	HandlerType: (*NamedPathServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NamedPathString",
			Handler:    _NamedPath_NamedPathString_Handler,
		},
		{
			MethodName: "NamedPathOptString",
			Handler:    _NamedPath_NamedPathOptString_Handler,
		},
		{
			MethodName: "NamedPathWrapString",
			Handler:    _NamedPath_NamedPathWrapString_Handler,
		},
		{
			MethodName: "EmbedNamedPathString",
			Handler:    _NamedPath_EmbedNamedPathString_Handler,
		},
		{
			MethodName: "EmbedNamedPathOptString",
			Handler:    _NamedPath_EmbedNamedPathOptString_Handler,
		},
		{
			MethodName: "EmbedNamedPathWrapString",
			Handler:    _NamedPath_EmbedNamedPathWrapString_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/path.proto",
}

const (
	MixPath_MixPath_FullMethodName = "/leo.example.route.path.MixPath/MixPath"
)

// MixPathClient is the client API for MixPath service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MixPathClient interface {
	MixPath(ctx context.Context, in *MixPathRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mixPathClient struct {
	cc grpc.ClientConnInterface
}

func NewMixPathClient(cc grpc.ClientConnInterface) MixPathClient {
	return &mixPathClient{cc}
}

func (c *mixPathClient) MixPath(ctx context.Context, in *MixPathRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, MixPath_MixPath_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MixPathServer is the server API for MixPath service.
// All implementations must embed UnimplementedMixPathServer
// for forward compatibility
type MixPathServer interface {
	MixPath(context.Context, *MixPathRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedMixPathServer()
}

// UnimplementedMixPathServer must be embedded to have forward compatible implementations.
type UnimplementedMixPathServer struct {
}

func (UnimplementedMixPathServer) MixPath(context.Context, *MixPathRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MixPath not implemented")
}
func (UnimplementedMixPathServer) mustEmbedUnimplementedMixPathServer() {}

// UnsafeMixPathServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MixPathServer will
// result in compilation errors.
type UnsafeMixPathServer interface {
	mustEmbedUnimplementedMixPathServer()
}

func RegisterMixPathServer(s grpc.ServiceRegistrar, srv MixPathServer) {
	s.RegisterService(&MixPath_ServiceDesc, srv)
}

func _MixPath_MixPath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MixPathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixPathServer).MixPath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MixPath_MixPath_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixPathServer).MixPath(ctx, req.(*MixPathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MixPath_ServiceDesc is the grpc.ServiceDesc for MixPath service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MixPath_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "leo.example.route.path.MixPath",
	HandlerType: (*MixPathServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MixPath",
			Handler:    _MixPath_MixPath_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/path.proto",
}
