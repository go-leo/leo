// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package body

import (
	bytes "bytes"
	context "context"
	json "encoding/json"
	errors "errors"
	fmt "fmt"
	endpoint "github.com/go-kit/kit/endpoint"
	http "github.com/go-kit/kit/transport/http"
	endpointx "github.com/go-leo/leo/v3/endpointx"
	mux "github.com/gorilla/mux"
	httpbody "google.golang.org/genproto/googleapis/api/httpbody"
	http2 "google.golang.org/genproto/googleapis/rpc/http"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	io "io"
	http1 "net/http"
	url "net/url"
)

func NewBodyHTTPServer(
	endpoints interface {
		StarBody() endpoint.Endpoint
		NamedBody() endpoint.Endpoint
		NonBody() endpoint.Endpoint
		HttpBodyStarBody() endpoint.Endpoint
		HttpBodyNamedBody() endpoint.Endpoint
		HttpRequestStarBody() endpoint.Endpoint
	},
	mdw []endpoint.Middleware,
	opts ...http.ServerOption,
) http1.Handler {
	router := mux.NewRouter()
	router.NewRoute().
		Name("/leo.example.body.v1.Body/StarBody").
		Methods("POST").
		Path("/v1/star/body").
		Handler(http.NewServer(
			endpointx.Chain(endpoints.StarBody(), mdw...),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &User{}
				if err := json.NewDecoder(r.Body).Decode(req); err != nil {
					return nil, err
				}
				vars := mux.Vars(r)
				_ = vars
				queries := r.URL.Query()
				_ = queries
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*emptypb.Empty)
				_ = resp
				w.WriteHeader(http1.StatusOK)
				data, err := json.Marshal(resp)
				if err != nil {
					return err
				}
				if _, err := w.Write(data); err != nil {
					return err
				}
				return nil
			},
			opts...,
		))
	router.NewRoute().
		Name("/leo.example.body.v1.Body/NamedBody").
		Methods("POST").
		Path("/v1/named/body").
		Handler(http.NewServer(
			endpointx.Chain(endpoints.NamedBody(), mdw...),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &UserRequest{}
				if err := json.NewDecoder(r.Body).Decode(req.User); err != nil {
					return nil, err
				}
				vars := mux.Vars(r)
				_ = vars
				queries := r.URL.Query()
				_ = queries
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*emptypb.Empty)
				_ = resp
				w.WriteHeader(http1.StatusOK)
				data, err := json.Marshal(resp)
				if err != nil {
					return err
				}
				if _, err := w.Write(data); err != nil {
					return err
				}
				return nil
			},
			opts...,
		))
	router.NewRoute().
		Name("/leo.example.body.v1.Body/NonBody").
		Methods("GET").
		Path("/v1/user_body").
		Handler(http.NewServer(
			endpointx.Chain(endpoints.NonBody(), mdw...),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &emptypb.Empty{}
				vars := mux.Vars(r)
				_ = vars
				queries := r.URL.Query()
				_ = queries
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*emptypb.Empty)
				_ = resp
				w.WriteHeader(http1.StatusOK)
				data, err := json.Marshal(resp)
				if err != nil {
					return err
				}
				if _, err := w.Write(data); err != nil {
					return err
				}
				return nil
			},
			opts...,
		))
	router.NewRoute().
		Name("/leo.example.body.v1.Body/HttpBodyStarBody").
		Methods("PUT").
		Path("/v1/http/body/star/body").
		Handler(http.NewServer(
			endpointx.Chain(endpoints.HttpBodyStarBody(), mdw...),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &httpbody.HttpBody{}
				body, err := io.ReadAll(r.Body)
				if err != nil {
					return nil, err
				}
				req.Data = body
				req.ContentType = r.Header.Get("Content-Type")
				vars := mux.Vars(r)
				_ = vars
				queries := r.URL.Query()
				_ = queries
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*emptypb.Empty)
				_ = resp
				w.WriteHeader(http1.StatusOK)
				data, err := json.Marshal(resp)
				if err != nil {
					return err
				}
				if _, err := w.Write(data); err != nil {
					return err
				}
				return nil
			},
			opts...,
		))
	router.NewRoute().
		Name("/leo.example.body.v1.Body/HttpBodyNamedBody").
		Methods("PUT").
		Path("/v1/http/body/named/body").
		Handler(http.NewServer(
			endpointx.Chain(endpoints.HttpBodyNamedBody(), mdw...),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &HttpBody{}
				req.Body = &httpbody.HttpBody{}
				body, err := io.ReadAll(r.Body)
				if err != nil {
					return nil, err
				}
				req.Body.Data = body
				req.Body.ContentType = r.Header.Get("Content-Type")
				vars := mux.Vars(r)
				_ = vars
				queries := r.URL.Query()
				_ = queries
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*emptypb.Empty)
				_ = resp
				w.WriteHeader(http1.StatusOK)
				data, err := json.Marshal(resp)
				if err != nil {
					return err
				}
				if _, err := w.Write(data); err != nil {
					return err
				}
				return nil
			},
			opts...,
		))
	router.NewRoute().
		Name("/leo.example.body.v1.Body/HttpRequestStarBody").
		Methods("PUT").
		Path("/v1/http/request/star/body").
		Handler(http.NewServer(
			endpointx.Chain(endpoints.HttpRequestStarBody(), mdw...),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &http2.HttpRequest{}
				req.Method = r.Method
				req.Uri = r.RequestURI
				req.Headers = make([]*http2.HttpHeader, 0, len(r.Header))
				for key, values := range r.Header {
					for _, value := range values {
						req.Headers = append(req.Headers, &http2.HttpHeader{Key: key, Value: value})
					}
				}
				body, err := io.ReadAll(r.Body)
				if err != nil {
					return nil, err
				}
				req.Body = body
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*emptypb.Empty)
				_ = resp
				w.WriteHeader(http1.StatusOK)
				data, err := json.Marshal(resp)
				if err != nil {
					return err
				}
				if _, err := w.Write(data); err != nil {
					return err
				}
				return nil
			},
			opts...,
		))
	return router
}

type bodyHTTPClient struct {
	starBody            endpoint.Endpoint
	namedBody           endpoint.Endpoint
	nonBody             endpoint.Endpoint
	httpBodyStarBody    endpoint.Endpoint
	httpBodyNamedBody   endpoint.Endpoint
	httpRequestStarBody endpoint.Endpoint
}

func (c *bodyHTTPClient) StarBody(ctx context.Context, request *User) (*emptypb.Empty, error) {
	rep, err := c.starBody(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *bodyHTTPClient) NamedBody(ctx context.Context, request *UserRequest) (*emptypb.Empty, error) {
	rep, err := c.namedBody(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *bodyHTTPClient) NonBody(ctx context.Context, request *emptypb.Empty) (*emptypb.Empty, error) {
	rep, err := c.nonBody(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *bodyHTTPClient) HttpBodyStarBody(ctx context.Context, request *httpbody.HttpBody) (*emptypb.Empty, error) {
	rep, err := c.httpBodyStarBody(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *bodyHTTPClient) HttpBodyNamedBody(ctx context.Context, request *HttpBody) (*emptypb.Empty, error) {
	rep, err := c.httpBodyNamedBody(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *bodyHTTPClient) HttpRequestStarBody(ctx context.Context, request *http2.HttpRequest) (*emptypb.Empty, error) {
	rep, err := c.httpRequestStarBody(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func NewBodyHTTPClient(
	scheme string,
	instance string,
	mdw []endpoint.Middleware,
	opts ...http.ClientOption,
) interface {
	StarBody(ctx context.Context, request *User) (*emptypb.Empty, error)
	NamedBody(ctx context.Context, request *UserRequest) (*emptypb.Empty, error)
	NonBody(ctx context.Context, request *emptypb.Empty) (*emptypb.Empty, error)
	HttpBodyStarBody(ctx context.Context, request *httpbody.HttpBody) (*emptypb.Empty, error)
	HttpBodyNamedBody(ctx context.Context, request *HttpBody) (*emptypb.Empty, error)
	HttpRequestStarBody(ctx context.Context, request *http2.HttpRequest) (*emptypb.Empty, error)
} {
	router := mux.NewRouter()
	router.NewRoute().
		Name("/leo.example.body.v1.Body/StarBody").
		Methods("POST").
		Path("/v1/star/body")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/NamedBody").
		Methods("POST").
		Path("/v1/named/body")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/NonBody").
		Methods("GET").
		Path("/v1/user_body")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/HttpBodyStarBody").
		Methods("PUT").
		Path("/v1/http/body/star/body")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/HttpBodyNamedBody").
		Methods("PUT").
		Path("/v1/http/body/named/body")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/HttpRequestStarBody").
		Methods("PUT").
		Path("/v1/http/request/star/body")
	return &bodyHTTPClient{
		starBody: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					if obj == nil {
						return nil, errors.New("request object is nil")
					}
					req, ok := obj.(*User)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					_ = req
					var body io.Reader
					var bodyBuf bytes.Buffer
					if err := json.NewEncoder(&bodyBuf).Encode(req); err != nil {
						return nil, err
					}
					body = &bodyBuf
					contentType := "application/json; charset=utf-8"
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/StarBody").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := url.Values{}
					target := &url.URL{
						Scheme:   scheme,
						Host:     instance,
						Path:     path.Path,
						RawQuery: queries.Encode(),
					}
					r, err := http1.NewRequestWithContext(ctx, "POST", target.String(), body)
					if err != nil {
						return nil, err
					}
					r.Header.Set("Content-Type", contentType)
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		namedBody: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					if obj == nil {
						return nil, errors.New("request object is nil")
					}
					req, ok := obj.(*UserRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					_ = req
					var body io.Reader
					var bodyBuf bytes.Buffer
					if err := json.NewEncoder(&bodyBuf).Encode(req.GetUser()); err != nil {
						return nil, err
					}
					body = &bodyBuf
					contentType := "application/json; charset=utf-8"
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/NamedBody").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := url.Values{}
					target := &url.URL{
						Scheme:   scheme,
						Host:     instance,
						Path:     path.Path,
						RawQuery: queries.Encode(),
					}
					r, err := http1.NewRequestWithContext(ctx, "POST", target.String(), body)
					if err != nil {
						return nil, err
					}
					r.Header.Set("Content-Type", contentType)
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		nonBody: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					if obj == nil {
						return nil, errors.New("request object is nil")
					}
					req, ok := obj.(*emptypb.Empty)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					_ = req
					var body io.Reader
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/NonBody").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := url.Values{}
					target := &url.URL{
						Scheme:   scheme,
						Host:     instance,
						Path:     path.Path,
						RawQuery: queries.Encode(),
					}
					r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		httpBodyStarBody: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					if obj == nil {
						return nil, errors.New("request object is nil")
					}
					req, ok := obj.(*httpbody.HttpBody)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					_ = req
					var body io.Reader
					body = bytes.NewReader(req.GetData())
					contentType := req.GetContentType()
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/HttpBodyStarBody").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := url.Values{}
					target := &url.URL{
						Scheme:   scheme,
						Host:     instance,
						Path:     path.Path,
						RawQuery: queries.Encode(),
					}
					r, err := http1.NewRequestWithContext(ctx, "PUT", target.String(), body)
					if err != nil {
						return nil, err
					}
					r.Header.Set("Content-Type", contentType)
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		httpBodyNamedBody: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					if obj == nil {
						return nil, errors.New("request object is nil")
					}
					req, ok := obj.(*HttpBody)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					_ = req
					var body io.Reader
					body = bytes.NewReader(req.GetBody().GetData())
					contentType := req.GetBody().GetContentType()
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/HttpBodyNamedBody").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := url.Values{}
					target := &url.URL{
						Scheme:   scheme,
						Host:     instance,
						Path:     path.Path,
						RawQuery: queries.Encode(),
					}
					r, err := http1.NewRequestWithContext(ctx, "PUT", target.String(), body)
					if err != nil {
						return nil, err
					}
					r.Header.Set("Content-Type", contentType)
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		httpRequestStarBody: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					if obj == nil {
						return nil, errors.New("request object is nil")
					}
					req, ok := obj.(*http2.HttpRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					_ = req
					var body io.Reader
					body = bytes.NewReader(req.GetBody())
					r, err := http1.NewRequestWithContext(ctx, req.GetMethod(), req.GetUri(), body)
					if err != nil {
						return nil, err
					}
					for _, header := range req.GetHeaders() {
						r.Header.Add(header.GetKey(), header.GetValue())
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
	}
}
