// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package body

import (
	bytes "bytes"
	context "context"
	json "encoding/json"
	errors "errors"
	fmt "fmt"
	endpoint "github.com/go-kit/kit/endpoint"
	http1 "github.com/go-kit/kit/transport/http"
	errorx "github.com/go-leo/gox/errorx"
	endpointx "github.com/go-leo/leo/v3/endpointx"
	mux "github.com/gorilla/mux"
	httpbody "google.golang.org/genproto/googleapis/api/httpbody"
	http "google.golang.org/genproto/googleapis/rpc/http"
	protojson "google.golang.org/protobuf/encoding/protojson"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	structpb "google.golang.org/protobuf/types/known/structpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	io "io"
	http2 "net/http"
	strconv "strconv"
	strings "strings"
)

type httpBodyClient struct {
	bool                 endpoint.Endpoint
	optBool              endpoint.Endpoint
	repBool              endpoint.Endpoint
	wrapBool             endpoint.Endpoint
	int32                endpoint.Endpoint
	optInt32             endpoint.Endpoint
	repInt32             endpoint.Endpoint
	wrapInt32            endpoint.Endpoint
	uint32               endpoint.Endpoint
	optUint32            endpoint.Endpoint
	repUint32            endpoint.Endpoint
	wrapUint32           endpoint.Endpoint
	fixed32              endpoint.Endpoint
	optFixed32           endpoint.Endpoint
	repFixed32           endpoint.Endpoint
	int64                endpoint.Endpoint
	optInt64             endpoint.Endpoint
	repInt64             endpoint.Endpoint
	wrapInt64            endpoint.Endpoint
	sint64               endpoint.Endpoint
	optSint64            endpoint.Endpoint
	repSint64            endpoint.Endpoint
	sfixed64             endpoint.Endpoint
	optSfixed64          endpoint.Endpoint
	repSfixed64          endpoint.Endpoint
	uint64               endpoint.Endpoint
	optUint64            endpoint.Endpoint
	repUint64            endpoint.Endpoint
	wrapUint64           endpoint.Endpoint
	fixed64              endpoint.Endpoint
	optFixed64           endpoint.Endpoint
	repFixed64           endpoint.Endpoint
	float                endpoint.Endpoint
	optFloat             endpoint.Endpoint
	repFloat             endpoint.Endpoint
	wrapFloat            endpoint.Endpoint
	double               endpoint.Endpoint
	optDouble            endpoint.Endpoint
	repDouble            endpoint.Endpoint
	wrapDouble           endpoint.Endpoint
	string               endpoint.Endpoint
	optString            endpoint.Endpoint
	repString            endpoint.Endpoint
	wrapString           endpoint.Endpoint
	bytes                endpoint.Endpoint
	optBytes             endpoint.Endpoint
	repBytes             endpoint.Endpoint
	wrapBytes            endpoint.Endpoint
	enum                 endpoint.Endpoint
	optEnum              endpoint.Endpoint
	repEnum              endpoint.Endpoint
	dictionary           endpoint.Endpoint
	httpBody             endpoint.Endpoint
	httpRequest          endpoint.Endpoint
	valueRequest         endpoint.Endpoint
	listValueRequest     endpoint.Endpoint
	structRequest        endpoint.Endpoint
	timestampRequest     endpoint.Endpoint
	durationRequest      endpoint.Endpoint
	optWrapDoubleRequest endpoint.Endpoint
	optWrapFloatRequest  endpoint.Endpoint
	optWrapInt64Request  endpoint.Endpoint
	optWrapUint64Request endpoint.Endpoint
	optWrapInt32Request  endpoint.Endpoint
	optWrapUint32Request endpoint.Endpoint
	optWrapBoolRequest   endpoint.Endpoint
	optWrapStringRequest endpoint.Endpoint
	optWrapBytesRequest  endpoint.Endpoint
	repWrapDoubleRequest endpoint.Endpoint
	repWrapFloatRequest  endpoint.Endpoint
	repWrapInt64Request  endpoint.Endpoint
	repWrapUint64Request endpoint.Endpoint
	repWrapInt32Request  endpoint.Endpoint
	repWrapUint32Request endpoint.Endpoint
	repWrapBoolRequest   endpoint.Endpoint
	repWrapStringRequest endpoint.Endpoint
	repWrapBytesRequest  endpoint.Endpoint
	userRequest          endpoint.Endpoint
	wrapDoubleBody       endpoint.Endpoint
	wrapFloatBody        endpoint.Endpoint
	wrapInt64Body        endpoint.Endpoint
	wrapUint64Body       endpoint.Endpoint
	wrapInt32Body        endpoint.Endpoint
	wrapUint32Body       endpoint.Endpoint
	wrapBoolBody         endpoint.Endpoint
	wrapStringBody       endpoint.Endpoint
	wrapBytesBody        endpoint.Endpoint
	httpBodyBody         endpoint.Endpoint
	httpRequestBody      endpoint.Endpoint
	valueBody            endpoint.Endpoint
	listValueBody        endpoint.Endpoint
	structBody           endpoint.Endpoint
	timestampBody        endpoint.Endpoint
	durationBody         endpoint.Endpoint
	userBody             endpoint.Endpoint
}

func (c *httpBodyClient) Bool(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.bool(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) OptBool(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.optBool(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) RepBool(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.repBool(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) WrapBool(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.wrapBool(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) Int32(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.int32(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) OptInt32(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.optInt32(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) RepInt32(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.repInt32(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) WrapInt32(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.wrapInt32(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) Uint32(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.uint32(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) OptUint32(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.optUint32(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) RepUint32(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.repUint32(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) WrapUint32(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.wrapUint32(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) Fixed32(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.fixed32(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) OptFixed32(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.optFixed32(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) RepFixed32(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.repFixed32(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) Int64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.int64(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) OptInt64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.optInt64(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) RepInt64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.repInt64(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) WrapInt64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.wrapInt64(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) Sint64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.sint64(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) OptSint64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.optSint64(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) RepSint64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.repSint64(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) Sfixed64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.sfixed64(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) OptSfixed64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.optSfixed64(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) RepSfixed64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.repSfixed64(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) Uint64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.uint64(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) OptUint64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.optUint64(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) RepUint64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.repUint64(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) WrapUint64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.wrapUint64(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) Fixed64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.fixed64(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) OptFixed64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.optFixed64(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) RepFixed64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.repFixed64(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) Float(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.float(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) OptFloat(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.optFloat(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) RepFloat(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.repFloat(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) WrapFloat(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.wrapFloat(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) Double(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.double(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) OptDouble(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.optDouble(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) RepDouble(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.repDouble(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) WrapDouble(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.wrapDouble(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) String(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.string(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) OptString(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.optString(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) RepString(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.repString(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) WrapString(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.wrapString(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) Bytes(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.bytes(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) OptBytes(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.optBytes(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) RepBytes(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.repBytes(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) WrapBytes(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.wrapBytes(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) Enum(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.enum(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) OptEnum(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.optEnum(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) RepEnum(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.repEnum(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) Dictionary(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.dictionary(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) HttpBody(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.httpBody(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) HttpRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.httpRequest(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) ValueRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.valueRequest(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) ListValueRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.listValueRequest(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) StructRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.structRequest(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) TimestampRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.timestampRequest(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) DurationRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.durationRequest(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) OptWrapDoubleRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.optWrapDoubleRequest(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) OptWrapFloatRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.optWrapFloatRequest(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) OptWrapInt64Request(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.optWrapInt64Request(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) OptWrapUint64Request(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.optWrapUint64Request(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) OptWrapInt32Request(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.optWrapInt32Request(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) OptWrapUint32Request(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.optWrapUint32Request(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) OptWrapBoolRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.optWrapBoolRequest(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) OptWrapStringRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.optWrapStringRequest(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) OptWrapBytesRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.optWrapBytesRequest(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) RepWrapDoubleRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.repWrapDoubleRequest(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) RepWrapFloatRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.repWrapFloatRequest(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) RepWrapInt64Request(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.repWrapInt64Request(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) RepWrapUint64Request(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.repWrapUint64Request(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) RepWrapInt32Request(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.repWrapInt32Request(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) RepWrapUint32Request(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.repWrapUint32Request(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) RepWrapBoolRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.repWrapBoolRequest(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) RepWrapStringRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.repWrapStringRequest(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) RepWrapBytesRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.repWrapBytesRequest(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) UserRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error) {
	rep, err := c.userRequest(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) WrapDoubleBody(ctx context.Context, request *wrapperspb.DoubleValue) (*emptypb.Empty, error) {
	rep, err := c.wrapDoubleBody(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) WrapFloatBody(ctx context.Context, request *wrapperspb.FloatValue) (*emptypb.Empty, error) {
	rep, err := c.wrapFloatBody(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) WrapInt64Body(ctx context.Context, request *wrapperspb.Int64Value) (*emptypb.Empty, error) {
	rep, err := c.wrapInt64Body(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) WrapUint64Body(ctx context.Context, request *wrapperspb.UInt64Value) (*emptypb.Empty, error) {
	rep, err := c.wrapUint64Body(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) WrapInt32Body(ctx context.Context, request *wrapperspb.Int32Value) (*emptypb.Empty, error) {
	rep, err := c.wrapInt32Body(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) WrapUint32Body(ctx context.Context, request *wrapperspb.UInt32Value) (*emptypb.Empty, error) {
	rep, err := c.wrapUint32Body(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) WrapBoolBody(ctx context.Context, request *wrapperspb.BoolValue) (*emptypb.Empty, error) {
	rep, err := c.wrapBoolBody(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) WrapStringBody(ctx context.Context, request *wrapperspb.StringValue) (*emptypb.Empty, error) {
	rep, err := c.wrapStringBody(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) WrapBytesBody(ctx context.Context, request *wrapperspb.BytesValue) (*emptypb.Empty, error) {
	rep, err := c.wrapBytesBody(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) HttpBodyBody(ctx context.Context, request *httpbody.HttpBody) (*emptypb.Empty, error) {
	rep, err := c.httpBodyBody(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) HttpRequestBody(ctx context.Context, request *http.HttpRequest) (*emptypb.Empty, error) {
	rep, err := c.httpRequestBody(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) ValueBody(ctx context.Context, request *structpb.Value) (*emptypb.Empty, error) {
	rep, err := c.valueBody(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) ListValueBody(ctx context.Context, request *structpb.ListValue) (*emptypb.Empty, error) {
	rep, err := c.listValueBody(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) StructBody(ctx context.Context, request *structpb.Struct) (*emptypb.Empty, error) {
	rep, err := c.structBody(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) TimestampBody(ctx context.Context, request *timestamppb.Timestamp) (*emptypb.Empty, error) {
	rep, err := c.timestampBody(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) DurationBody(ctx context.Context, request *durationpb.Duration) (*emptypb.Empty, error) {
	rep, err := c.durationBody(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpBodyClient) UserBody(ctx context.Context, request *User) (*emptypb.Empty, error) {
	rep, err := c.userBody(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func NewBodyHTTPClient(
	instance string,
	mdw []endpoint.Middleware,
	opts ...http1.ClientOption,
) interface {
	Bool(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	OptBool(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	RepBool(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	WrapBool(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	Int32(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	OptInt32(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	RepInt32(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	WrapInt32(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	Uint32(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	OptUint32(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	RepUint32(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	WrapUint32(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	Fixed32(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	OptFixed32(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	RepFixed32(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	Int64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	OptInt64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	RepInt64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	WrapInt64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	Sint64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	OptSint64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	RepSint64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	Sfixed64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	OptSfixed64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	RepSfixed64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	Uint64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	OptUint64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	RepUint64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	WrapUint64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	Fixed64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	OptFixed64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	RepFixed64(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	Float(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	OptFloat(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	RepFloat(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	WrapFloat(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	Double(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	OptDouble(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	RepDouble(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	WrapDouble(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	String(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	OptString(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	RepString(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	WrapString(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	Bytes(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	OptBytes(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	RepBytes(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	WrapBytes(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	Enum(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	OptEnum(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	RepEnum(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	Dictionary(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	HttpBody(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	HttpRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	ValueRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	ListValueRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	StructRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	TimestampRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	DurationRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	OptWrapDoubleRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	OptWrapFloatRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	OptWrapInt64Request(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	OptWrapUint64Request(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	OptWrapInt32Request(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	OptWrapUint32Request(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	OptWrapBoolRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	OptWrapStringRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	OptWrapBytesRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	RepWrapDoubleRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	RepWrapFloatRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	RepWrapInt64Request(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	RepWrapUint64Request(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	RepWrapInt32Request(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	RepWrapUint32Request(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	RepWrapBoolRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	RepWrapStringRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	RepWrapBytesRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	UserRequest(ctx context.Context, request *BodyRequest) (*emptypb.Empty, error)
	WrapDoubleBody(ctx context.Context, request *wrapperspb.DoubleValue) (*emptypb.Empty, error)
	WrapFloatBody(ctx context.Context, request *wrapperspb.FloatValue) (*emptypb.Empty, error)
	WrapInt64Body(ctx context.Context, request *wrapperspb.Int64Value) (*emptypb.Empty, error)
	WrapUint64Body(ctx context.Context, request *wrapperspb.UInt64Value) (*emptypb.Empty, error)
	WrapInt32Body(ctx context.Context, request *wrapperspb.Int32Value) (*emptypb.Empty, error)
	WrapUint32Body(ctx context.Context, request *wrapperspb.UInt32Value) (*emptypb.Empty, error)
	WrapBoolBody(ctx context.Context, request *wrapperspb.BoolValue) (*emptypb.Empty, error)
	WrapStringBody(ctx context.Context, request *wrapperspb.StringValue) (*emptypb.Empty, error)
	WrapBytesBody(ctx context.Context, request *wrapperspb.BytesValue) (*emptypb.Empty, error)
	HttpBodyBody(ctx context.Context, request *httpbody.HttpBody) (*emptypb.Empty, error)
	HttpRequestBody(ctx context.Context, request *http.HttpRequest) (*emptypb.Empty, error)
	ValueBody(ctx context.Context, request *structpb.Value) (*emptypb.Empty, error)
	ListValueBody(ctx context.Context, request *structpb.ListValue) (*emptypb.Empty, error)
	StructBody(ctx context.Context, request *structpb.Struct) (*emptypb.Empty, error)
	TimestampBody(ctx context.Context, request *timestamppb.Timestamp) (*emptypb.Empty, error)
	DurationBody(ctx context.Context, request *durationpb.Duration) (*emptypb.Empty, error)
	UserBody(ctx context.Context, request *User) (*emptypb.Empty, error)
} {
	router := mux.NewRouter()
	router.NewRoute().
		Name("/leo.example.body.v1.Body/Bool").
		Methods("PUT").
		Path("/v1/bool")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/OptBool").
		Methods("PUT").
		Path("/v1/opt_bool")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/RepBool").
		Methods("PUT").
		Path("/v1/rep_bool")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/WrapBool").
		Methods("PUT").
		Path("/v1/wrap_bool")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/Int32").
		Methods("PUT").
		Path("/v1/int32")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/OptInt32").
		Methods("PUT").
		Path("/v1/opt_int32")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/RepInt32").
		Methods("PUT").
		Path("/v1/rep_int32")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/WrapInt32").
		Methods("PUT").
		Path("/v1/wrap_int32")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/Uint32").
		Methods("PUT").
		Path("/v1/uint32")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/OptUint32").
		Methods("PUT").
		Path("/v1/opt_uint32")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/RepUint32").
		Methods("PUT").
		Path("/v1/rep_uint32")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/WrapUint32").
		Methods("PUT").
		Path("/v1/wrap_uint32")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/Fixed32").
		Methods("PUT").
		Path("/v1/fixed32")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/OptFixed32").
		Methods("PUT").
		Path("/v1/opt_fixed32")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/RepFixed32").
		Methods("PUT").
		Path("/v1/rep_fixed32")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/Int64").
		Methods("PUT").
		Path("/v1/int64")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/OptInt64").
		Methods("PUT").
		Path("/v1/opt_int64")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/RepInt64").
		Methods("PUT").
		Path("/v1/rep_int64")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/WrapInt64").
		Methods("PUT").
		Path("/v1/wrap_int64")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/Sint64").
		Methods("PUT").
		Path("/v1/sint64")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/OptSint64").
		Methods("PUT").
		Path("/v1/opt_sint64")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/RepSint64").
		Methods("PUT").
		Path("/v1/rep_sint64")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/Sfixed64").
		Methods("PUT").
		Path("/v1/sfixed64")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/OptSfixed64").
		Methods("PUT").
		Path("/v1/opt_sfixed64")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/RepSfixed64").
		Methods("PUT").
		Path("/v1/rep_sfixed64")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/Uint64").
		Methods("PUT").
		Path("/v1/uint64")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/OptUint64").
		Methods("PUT").
		Path("/v1/opt_uint64")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/RepUint64").
		Methods("PUT").
		Path("/v1/rep_uint64")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/WrapUint64").
		Methods("PUT").
		Path("/v1/wrap_uint64")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/Fixed64").
		Methods("PUT").
		Path("/v1/fixed64")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/OptFixed64").
		Methods("PUT").
		Path("/v1/opt_fixed64")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/RepFixed64").
		Methods("PUT").
		Path("/v1/rep_fixed64")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/Float").
		Methods("PUT").
		Path("/v1/float")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/OptFloat").
		Methods("PUT").
		Path("/v1/opt_float")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/RepFloat").
		Methods("PUT").
		Path("/v1/rep_float")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/WrapFloat").
		Methods("PUT").
		Path("/v1/wrap_float")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/Double").
		Methods("PUT").
		Path("/v1/double")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/OptDouble").
		Methods("PUT").
		Path("/v1/opt_double")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/RepDouble").
		Methods("PUT").
		Path("/v1/rep_double")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/WrapDouble").
		Methods("PUT").
		Path("/v1/wrap_double")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/String").
		Methods("PUT").
		Path("/v1/string")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/OptString").
		Methods("PUT").
		Path("/v1/opt_string")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/RepString").
		Methods("PUT").
		Path("/v1/rep_string")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/WrapString").
		Methods("PUT").
		Path("/v1/wrap_string")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/Bytes").
		Methods("PUT").
		Path("/v1/bytes")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/OptBytes").
		Methods("PUT").
		Path("/v1/opt_bytes")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/RepBytes").
		Methods("PUT").
		Path("/v1/rep_bytes")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/WrapBytes").
		Methods("PUT").
		Path("/v1/wrap_bytes")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/Enum").
		Methods("PUT").
		Path("/v1/status")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/OptEnum").
		Methods("PUT").
		Path("/v1/opt_status")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/RepEnum").
		Methods("PUT").
		Path("/v1/rep_status")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/Dictionary").
		Methods("PUT").
		Path("/v1/dictionary")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/HttpBody").
		Methods("PUT").
		Path("/v1/http_body")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/HttpRequest").
		Methods("PUT").
		Path("/v1/http_request")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/ValueRequest").
		Methods("PUT").
		Path("/v1/value")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/ListValueRequest").
		Methods("PUT").
		Path("/v1/list_value")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/StructRequest").
		Methods("PUT").
		Path("/v1/struct")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/TimestampRequest").
		Methods("PUT").
		Path("/v1/timestamp")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/DurationRequest").
		Methods("PUT").
		Path("/v1/duration")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/OptWrapDoubleRequest").
		Methods("PUT").
		Path("/v1/opt_wrap_double")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/OptWrapFloatRequest").
		Methods("PUT").
		Path("/v1/opt_wrap_float")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/OptWrapInt64Request").
		Methods("PUT").
		Path("/v1/opt_wrap_int64")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/OptWrapUint64Request").
		Methods("PUT").
		Path("/v1/opt_wrap_uint64")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/OptWrapInt32Request").
		Methods("PUT").
		Path("/v1/opt_wrap_int32")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/OptWrapUint32Request").
		Methods("PUT").
		Path("/v1/opt_wrap_uint32")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/OptWrapBoolRequest").
		Methods("PUT").
		Path("/v1/opt_wrap_bool")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/OptWrapStringRequest").
		Methods("PUT").
		Path("/v1/opt_wrap_string")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/OptWrapBytesRequest").
		Methods("PUT").
		Path("/v1/opt_wrap_bytes")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/RepWrapDoubleRequest").
		Methods("PUT").
		Path("/v1/rep_wrap_double")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/RepWrapFloatRequest").
		Methods("PUT").
		Path("/v1/rep_wrap_float")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/RepWrapInt64Request").
		Methods("PUT").
		Path("/v1/rep_wrap_int64")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/RepWrapUint64Request").
		Methods("PUT").
		Path("/v1/rep_wrap_uint64")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/RepWrapInt32Request").
		Methods("PUT").
		Path("/v1/rep_wrap_int32")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/RepWrapUint32Request").
		Methods("PUT").
		Path("/v1/rep_wrap_uint32")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/RepWrapBoolRequest").
		Methods("PUT").
		Path("/v1/rep_wrap_bool")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/RepWrapStringRequest").
		Methods("PUT").
		Path("/v1/rep_wrap_string")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/RepWrapBytesRequest").
		Methods("PUT").
		Path("/v1/rep_wrap_bytes")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/UserRequest").
		Methods("PUT").
		Path("/v1/user")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/WrapDoubleBody").
		Methods("PUT").
		Path("/v1/wrap_double_body")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/WrapFloatBody").
		Methods("PUT").
		Path("/v1/wrap_float_body")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/WrapInt64Body").
		Methods("PUT").
		Path("/v1/wrap_int64_body")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/WrapUint64Body").
		Methods("PUT").
		Path("/v1/wrap_uint64_body")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/WrapInt32Body").
		Methods("PUT").
		Path("/v1/wrap_int32_body")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/WrapUint32Body").
		Methods("PUT").
		Path("/v1/wrap_uint32_body")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/WrapBoolBody").
		Methods("PUT").
		Path("/v1/wrap_bool_body")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/WrapStringBody").
		Methods("PUT").
		Path("/v1/wrap_string_body")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/WrapBytesBody").
		Methods("PUT").
		Path("/v1/wrap_bytes_body")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/HttpBodyBody").
		Methods("PUT").
		Path("/v1/http_body_body")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/HttpRequestBody").
		Methods("PUT").
		Path("/v1/http_request_body")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/ValueBody").
		Methods("PUT").
		Path("/v1/value_body")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/ListValueBody").
		Methods("PUT").
		Path("/v1/list_value_body")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/StructBody").
		Methods("PUT").
		Path("/v1/struct_body")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/TimestampBody").
		Methods("PUT").
		Path("/v1/timestamp_body")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/DurationBody").
		Methods("PUT").
		Path("/v1/duration_body")
	router.NewRoute().
		Name("/leo.example.body.v1.Body/UserBody").
		Methods("PUT").
		Path("/v1/user_body")
	return &httpBodyClient{
		bool: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					body = strings.NewReader(strconv.FormatBool(req.Bool))
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/Bool").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		optBool: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.OptBool != nil {
						body = strings.NewReader(strconv.FormatBool(*req.OptBool))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/OptBool").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		repBool: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.RepBool != nil {
						if err := json.NewDecoder(body).Decode(req.RepBool); err != nil {
							return nil, err
						}
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/RepBool").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		wrapBool: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.WrapBool != nil {
						body = strings.NewReader(strconv.FormatBool(req.WrapBool.Value))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/WrapBool").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		int32: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					body = strings.NewReader(strconv.FormatInt(int64(req.Int32), 10))
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/Int32").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		optInt32: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.OptInt32 != nil {
						body = strings.NewReader(strconv.FormatInt(int64(*req.OptInt32), 10))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/OptInt32").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		repInt32: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.RepInt32 != nil {
						if err := json.NewDecoder(body).Decode(req.RepInt32); err != nil {
							return nil, err
						}
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/RepInt32").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		wrapInt32: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.WrapInt32 != nil {
						body = strings.NewReader(strconv.FormatInt(int64(req.WrapInt32.Value), 10))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/WrapInt32").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		uint32: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					body = strings.NewReader(strconv.FormatUint(uint64(req.Uint32), 10))
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/Uint32").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		optUint32: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.OptUint32 != nil {
						body = strings.NewReader(strconv.FormatUint(uint64(*req.OptUint32), 10))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/OptUint32").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		repUint32: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.RepUint32 != nil {
						if err := json.NewDecoder(body).Decode(req.RepUint32); err != nil {
							return nil, err
						}
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/RepUint32").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		wrapUint32: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.WrapUint32 != nil {
						body = strings.NewReader(strconv.FormatUint(uint64(req.WrapUint32.Value), 10))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/WrapUint32").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		fixed32: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					body = strings.NewReader(strconv.FormatUint(uint64(req.Fixed32), 10))
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/Fixed32").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		optFixed32: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.OptFixed32 != nil {
						body = strings.NewReader(strconv.FormatUint(uint64(*req.OptFixed32), 10))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/OptFixed32").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		repFixed32: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.RepFixed32 != nil {
						if err := json.NewDecoder(body).Decode(req.RepFixed32); err != nil {
							return nil, err
						}
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/RepFixed32").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		int64: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					body = strings.NewReader(strconv.FormatInt(req.Int64, 10))
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/Int64").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		optInt64: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.OptInt64 != nil {
						body = strings.NewReader(strconv.FormatInt(*req.OptInt64, 10))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/OptInt64").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		repInt64: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.RepInt64 != nil {
						if err := json.NewDecoder(body).Decode(req.RepInt64); err != nil {
							return nil, err
						}
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/RepInt64").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		wrapInt64: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.WrapInt64 != nil {
						body = strings.NewReader(strconv.FormatInt(req.WrapInt64.Value, 10))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/WrapInt64").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		sint64: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					body = strings.NewReader(strconv.FormatInt(req.Sint64, 10))
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/Sint64").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		optSint64: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.OptSint64 != nil {
						body = strings.NewReader(strconv.FormatInt(*req.OptSint64, 10))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/OptSint64").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		repSint64: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.RepSint64 != nil {
						if err := json.NewDecoder(body).Decode(req.RepSint64); err != nil {
							return nil, err
						}
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/RepSint64").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		sfixed64: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					body = strings.NewReader(strconv.FormatInt(req.Sfixed64, 10))
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/Sfixed64").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		optSfixed64: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.OptSfixed64 != nil {
						body = strings.NewReader(strconv.FormatInt(*req.OptSfixed64, 10))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/OptSfixed64").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		repSfixed64: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.RepSfixed64 != nil {
						if err := json.NewDecoder(body).Decode(req.RepSfixed64); err != nil {
							return nil, err
						}
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/RepSfixed64").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		uint64: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					body = strings.NewReader(strconv.FormatUint(req.Uint64, 10))
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/Uint64").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		optUint64: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.OptUint64 != nil {
						body = strings.NewReader(strconv.FormatUint(*req.OptUint64, 10))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/OptUint64").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		repUint64: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.RepUint64 != nil {
						if err := json.NewDecoder(body).Decode(req.RepUint64); err != nil {
							return nil, err
						}
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/RepUint64").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		wrapUint64: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.WrapUint64 != nil {
						body = strings.NewReader(strconv.FormatUint(req.WrapUint64.Value, 10))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/WrapUint64").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		fixed64: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					body = strings.NewReader(strconv.FormatUint(req.Fixed64, 10))
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/Fixed64").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		optFixed64: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.OptFixed64 != nil {
						body = strings.NewReader(strconv.FormatUint(*req.OptFixed64, 10))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/OptFixed64").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		repFixed64: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.RepFixed64 != nil {
						if err := json.NewDecoder(body).Decode(req.RepFixed64); err != nil {
							return nil, err
						}
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/RepFixed64").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		float: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					body = strings.NewReader(strconv.FormatFloat(float64(req.Float), 'f', -1, 32))
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/Float").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		optFloat: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.OptFloat != nil {
						body = strings.NewReader(strconv.FormatFloat(float64(*req.OptFloat), 'f', -1, 32))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/OptFloat").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		repFloat: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.RepFloat != nil {
						if err := json.NewDecoder(body).Decode(req.RepFloat); err != nil {
							return nil, err
						}
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/RepFloat").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		wrapFloat: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.WrapFloat != nil {
						body = strings.NewReader(strconv.FormatFloat(float64(req.WrapFloat.Value), 'f', -1, 32))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/WrapFloat").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		double: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					body = strings.NewReader(strconv.FormatFloat(req.Double, 'f', -1, 64))
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/Double").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		optDouble: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.OptDouble != nil {
						body = strings.NewReader(strconv.FormatFloat(*req.OptDouble, 'f', -1, 64))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/OptDouble").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		repDouble: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.RepDouble != nil {
						if err := json.NewDecoder(body).Decode(req.RepDouble); err != nil {
							return nil, err
						}
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/RepDouble").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		wrapDouble: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.WrapDouble != nil {
						body = strings.NewReader(strconv.FormatFloat(req.WrapDouble.Value, 'f', -1, 64))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/WrapDouble").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		string: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					body = strings.NewReader(req.String_)
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/String").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		optString: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.OptString != nil {
						body = strings.NewReader(*req.OptString)
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/OptString").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		repString: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.RepString != nil {
						if err := json.NewDecoder(body).Decode(req.RepString); err != nil {
							return nil, err
						}
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/RepString").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		wrapString: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.WrapString != nil {
						body = strings.NewReader(req.WrapString.Value)
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/WrapString").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		bytes: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					body = bytes.NewReader(req.Bytes)
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/Bytes").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		optBytes: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					body = bytes.NewReader(req.OptBytes)
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/OptBytes").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		repBytes: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.RepBytes != nil {
						if err := json.NewDecoder(body).Decode(req.RepBytes); err != nil {
							return nil, err
						}
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/RepBytes").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		wrapBytes: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.WrapBytes != nil {
						body = bytes.NewReader(req.WrapBytes.Value)
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/WrapBytes").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		enum: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					body = strings.NewReader(strconv.FormatInt(int64(req.Status), 10))
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/Enum").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		optEnum: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.OptStatus != nil {
						body = strings.NewReader(strconv.FormatInt(int64(*req.OptStatus), 10))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/OptEnum").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		repEnum: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.RepStatus != nil {
						if err := json.NewDecoder(body).Decode(req.RepStatus); err != nil {
							return nil, err
						}
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/RepEnum").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		dictionary: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.Dictionary != nil {
						data, err := json.Marshal(req.Dictionary)
						if err != nil {
							return nil, err
						}
						body = bytes.NewBuffer(data)
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/Dictionary").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		httpBody: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.HttpBody != nil {
						body = bytes.NewReader(req.HttpBody.Data)
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/HttpBody").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		httpRequest: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.HttpRequest != nil {
						body = bytes.NewReader(req.HttpRequest.Body)
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/HttpRequest").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		valueRequest: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.Value != nil {
						data, err := protojson.Marshal(req.Value)
						if err != nil {
							return nil, err
						}
						body = bytes.NewBuffer(data)
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/ValueRequest").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		listValueRequest: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.ListValue != nil {
						data, err := protojson.Marshal(req.ListValue)
						if err != nil {
							return nil, err
						}
						body = bytes.NewBuffer(data)
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/ListValueRequest").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		structRequest: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.Struct != nil {
						data, err := protojson.Marshal(req.Struct)
						if err != nil {
							return nil, err
						}
						body = bytes.NewBuffer(data)
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/StructRequest").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		timestampRequest: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.Timestamp != nil {
						body = strings.NewReader(string(errorx.Ignore(protojson.Marshal(req.Timestamp))))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/TimestampRequest").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		durationRequest: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.Duration != nil {
						body = strings.NewReader(string(errorx.Ignore(protojson.Marshal(req.Duration))))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/DurationRequest").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		optWrapDoubleRequest: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.OptWrapDouble != nil {
						body = strings.NewReader(strconv.FormatFloat(req.OptWrapDouble.Value, 'f', -1, 64))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/OptWrapDoubleRequest").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		optWrapFloatRequest: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.OptWrapFloat != nil {
						body = strings.NewReader(strconv.FormatFloat(float64(req.OptWrapFloat.Value), 'f', -1, 32))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/OptWrapFloatRequest").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		optWrapInt64Request: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.OptWrapInt64 != nil {
						body = strings.NewReader(strconv.FormatInt(req.OptWrapInt64.Value, 10))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/OptWrapInt64Request").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		optWrapUint64Request: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.OptWrapUint64 != nil {
						body = strings.NewReader(strconv.FormatUint(req.OptWrapUint64.Value, 10))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/OptWrapUint64Request").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		optWrapInt32Request: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.OptWrapInt32 != nil {
						body = strings.NewReader(strconv.FormatInt(int64(req.OptWrapInt32.Value), 10))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/OptWrapInt32Request").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		optWrapUint32Request: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.OptWrapUint32 != nil {
						body = strings.NewReader(strconv.FormatUint(uint64(req.OptWrapUint32.Value), 10))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/OptWrapUint32Request").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		optWrapBoolRequest: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.OptWrapBool != nil {
						body = strings.NewReader(strconv.FormatBool(req.OptWrapBool.Value))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/OptWrapBoolRequest").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		optWrapStringRequest: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.OptWrapString != nil {
						body = strings.NewReader(req.OptWrapString.Value)
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/OptWrapStringRequest").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		optWrapBytesRequest: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.OptWrapBytes != nil {
						body = bytes.NewReader(req.OptWrapBytes.Value)
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/OptWrapBytesRequest").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		repWrapDoubleRequest: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.RepWrapDouble != nil {
						if err := json.NewDecoder(body).Decode(req.RepWrapDouble); err != nil {
							return nil, err
						}
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/RepWrapDoubleRequest").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		repWrapFloatRequest: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.RepWrapFloat != nil {
						if err := json.NewDecoder(body).Decode(req.RepWrapFloat); err != nil {
							return nil, err
						}
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/RepWrapFloatRequest").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		repWrapInt64Request: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.RepWrapInt64 != nil {
						if err := json.NewDecoder(body).Decode(req.RepWrapInt64); err != nil {
							return nil, err
						}
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/RepWrapInt64Request").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		repWrapUint64Request: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.RepWrapUint64 != nil {
						if err := json.NewDecoder(body).Decode(req.RepWrapUint64); err != nil {
							return nil, err
						}
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/RepWrapUint64Request").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		repWrapInt32Request: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.RepWrapInt32 != nil {
						if err := json.NewDecoder(body).Decode(req.RepWrapInt32); err != nil {
							return nil, err
						}
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/RepWrapInt32Request").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		repWrapUint32Request: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.RepWrapUint32 != nil {
						if err := json.NewDecoder(body).Decode(req.RepWrapUint32); err != nil {
							return nil, err
						}
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/RepWrapUint32Request").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		repWrapBoolRequest: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.RepWrapBool != nil {
						if err := json.NewDecoder(body).Decode(req.RepWrapBool); err != nil {
							return nil, err
						}
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/RepWrapBoolRequest").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		repWrapStringRequest: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.RepWrapString != nil {
						if err := json.NewDecoder(body).Decode(req.RepWrapString); err != nil {
							return nil, err
						}
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/RepWrapStringRequest").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_bytesRepWrapBytes message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		repWrapBytesRequest: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.RepWrapBytes != nil {
						if err := json.NewDecoder(body).Decode(req.RepWrapBytes); err != nil {
							return nil, err
						}
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/RepWrapBytesRequest").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// userUser message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		userRequest: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*BodyRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req.User != nil {
						data, err := protojson.Marshal(req.User)
						if err != nil {
							return nil, err
						}
						body = bytes.NewBuffer(data)
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/UserRequest").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := r.URL.Query()
					// boolBool bool
					// int32Int32 int32
					// sint32Sint32 sint32
					// uint32Uint32 uint32
					// int64Int64 int64
					// sint64Sint64 sint64
					// uint64Uint64 uint64
					// sfixed32Sfixed32 sfixed32
					// fixed32Fixed32 fixed32
					// floatFloat float
					// sfixed64Sfixed64 sfixed64
					// fixed64Fixed64 fixed64
					// doubleDouble double
					// stringString_ string
					// bytesBytes bytes
					// opt_boolOptBool bool
					// opt_int32OptInt32 int32
					// opt_sint32OptSint32 sint32
					// opt_uint32OptUint32 uint32
					// opt_int64OptInt64 int64
					// opt_sint64OptSint64 sint64
					// opt_uint64OptUint64 uint64
					// opt_sfixed32OptSfixed32 sfixed32
					// opt_fixed32OptFixed32 fixed32
					// opt_floatOptFloat float
					// opt_sfixed64OptSfixed64 sfixed64
					// opt_fixed64OptFixed64 fixed64
					// opt_doubleOptDouble double
					// opt_stringOptString string
					// opt_bytesOptBytes bytes
					// wrap_doubleWrapDouble message
					// wrap_floatWrapFloat message
					// wrap_int64WrapInt64 message
					// wrap_uint64WrapUint64 message
					// wrap_int32WrapInt32 message
					// wrap_uint32WrapUint32 message
					// wrap_boolWrapBool message
					// wrap_stringWrapString message
					// wrap_bytesWrapBytes message
					// rep_boolRepBool bool
					// rep_int32RepInt32 int32
					// rep_sint32RepSint32 sint32
					// rep_uint32RepUint32 uint32
					// rep_int64RepInt64 int64
					// rep_sint64RepSint64 sint64
					// rep_uint64RepUint64 uint64
					// rep_sfixed32RepSfixed32 sfixed32
					// rep_fixed32RepFixed32 fixed32
					// rep_floatRepFloat float
					// rep_sfixed64RepSfixed64 sfixed64
					// rep_fixed64RepFixed64 fixed64
					// rep_doubleRepDouble double
					// rep_stringRepString string
					// rep_bytesRepBytes bytes
					// statusStatus enum
					// opt_statusOptStatus enum
					// rep_statusRepStatus enum
					// dictionaryDictionary message
					// http_bodyHttpBody message
					// http_requestHttpRequest message
					// valueValue message
					// list_valueListValue message
					// structStruct message
					// timestampTimestamp message
					// durationDuration message
					// opt_wrap_doubleOptWrapDouble message
					// opt_wrap_floatOptWrapFloat message
					// opt_wrap_int64OptWrapInt64 message
					// opt_wrap_uint64OptWrapUint64 message
					// opt_wrap_int32OptWrapInt32 message
					// opt_wrap_uint32OptWrapUint32 message
					// opt_wrap_boolOptWrapBool message
					// opt_wrap_stringOptWrapString message
					// opt_wrap_bytesOptWrapBytes message
					// rep_wrap_doubleRepWrapDouble message
					// rep_wrap_floatRepWrapFloat message
					// rep_wrap_int64RepWrapInt64 message
					// rep_wrap_uint64RepWrapUint64 message
					// rep_wrap_int32RepWrapInt32 message
					// rep_wrap_uint32RepWrapUint32 message
					// rep_wrap_boolRepWrapBool message
					// rep_wrap_stringRepWrapString message
					// rep_wrap_bytesRepWrapBytes message
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		wrapDoubleBody: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*wrapperspb.DoubleValue)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req != nil {
						body = strings.NewReader(strconv.FormatFloat(req.Value, 'f', -1, 64))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/WrapDoubleBody").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		wrapFloatBody: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*wrapperspb.FloatValue)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req != nil {
						body = strings.NewReader(strconv.FormatFloat(float64(req.Value), 'f', -1, 32))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/WrapFloatBody").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		wrapInt64Body: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*wrapperspb.Int64Value)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req != nil {
						body = strings.NewReader(strconv.FormatInt(req.Value, 10))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/WrapInt64Body").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		wrapUint64Body: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*wrapperspb.UInt64Value)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req != nil {
						body = strings.NewReader(strconv.FormatUint(req.Value, 10))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/WrapUint64Body").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		wrapInt32Body: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*wrapperspb.Int32Value)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req != nil {
						body = strings.NewReader(strconv.FormatInt(int64(req.Value), 10))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/WrapInt32Body").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		wrapUint32Body: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*wrapperspb.UInt32Value)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req != nil {
						body = strings.NewReader(strconv.FormatUint(uint64(req.Value), 10))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/WrapUint32Body").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		wrapBoolBody: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*wrapperspb.BoolValue)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req != nil {
						body = strings.NewReader(strconv.FormatBool(req.Value))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/WrapBoolBody").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		wrapStringBody: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*wrapperspb.StringValue)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req != nil {
						body = strings.NewReader(req.Value)
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/WrapStringBody").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		wrapBytesBody: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*wrapperspb.BytesValue)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req != nil {
						body = bytes.NewReader(req.Value)
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/WrapBytesBody").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		httpBodyBody: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*httpbody.HttpBody)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req != nil {
						body = bytes.NewReader(req.Data)
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/HttpBodyBody").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		httpRequestBody: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*http.HttpRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req != nil {
						body = bytes.NewReader(req.Body)
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/HttpRequestBody").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		valueBody: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*structpb.Value)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req != nil {
						data, err := protojson.Marshal(req)
						if err != nil {
							return nil, err
						}
						body = bytes.NewBuffer(data)
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/ValueBody").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		listValueBody: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*structpb.ListValue)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req != nil {
						data, err := protojson.Marshal(req)
						if err != nil {
							return nil, err
						}
						body = bytes.NewBuffer(data)
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/ListValueBody").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		structBody: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*structpb.Struct)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req != nil {
						data, err := protojson.Marshal(req)
						if err != nil {
							return nil, err
						}
						body = bytes.NewBuffer(data)
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/StructBody").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		timestampBody: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*timestamppb.Timestamp)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req != nil {
						body = strings.NewReader(string(errorx.Ignore(protojson.Marshal(req))))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/TimestampBody").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		durationBody: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*durationpb.Duration)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req != nil {
						body = strings.NewReader(string(errorx.Ignore(protojson.Marshal(req))))
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/DurationBody").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		userBody: endpointx.Chain(
			http1.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http2.Request, error) {
					req, ok := obj.(*User)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "PUT"
					var url string
					var body io.Reader
					if req != nil {
						data, err := protojson.Marshal(req)
						if err != nil {
							return nil, err
						}
						body = bytes.NewBuffer(data)
					}
					var pairs []string
					path, err := router.Get("/leo.example.body.v1.Body/UserBody").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http2.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http2.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
	}
}
