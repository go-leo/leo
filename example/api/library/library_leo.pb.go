// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package library

import (
	bytes "bytes"
	context "context"
	errors "errors"
	fmt "fmt"
	endpoint "github.com/go-kit/kit/endpoint"
	sd "github.com/go-kit/kit/sd"
	grpc "github.com/go-kit/kit/transport/grpc"
	http "github.com/go-kit/kit/transport/http"
	jsonx "github.com/go-leo/gox/encodingx/jsonx"
	errorx "github.com/go-leo/gox/errorx"
	urlx "github.com/go-leo/gox/netx/urlx"
	strconvx "github.com/go-leo/gox/strconvx"
	endpointx "github.com/go-leo/leo/v3/endpointx"
	statusx "github.com/go-leo/leo/v3/statusx"
	transportx "github.com/go-leo/leo/v3/transportx"
	grpcx "github.com/go-leo/leo/v3/transportx/grpcx"
	httpx "github.com/go-leo/leo/v3/transportx/httpx"
	mux "github.com/gorilla/mux"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	io "io"
	http1 "net/http"
	url "net/url"
	strings "strings"
)

// =========================== endpoints ===========================

type LibraryServiceService interface {
	CreateShelf(ctx context.Context, request *CreateShelfRequest) (*Shelf, error)
	GetShelf(ctx context.Context, request *GetShelfRequest) (*Shelf, error)
	ListShelves(ctx context.Context, request *ListShelvesRequest) (*ListShelvesResponse, error)
	DeleteShelf(ctx context.Context, request *DeleteShelfRequest) (*emptypb.Empty, error)
	MergeShelves(ctx context.Context, request *MergeShelvesRequest) (*Shelf, error)
	CreateBook(ctx context.Context, request *CreateBookRequest) (*Book, error)
	GetBook(ctx context.Context, request *GetBookRequest) (*Book, error)
	ListBooks(ctx context.Context, request *ListBooksRequest) (*ListBooksResponse, error)
	DeleteBook(ctx context.Context, request *DeleteBookRequest) (*emptypb.Empty, error)
	UpdateBook(ctx context.Context, request *UpdateBookRequest) (*Book, error)
	MoveBook(ctx context.Context, request *MoveBookRequest) (*Book, error)
}

type LibraryServiceEndpoints interface {
	CreateShelf(ctx context.Context) endpoint.Endpoint
	GetShelf(ctx context.Context) endpoint.Endpoint
	ListShelves(ctx context.Context) endpoint.Endpoint
	DeleteShelf(ctx context.Context) endpoint.Endpoint
	MergeShelves(ctx context.Context) endpoint.Endpoint
	CreateBook(ctx context.Context) endpoint.Endpoint
	GetBook(ctx context.Context) endpoint.Endpoint
	ListBooks(ctx context.Context) endpoint.Endpoint
	DeleteBook(ctx context.Context) endpoint.Endpoint
	UpdateBook(ctx context.Context) endpoint.Endpoint
	MoveBook(ctx context.Context) endpoint.Endpoint
}

type LibraryServiceClientTransports interface {
	CreateShelf() transportx.ClientTransport
	GetShelf() transportx.ClientTransport
	ListShelves() transportx.ClientTransport
	DeleteShelf() transportx.ClientTransport
	MergeShelves() transportx.ClientTransport
	CreateBook() transportx.ClientTransport
	GetBook() transportx.ClientTransport
	ListBooks() transportx.ClientTransport
	DeleteBook() transportx.ClientTransport
	UpdateBook() transportx.ClientTransport
	MoveBook() transportx.ClientTransport
}

type LibraryServiceFactories interface {
	CreateShelf(middlewares ...endpoint.Middleware) sd.Factory
	GetShelf(middlewares ...endpoint.Middleware) sd.Factory
	ListShelves(middlewares ...endpoint.Middleware) sd.Factory
	DeleteShelf(middlewares ...endpoint.Middleware) sd.Factory
	MergeShelves(middlewares ...endpoint.Middleware) sd.Factory
	CreateBook(middlewares ...endpoint.Middleware) sd.Factory
	GetBook(middlewares ...endpoint.Middleware) sd.Factory
	ListBooks(middlewares ...endpoint.Middleware) sd.Factory
	DeleteBook(middlewares ...endpoint.Middleware) sd.Factory
	UpdateBook(middlewares ...endpoint.Middleware) sd.Factory
	MoveBook(middlewares ...endpoint.Middleware) sd.Factory
}

type LibraryServiceEndpointers interface {
	CreateShelf() sd.Endpointer
	GetShelf() sd.Endpointer
	ListShelves() sd.Endpointer
	DeleteShelf() sd.Endpointer
	MergeShelves() sd.Endpointer
	CreateBook() sd.Endpointer
	GetBook() sd.Endpointer
	ListBooks() sd.Endpointer
	DeleteBook() sd.Endpointer
	UpdateBook() sd.Endpointer
	MoveBook() sd.Endpointer
}

type libraryServiceServerEndpoints struct {
	svc         LibraryServiceService
	middlewares []endpoint.Middleware
}

func (e *libraryServiceServerEndpoints) CreateShelf(context.Context) endpoint.Endpoint {
	component := func(ctx context.Context, request any) (any, error) {
		return e.svc.CreateShelf(ctx, request.(*CreateShelfRequest))
	}
	return endpointx.Chain(component, e.middlewares...)
}

func (e *libraryServiceServerEndpoints) GetShelf(context.Context) endpoint.Endpoint {
	component := func(ctx context.Context, request any) (any, error) {
		return e.svc.GetShelf(ctx, request.(*GetShelfRequest))
	}
	return endpointx.Chain(component, e.middlewares...)
}

func (e *libraryServiceServerEndpoints) ListShelves(context.Context) endpoint.Endpoint {
	component := func(ctx context.Context, request any) (any, error) {
		return e.svc.ListShelves(ctx, request.(*ListShelvesRequest))
	}
	return endpointx.Chain(component, e.middlewares...)
}

func (e *libraryServiceServerEndpoints) DeleteShelf(context.Context) endpoint.Endpoint {
	component := func(ctx context.Context, request any) (any, error) {
		return e.svc.DeleteShelf(ctx, request.(*DeleteShelfRequest))
	}
	return endpointx.Chain(component, e.middlewares...)
}

func (e *libraryServiceServerEndpoints) MergeShelves(context.Context) endpoint.Endpoint {
	component := func(ctx context.Context, request any) (any, error) {
		return e.svc.MergeShelves(ctx, request.(*MergeShelvesRequest))
	}
	return endpointx.Chain(component, e.middlewares...)
}

func (e *libraryServiceServerEndpoints) CreateBook(context.Context) endpoint.Endpoint {
	component := func(ctx context.Context, request any) (any, error) {
		return e.svc.CreateBook(ctx, request.(*CreateBookRequest))
	}
	return endpointx.Chain(component, e.middlewares...)
}

func (e *libraryServiceServerEndpoints) GetBook(context.Context) endpoint.Endpoint {
	component := func(ctx context.Context, request any) (any, error) {
		return e.svc.GetBook(ctx, request.(*GetBookRequest))
	}
	return endpointx.Chain(component, e.middlewares...)
}

func (e *libraryServiceServerEndpoints) ListBooks(context.Context) endpoint.Endpoint {
	component := func(ctx context.Context, request any) (any, error) {
		return e.svc.ListBooks(ctx, request.(*ListBooksRequest))
	}
	return endpointx.Chain(component, e.middlewares...)
}

func (e *libraryServiceServerEndpoints) DeleteBook(context.Context) endpoint.Endpoint {
	component := func(ctx context.Context, request any) (any, error) {
		return e.svc.DeleteBook(ctx, request.(*DeleteBookRequest))
	}
	return endpointx.Chain(component, e.middlewares...)
}

func (e *libraryServiceServerEndpoints) UpdateBook(context.Context) endpoint.Endpoint {
	component := func(ctx context.Context, request any) (any, error) {
		return e.svc.UpdateBook(ctx, request.(*UpdateBookRequest))
	}
	return endpointx.Chain(component, e.middlewares...)
}

func (e *libraryServiceServerEndpoints) MoveBook(context.Context) endpoint.Endpoint {
	component := func(ctx context.Context, request any) (any, error) {
		return e.svc.MoveBook(ctx, request.(*MoveBookRequest))
	}
	return endpointx.Chain(component, e.middlewares...)
}

func newLibraryServiceServerEndpoints(svc LibraryServiceService, middlewares ...endpoint.Middleware) LibraryServiceEndpoints {
	return &libraryServiceServerEndpoints{svc: svc, middlewares: middlewares}
}

type libraryServiceClientEndpoints struct {
	transports  LibraryServiceClientTransports
	middlewares []endpoint.Middleware
}

func (e *libraryServiceClientEndpoints) CreateShelf(ctx context.Context) endpoint.Endpoint {
	return endpointx.Chain(e.transports.CreateShelf().Endpoint(ctx), e.middlewares...)
}

func (e *libraryServiceClientEndpoints) GetShelf(ctx context.Context) endpoint.Endpoint {
	return endpointx.Chain(e.transports.GetShelf().Endpoint(ctx), e.middlewares...)
}

func (e *libraryServiceClientEndpoints) ListShelves(ctx context.Context) endpoint.Endpoint {
	return endpointx.Chain(e.transports.ListShelves().Endpoint(ctx), e.middlewares...)
}

func (e *libraryServiceClientEndpoints) DeleteShelf(ctx context.Context) endpoint.Endpoint {
	return endpointx.Chain(e.transports.DeleteShelf().Endpoint(ctx), e.middlewares...)
}

func (e *libraryServiceClientEndpoints) MergeShelves(ctx context.Context) endpoint.Endpoint {
	return endpointx.Chain(e.transports.MergeShelves().Endpoint(ctx), e.middlewares...)
}

func (e *libraryServiceClientEndpoints) CreateBook(ctx context.Context) endpoint.Endpoint {
	return endpointx.Chain(e.transports.CreateBook().Endpoint(ctx), e.middlewares...)
}

func (e *libraryServiceClientEndpoints) GetBook(ctx context.Context) endpoint.Endpoint {
	return endpointx.Chain(e.transports.GetBook().Endpoint(ctx), e.middlewares...)
}

func (e *libraryServiceClientEndpoints) ListBooks(ctx context.Context) endpoint.Endpoint {
	return endpointx.Chain(e.transports.ListBooks().Endpoint(ctx), e.middlewares...)
}

func (e *libraryServiceClientEndpoints) DeleteBook(ctx context.Context) endpoint.Endpoint {
	return endpointx.Chain(e.transports.DeleteBook().Endpoint(ctx), e.middlewares...)
}

func (e *libraryServiceClientEndpoints) UpdateBook(ctx context.Context) endpoint.Endpoint {
	return endpointx.Chain(e.transports.UpdateBook().Endpoint(ctx), e.middlewares...)
}

func (e *libraryServiceClientEndpoints) MoveBook(ctx context.Context) endpoint.Endpoint {
	return endpointx.Chain(e.transports.MoveBook().Endpoint(ctx), e.middlewares...)
}

func newLibraryServiceClientEndpoints(transports LibraryServiceClientTransports, middlewares ...endpoint.Middleware) LibraryServiceEndpoints {
	return &libraryServiceClientEndpoints{transports: transports, middlewares: middlewares}
}

// =========================== cqrs ===========================

// =========================== grpc server ===========================

type LibraryServiceGrpcServerTransports interface {
	CreateShelf() *grpc.Server
	GetShelf() *grpc.Server
	ListShelves() *grpc.Server
	DeleteShelf() *grpc.Server
	MergeShelves() *grpc.Server
	CreateBook() *grpc.Server
	GetBook() *grpc.Server
	ListBooks() *grpc.Server
	DeleteBook() *grpc.Server
	UpdateBook() *grpc.Server
	MoveBook() *grpc.Server
}

type libraryServiceGrpcServerTransports struct {
	createShelf  *grpc.Server
	getShelf     *grpc.Server
	listShelves  *grpc.Server
	deleteShelf  *grpc.Server
	mergeShelves *grpc.Server
	createBook   *grpc.Server
	getBook      *grpc.Server
	listBooks    *grpc.Server
	deleteBook   *grpc.Server
	updateBook   *grpc.Server
	moveBook     *grpc.Server
}

func (t *libraryServiceGrpcServerTransports) CreateShelf() *grpc.Server {
	return t.createShelf
}

func (t *libraryServiceGrpcServerTransports) GetShelf() *grpc.Server {
	return t.getShelf
}

func (t *libraryServiceGrpcServerTransports) ListShelves() *grpc.Server {
	return t.listShelves
}

func (t *libraryServiceGrpcServerTransports) DeleteShelf() *grpc.Server {
	return t.deleteShelf
}

func (t *libraryServiceGrpcServerTransports) MergeShelves() *grpc.Server {
	return t.mergeShelves
}

func (t *libraryServiceGrpcServerTransports) CreateBook() *grpc.Server {
	return t.createBook
}

func (t *libraryServiceGrpcServerTransports) GetBook() *grpc.Server {
	return t.getBook
}

func (t *libraryServiceGrpcServerTransports) ListBooks() *grpc.Server {
	return t.listBooks
}

func (t *libraryServiceGrpcServerTransports) DeleteBook() *grpc.Server {
	return t.deleteBook
}

func (t *libraryServiceGrpcServerTransports) UpdateBook() *grpc.Server {
	return t.updateBook
}

func (t *libraryServiceGrpcServerTransports) MoveBook() *grpc.Server {
	return t.moveBook
}

func newLibraryServiceGrpcServerTransports(endpoints LibraryServiceEndpoints) LibraryServiceGrpcServerTransports {
	return &libraryServiceGrpcServerTransports{
		createShelf: grpc.NewServer(
			endpoints.CreateShelf(context.TODO()),
			func(_ context.Context, v any) (any, error) { return v, nil },
			func(_ context.Context, v any) (any, error) { return v, nil },
			grpc.ServerBefore(grpcx.ServerEndpointInjector("/google.example.library.v1.LibraryService/CreateShelf")),
			grpc.ServerBefore(grpcx.ServerTransportInjector),
			grpc.ServerBefore(grpcx.IncomingMetadata),
		),
		getShelf: grpc.NewServer(
			endpoints.GetShelf(context.TODO()),
			func(_ context.Context, v any) (any, error) { return v, nil },
			func(_ context.Context, v any) (any, error) { return v, nil },
			grpc.ServerBefore(grpcx.ServerEndpointInjector("/google.example.library.v1.LibraryService/GetShelf")),
			grpc.ServerBefore(grpcx.ServerTransportInjector),
			grpc.ServerBefore(grpcx.IncomingMetadata),
		),
		listShelves: grpc.NewServer(
			endpoints.ListShelves(context.TODO()),
			func(_ context.Context, v any) (any, error) { return v, nil },
			func(_ context.Context, v any) (any, error) { return v, nil },
			grpc.ServerBefore(grpcx.ServerEndpointInjector("/google.example.library.v1.LibraryService/ListShelves")),
			grpc.ServerBefore(grpcx.ServerTransportInjector),
			grpc.ServerBefore(grpcx.IncomingMetadata),
		),
		deleteShelf: grpc.NewServer(
			endpoints.DeleteShelf(context.TODO()),
			func(_ context.Context, v any) (any, error) { return v, nil },
			func(_ context.Context, v any) (any, error) { return v, nil },
			grpc.ServerBefore(grpcx.ServerEndpointInjector("/google.example.library.v1.LibraryService/DeleteShelf")),
			grpc.ServerBefore(grpcx.ServerTransportInjector),
			grpc.ServerBefore(grpcx.IncomingMetadata),
		),
		mergeShelves: grpc.NewServer(
			endpoints.MergeShelves(context.TODO()),
			func(_ context.Context, v any) (any, error) { return v, nil },
			func(_ context.Context, v any) (any, error) { return v, nil },
			grpc.ServerBefore(grpcx.ServerEndpointInjector("/google.example.library.v1.LibraryService/MergeShelves")),
			grpc.ServerBefore(grpcx.ServerTransportInjector),
			grpc.ServerBefore(grpcx.IncomingMetadata),
		),
		createBook: grpc.NewServer(
			endpoints.CreateBook(context.TODO()),
			func(_ context.Context, v any) (any, error) { return v, nil },
			func(_ context.Context, v any) (any, error) { return v, nil },
			grpc.ServerBefore(grpcx.ServerEndpointInjector("/google.example.library.v1.LibraryService/CreateBook")),
			grpc.ServerBefore(grpcx.ServerTransportInjector),
			grpc.ServerBefore(grpcx.IncomingMetadata),
		),
		getBook: grpc.NewServer(
			endpoints.GetBook(context.TODO()),
			func(_ context.Context, v any) (any, error) { return v, nil },
			func(_ context.Context, v any) (any, error) { return v, nil },
			grpc.ServerBefore(grpcx.ServerEndpointInjector("/google.example.library.v1.LibraryService/GetBook")),
			grpc.ServerBefore(grpcx.ServerTransportInjector),
			grpc.ServerBefore(grpcx.IncomingMetadata),
		),
		listBooks: grpc.NewServer(
			endpoints.ListBooks(context.TODO()),
			func(_ context.Context, v any) (any, error) { return v, nil },
			func(_ context.Context, v any) (any, error) { return v, nil },
			grpc.ServerBefore(grpcx.ServerEndpointInjector("/google.example.library.v1.LibraryService/ListBooks")),
			grpc.ServerBefore(grpcx.ServerTransportInjector),
			grpc.ServerBefore(grpcx.IncomingMetadata),
		),
		deleteBook: grpc.NewServer(
			endpoints.DeleteBook(context.TODO()),
			func(_ context.Context, v any) (any, error) { return v, nil },
			func(_ context.Context, v any) (any, error) { return v, nil },
			grpc.ServerBefore(grpcx.ServerEndpointInjector("/google.example.library.v1.LibraryService/DeleteBook")),
			grpc.ServerBefore(grpcx.ServerTransportInjector),
			grpc.ServerBefore(grpcx.IncomingMetadata),
		),
		updateBook: grpc.NewServer(
			endpoints.UpdateBook(context.TODO()),
			func(_ context.Context, v any) (any, error) { return v, nil },
			func(_ context.Context, v any) (any, error) { return v, nil },
			grpc.ServerBefore(grpcx.ServerEndpointInjector("/google.example.library.v1.LibraryService/UpdateBook")),
			grpc.ServerBefore(grpcx.ServerTransportInjector),
			grpc.ServerBefore(grpcx.IncomingMetadata),
		),
		moveBook: grpc.NewServer(
			endpoints.MoveBook(context.TODO()),
			func(_ context.Context, v any) (any, error) { return v, nil },
			func(_ context.Context, v any) (any, error) { return v, nil },
			grpc.ServerBefore(grpcx.ServerEndpointInjector("/google.example.library.v1.LibraryService/MoveBook")),
			grpc.ServerBefore(grpcx.ServerTransportInjector),
			grpc.ServerBefore(grpcx.IncomingMetadata),
		),
	}
}

type libraryServiceGrpcServer struct {
	createShelf  *grpc.Server
	getShelf     *grpc.Server
	listShelves  *grpc.Server
	deleteShelf  *grpc.Server
	mergeShelves *grpc.Server
	createBook   *grpc.Server
	getBook      *grpc.Server
	listBooks    *grpc.Server
	deleteBook   *grpc.Server
	updateBook   *grpc.Server
	moveBook     *grpc.Server
}

func (s *libraryServiceGrpcServer) CreateShelf(ctx context.Context, request *CreateShelfRequest) (*Shelf, error) {
	ctx, rep, err := s.createShelf.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*Shelf), nil
}

func (s *libraryServiceGrpcServer) GetShelf(ctx context.Context, request *GetShelfRequest) (*Shelf, error) {
	ctx, rep, err := s.getShelf.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*Shelf), nil
}

func (s *libraryServiceGrpcServer) ListShelves(ctx context.Context, request *ListShelvesRequest) (*ListShelvesResponse, error) {
	ctx, rep, err := s.listShelves.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*ListShelvesResponse), nil
}

func (s *libraryServiceGrpcServer) DeleteShelf(ctx context.Context, request *DeleteShelfRequest) (*emptypb.Empty, error) {
	ctx, rep, err := s.deleteShelf.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*emptypb.Empty), nil
}

func (s *libraryServiceGrpcServer) MergeShelves(ctx context.Context, request *MergeShelvesRequest) (*Shelf, error) {
	ctx, rep, err := s.mergeShelves.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*Shelf), nil
}

func (s *libraryServiceGrpcServer) CreateBook(ctx context.Context, request *CreateBookRequest) (*Book, error) {
	ctx, rep, err := s.createBook.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*Book), nil
}

func (s *libraryServiceGrpcServer) GetBook(ctx context.Context, request *GetBookRequest) (*Book, error) {
	ctx, rep, err := s.getBook.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*Book), nil
}

func (s *libraryServiceGrpcServer) ListBooks(ctx context.Context, request *ListBooksRequest) (*ListBooksResponse, error) {
	ctx, rep, err := s.listBooks.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*ListBooksResponse), nil
}

func (s *libraryServiceGrpcServer) DeleteBook(ctx context.Context, request *DeleteBookRequest) (*emptypb.Empty, error) {
	ctx, rep, err := s.deleteBook.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*emptypb.Empty), nil
}

func (s *libraryServiceGrpcServer) UpdateBook(ctx context.Context, request *UpdateBookRequest) (*Book, error) {
	ctx, rep, err := s.updateBook.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*Book), nil
}

func (s *libraryServiceGrpcServer) MoveBook(ctx context.Context, request *MoveBookRequest) (*Book, error) {
	ctx, rep, err := s.moveBook.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*Book), nil
}

func NewLibraryServiceGrpcServer(svc LibraryServiceService, middlewares ...endpoint.Middleware) LibraryServiceService {
	endpoints := newLibraryServiceServerEndpoints(svc, middlewares...)
	transports := newLibraryServiceGrpcServerTransports(endpoints)
	return &libraryServiceGrpcServer{
		createShelf:  transports.CreateShelf(),
		getShelf:     transports.GetShelf(),
		listShelves:  transports.ListShelves(),
		deleteShelf:  transports.DeleteShelf(),
		mergeShelves: transports.MergeShelves(),
		createBook:   transports.CreateBook(),
		getBook:      transports.GetBook(),
		listBooks:    transports.ListBooks(),
		deleteBook:   transports.DeleteBook(),
		updateBook:   transports.UpdateBook(),
		moveBook:     transports.MoveBook(),
	}
}

// =========================== grpc client ===========================

type libraryServiceGrpcClientTransports struct {
	createShelf  transportx.ClientTransport
	getShelf     transportx.ClientTransport
	listShelves  transportx.ClientTransport
	deleteShelf  transportx.ClientTransport
	mergeShelves transportx.ClientTransport
	createBook   transportx.ClientTransport
	getBook      transportx.ClientTransport
	listBooks    transportx.ClientTransport
	deleteBook   transportx.ClientTransport
	updateBook   transportx.ClientTransport
	moveBook     transportx.ClientTransport
}

func (t *libraryServiceGrpcClientTransports) CreateShelf() transportx.ClientTransport {
	return t.createShelf
}

func (t *libraryServiceGrpcClientTransports) GetShelf() transportx.ClientTransport {
	return t.getShelf
}

func (t *libraryServiceGrpcClientTransports) ListShelves() transportx.ClientTransport {
	return t.listShelves
}

func (t *libraryServiceGrpcClientTransports) DeleteShelf() transportx.ClientTransport {
	return t.deleteShelf
}

func (t *libraryServiceGrpcClientTransports) MergeShelves() transportx.ClientTransport {
	return t.mergeShelves
}

func (t *libraryServiceGrpcClientTransports) CreateBook() transportx.ClientTransport {
	return t.createBook
}

func (t *libraryServiceGrpcClientTransports) GetBook() transportx.ClientTransport {
	return t.getBook
}

func (t *libraryServiceGrpcClientTransports) ListBooks() transportx.ClientTransport {
	return t.listBooks
}

func (t *libraryServiceGrpcClientTransports) DeleteBook() transportx.ClientTransport {
	return t.deleteBook
}

func (t *libraryServiceGrpcClientTransports) UpdateBook() transportx.ClientTransport {
	return t.updateBook
}

func (t *libraryServiceGrpcClientTransports) MoveBook() transportx.ClientTransport {
	return t.moveBook
}

func NewLibraryServiceGrpcClientTransports(target string, options ...transportx.ClientTransportOption) (LibraryServiceClientTransports, error) {
	t := &libraryServiceGrpcClientTransports{}
	var err error
	t.createShelf, err = errorx.Break[transportx.ClientTransport](err)(func() (transportx.ClientTransport, error) {
		return transportx.NewClientTransport(
			target,
			grpcx.ClientFactory(
				"google.example.library.v1.LibraryService",
				"CreateShelf",
				func(_ context.Context, v any) (any, error) { return v, nil },
				func(_ context.Context, v any) (any, error) { return v, nil },
				Shelf{},
				grpc.ClientBefore(grpcx.OutgoingMetadata),
			),
			options...,
		)
	})
	t.getShelf, err = errorx.Break[transportx.ClientTransport](err)(func() (transportx.ClientTransport, error) {
		return transportx.NewClientTransport(
			target,
			grpcx.ClientFactory(
				"google.example.library.v1.LibraryService",
				"GetShelf",
				func(_ context.Context, v any) (any, error) { return v, nil },
				func(_ context.Context, v any) (any, error) { return v, nil },
				Shelf{},
				grpc.ClientBefore(grpcx.OutgoingMetadata),
			),
			options...,
		)
	})
	t.listShelves, err = errorx.Break[transportx.ClientTransport](err)(func() (transportx.ClientTransport, error) {
		return transportx.NewClientTransport(
			target,
			grpcx.ClientFactory(
				"google.example.library.v1.LibraryService",
				"ListShelves",
				func(_ context.Context, v any) (any, error) { return v, nil },
				func(_ context.Context, v any) (any, error) { return v, nil },
				ListShelvesResponse{},
				grpc.ClientBefore(grpcx.OutgoingMetadata),
			),
			options...,
		)
	})
	t.deleteShelf, err = errorx.Break[transportx.ClientTransport](err)(func() (transportx.ClientTransport, error) {
		return transportx.NewClientTransport(
			target,
			grpcx.ClientFactory(
				"google.example.library.v1.LibraryService",
				"DeleteShelf",
				func(_ context.Context, v any) (any, error) { return v, nil },
				func(_ context.Context, v any) (any, error) { return v, nil },
				emptypb.Empty{},
				grpc.ClientBefore(grpcx.OutgoingMetadata),
			),
			options...,
		)
	})
	t.mergeShelves, err = errorx.Break[transportx.ClientTransport](err)(func() (transportx.ClientTransport, error) {
		return transportx.NewClientTransport(
			target,
			grpcx.ClientFactory(
				"google.example.library.v1.LibraryService",
				"MergeShelves",
				func(_ context.Context, v any) (any, error) { return v, nil },
				func(_ context.Context, v any) (any, error) { return v, nil },
				Shelf{},
				grpc.ClientBefore(grpcx.OutgoingMetadata),
			),
			options...,
		)
	})
	t.createBook, err = errorx.Break[transportx.ClientTransport](err)(func() (transportx.ClientTransport, error) {
		return transportx.NewClientTransport(
			target,
			grpcx.ClientFactory(
				"google.example.library.v1.LibraryService",
				"CreateBook",
				func(_ context.Context, v any) (any, error) { return v, nil },
				func(_ context.Context, v any) (any, error) { return v, nil },
				Book{},
				grpc.ClientBefore(grpcx.OutgoingMetadata),
			),
			options...,
		)
	})
	t.getBook, err = errorx.Break[transportx.ClientTransport](err)(func() (transportx.ClientTransport, error) {
		return transportx.NewClientTransport(
			target,
			grpcx.ClientFactory(
				"google.example.library.v1.LibraryService",
				"GetBook",
				func(_ context.Context, v any) (any, error) { return v, nil },
				func(_ context.Context, v any) (any, error) { return v, nil },
				Book{},
				grpc.ClientBefore(grpcx.OutgoingMetadata),
			),
			options...,
		)
	})
	t.listBooks, err = errorx.Break[transportx.ClientTransport](err)(func() (transportx.ClientTransport, error) {
		return transportx.NewClientTransport(
			target,
			grpcx.ClientFactory(
				"google.example.library.v1.LibraryService",
				"ListBooks",
				func(_ context.Context, v any) (any, error) { return v, nil },
				func(_ context.Context, v any) (any, error) { return v, nil },
				ListBooksResponse{},
				grpc.ClientBefore(grpcx.OutgoingMetadata),
			),
			options...,
		)
	})
	t.deleteBook, err = errorx.Break[transportx.ClientTransport](err)(func() (transportx.ClientTransport, error) {
		return transportx.NewClientTransport(
			target,
			grpcx.ClientFactory(
				"google.example.library.v1.LibraryService",
				"DeleteBook",
				func(_ context.Context, v any) (any, error) { return v, nil },
				func(_ context.Context, v any) (any, error) { return v, nil },
				emptypb.Empty{},
				grpc.ClientBefore(grpcx.OutgoingMetadata),
			),
			options...,
		)
	})
	t.updateBook, err = errorx.Break[transportx.ClientTransport](err)(func() (transportx.ClientTransport, error) {
		return transportx.NewClientTransport(
			target,
			grpcx.ClientFactory(
				"google.example.library.v1.LibraryService",
				"UpdateBook",
				func(_ context.Context, v any) (any, error) { return v, nil },
				func(_ context.Context, v any) (any, error) { return v, nil },
				Book{},
				grpc.ClientBefore(grpcx.OutgoingMetadata),
			),
			options...,
		)
	})
	t.moveBook, err = errorx.Break[transportx.ClientTransport](err)(func() (transportx.ClientTransport, error) {
		return transportx.NewClientTransport(
			target,
			grpcx.ClientFactory(
				"google.example.library.v1.LibraryService",
				"MoveBook",
				func(_ context.Context, v any) (any, error) { return v, nil },
				func(_ context.Context, v any) (any, error) { return v, nil },
				Book{},
				grpc.ClientBefore(grpcx.OutgoingMetadata),
			),
			options...,
		)
	})
	return t, err
}

type libraryServiceGrpcClient struct {
	endpoints LibraryServiceEndpoints
}

func (c *libraryServiceGrpcClient) CreateShelf(ctx context.Context, request *CreateShelfRequest) (*Shelf, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/CreateShelf")
	ctx = transportx.InjectName(ctx, grpcx.GrpcClient)
	rep, err := c.endpoints.CreateShelf(ctx)(ctx, request)
	if err != nil {
		return nil, statusx.FromGrpcError(err)
	}
	return rep.(*Shelf), nil
}

func (c *libraryServiceGrpcClient) GetShelf(ctx context.Context, request *GetShelfRequest) (*Shelf, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/GetShelf")
	ctx = transportx.InjectName(ctx, grpcx.GrpcClient)
	rep, err := c.endpoints.GetShelf(ctx)(ctx, request)
	if err != nil {
		return nil, statusx.FromGrpcError(err)
	}
	return rep.(*Shelf), nil
}

func (c *libraryServiceGrpcClient) ListShelves(ctx context.Context, request *ListShelvesRequest) (*ListShelvesResponse, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/ListShelves")
	ctx = transportx.InjectName(ctx, grpcx.GrpcClient)
	rep, err := c.endpoints.ListShelves(ctx)(ctx, request)
	if err != nil {
		return nil, statusx.FromGrpcError(err)
	}
	return rep.(*ListShelvesResponse), nil
}

func (c *libraryServiceGrpcClient) DeleteShelf(ctx context.Context, request *DeleteShelfRequest) (*emptypb.Empty, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/DeleteShelf")
	ctx = transportx.InjectName(ctx, grpcx.GrpcClient)
	rep, err := c.endpoints.DeleteShelf(ctx)(ctx, request)
	if err != nil {
		return nil, statusx.FromGrpcError(err)
	}
	return rep.(*emptypb.Empty), nil
}

func (c *libraryServiceGrpcClient) MergeShelves(ctx context.Context, request *MergeShelvesRequest) (*Shelf, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/MergeShelves")
	ctx = transportx.InjectName(ctx, grpcx.GrpcClient)
	rep, err := c.endpoints.MergeShelves(ctx)(ctx, request)
	if err != nil {
		return nil, statusx.FromGrpcError(err)
	}
	return rep.(*Shelf), nil
}

func (c *libraryServiceGrpcClient) CreateBook(ctx context.Context, request *CreateBookRequest) (*Book, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/CreateBook")
	ctx = transportx.InjectName(ctx, grpcx.GrpcClient)
	rep, err := c.endpoints.CreateBook(ctx)(ctx, request)
	if err != nil {
		return nil, statusx.FromGrpcError(err)
	}
	return rep.(*Book), nil
}

func (c *libraryServiceGrpcClient) GetBook(ctx context.Context, request *GetBookRequest) (*Book, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/GetBook")
	ctx = transportx.InjectName(ctx, grpcx.GrpcClient)
	rep, err := c.endpoints.GetBook(ctx)(ctx, request)
	if err != nil {
		return nil, statusx.FromGrpcError(err)
	}
	return rep.(*Book), nil
}

func (c *libraryServiceGrpcClient) ListBooks(ctx context.Context, request *ListBooksRequest) (*ListBooksResponse, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/ListBooks")
	ctx = transportx.InjectName(ctx, grpcx.GrpcClient)
	rep, err := c.endpoints.ListBooks(ctx)(ctx, request)
	if err != nil {
		return nil, statusx.FromGrpcError(err)
	}
	return rep.(*ListBooksResponse), nil
}

func (c *libraryServiceGrpcClient) DeleteBook(ctx context.Context, request *DeleteBookRequest) (*emptypb.Empty, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/DeleteBook")
	ctx = transportx.InjectName(ctx, grpcx.GrpcClient)
	rep, err := c.endpoints.DeleteBook(ctx)(ctx, request)
	if err != nil {
		return nil, statusx.FromGrpcError(err)
	}
	return rep.(*emptypb.Empty), nil
}

func (c *libraryServiceGrpcClient) UpdateBook(ctx context.Context, request *UpdateBookRequest) (*Book, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/UpdateBook")
	ctx = transportx.InjectName(ctx, grpcx.GrpcClient)
	rep, err := c.endpoints.UpdateBook(ctx)(ctx, request)
	if err != nil {
		return nil, statusx.FromGrpcError(err)
	}
	return rep.(*Book), nil
}

func (c *libraryServiceGrpcClient) MoveBook(ctx context.Context, request *MoveBookRequest) (*Book, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/MoveBook")
	ctx = transportx.InjectName(ctx, grpcx.GrpcClient)
	rep, err := c.endpoints.MoveBook(ctx)(ctx, request)
	if err != nil {
		return nil, statusx.FromGrpcError(err)
	}
	return rep.(*Book), nil
}

func NewLibraryServiceGrpcClient(transports LibraryServiceClientTransports, middlewares ...endpoint.Middleware) LibraryServiceService {
	endpoints := newLibraryServiceClientEndpoints(transports, middlewares...)
	return &libraryServiceGrpcClient{endpoints: endpoints}
}

// =========================== http server ===========================

type LibraryServiceHttpServerTransports interface {
	CreateShelf() *http.Server
	GetShelf() *http.Server
	ListShelves() *http.Server
	DeleteShelf() *http.Server
	MergeShelves() *http.Server
	CreateBook() *http.Server
	GetBook() *http.Server
	ListBooks() *http.Server
	DeleteBook() *http.Server
	UpdateBook() *http.Server
	MoveBook() *http.Server
}

type libraryServiceHttpServerTransports struct {
	createShelf  *http.Server
	getShelf     *http.Server
	listShelves  *http.Server
	deleteShelf  *http.Server
	mergeShelves *http.Server
	createBook   *http.Server
	getBook      *http.Server
	listBooks    *http.Server
	deleteBook   *http.Server
	updateBook   *http.Server
	moveBook     *http.Server
}

func (t *libraryServiceHttpServerTransports) CreateShelf() *http.Server {
	return t.createShelf
}

func (t *libraryServiceHttpServerTransports) GetShelf() *http.Server {
	return t.getShelf
}

func (t *libraryServiceHttpServerTransports) ListShelves() *http.Server {
	return t.listShelves
}

func (t *libraryServiceHttpServerTransports) DeleteShelf() *http.Server {
	return t.deleteShelf
}

func (t *libraryServiceHttpServerTransports) MergeShelves() *http.Server {
	return t.mergeShelves
}

func (t *libraryServiceHttpServerTransports) CreateBook() *http.Server {
	return t.createBook
}

func (t *libraryServiceHttpServerTransports) GetBook() *http.Server {
	return t.getBook
}

func (t *libraryServiceHttpServerTransports) ListBooks() *http.Server {
	return t.listBooks
}

func (t *libraryServiceHttpServerTransports) DeleteBook() *http.Server {
	return t.deleteBook
}

func (t *libraryServiceHttpServerTransports) UpdateBook() *http.Server {
	return t.updateBook
}

func (t *libraryServiceHttpServerTransports) MoveBook() *http.Server {
	return t.moveBook
}

func newLibraryServiceHttpServerTransports(endpoints LibraryServiceEndpoints) LibraryServiceHttpServerTransports {
	return &libraryServiceHttpServerTransports{
		createShelf: http.NewServer(
			endpoints.CreateShelf(context.TODO()),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &CreateShelfRequest{}
				if err := jsonx.NewDecoder(r.Body).Decode(&req.Shelf); err != nil {
					return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
				}
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*Shelf)
				w.Header().Set("Content-Type", "application/json; charset=utf-8")
				w.WriteHeader(http1.StatusOK)
				if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
					return statusx.ErrInternal.With(statusx.Wrap(err))
				}
				return nil
			},
			http.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/CreateShelf")),
			http.ServerBefore(httpx.TransportInjector(httpx.HttpServer)),
			http.ServerBefore(httpx.IncomingMetadata),
			http.ServerErrorEncoder(httpx.ErrorEncoder),
		),
		getShelf: http.NewServer(
			endpoints.GetShelf(context.TODO()),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &GetShelfRequest{}
				vars := urlx.FormFromMap(mux.Vars(r))
				var varErr error
				req.Name = fmt.Sprintf("shelves/%s", vars.Get("shelf"))
				if varErr != nil {
					return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(varErr))
				}
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*Shelf)
				w.Header().Set("Content-Type", "application/json; charset=utf-8")
				w.WriteHeader(http1.StatusOK)
				if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
					return statusx.ErrInternal.With(statusx.Wrap(err))
				}
				return nil
			},
			http.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/GetShelf")),
			http.ServerBefore(httpx.TransportInjector(httpx.HttpServer)),
			http.ServerBefore(httpx.IncomingMetadata),
			http.ServerErrorEncoder(httpx.ErrorEncoder),
		),
		listShelves: http.NewServer(
			endpoints.ListShelves(context.TODO()),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &ListShelvesRequest{}
				queries := r.URL.Query()
				var queryErr error
				req.PageSize, queryErr = errorx.Break[int32](queryErr)(urlx.GetInt[int32](queries, "page_size"))
				req.PageToken = queries.Get("page_token")
				if queryErr != nil {
					return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(queryErr))
				}
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*ListShelvesResponse)
				w.Header().Set("Content-Type", "application/json; charset=utf-8")
				w.WriteHeader(http1.StatusOK)
				if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
					return statusx.ErrInternal.With(statusx.Wrap(err))
				}
				return nil
			},
			http.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/ListShelves")),
			http.ServerBefore(httpx.TransportInjector(httpx.HttpServer)),
			http.ServerBefore(httpx.IncomingMetadata),
			http.ServerErrorEncoder(httpx.ErrorEncoder),
		),
		deleteShelf: http.NewServer(
			endpoints.DeleteShelf(context.TODO()),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &DeleteShelfRequest{}
				vars := urlx.FormFromMap(mux.Vars(r))
				var varErr error
				req.Name = fmt.Sprintf("shelves/%s", vars.Get("shelf"))
				if varErr != nil {
					return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(varErr))
				}
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*emptypb.Empty)
				w.Header().Set("Content-Type", "application/json; charset=utf-8")
				w.WriteHeader(http1.StatusOK)
				if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
					return statusx.ErrInternal.With(statusx.Wrap(err))
				}
				return nil
			},
			http.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/DeleteShelf")),
			http.ServerBefore(httpx.TransportInjector(httpx.HttpServer)),
			http.ServerBefore(httpx.IncomingMetadata),
			http.ServerErrorEncoder(httpx.ErrorEncoder),
		),
		mergeShelves: http.NewServer(
			endpoints.MergeShelves(context.TODO()),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &MergeShelvesRequest{}
				if err := jsonx.NewDecoder(r.Body).Decode(req); err != nil {
					return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
				}
				vars := urlx.FormFromMap(mux.Vars(r))
				var varErr error
				req.Name = fmt.Sprintf("shelves/%s", vars.Get("shelf"))
				if varErr != nil {
					return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(varErr))
				}
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*Shelf)
				w.Header().Set("Content-Type", "application/json; charset=utf-8")
				w.WriteHeader(http1.StatusOK)
				if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
					return statusx.ErrInternal.With(statusx.Wrap(err))
				}
				return nil
			},
			http.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/MergeShelves")),
			http.ServerBefore(httpx.TransportInjector(httpx.HttpServer)),
			http.ServerBefore(httpx.IncomingMetadata),
			http.ServerErrorEncoder(httpx.ErrorEncoder),
		),
		createBook: http.NewServer(
			endpoints.CreateBook(context.TODO()),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &CreateBookRequest{}
				if err := jsonx.NewDecoder(r.Body).Decode(&req.Book); err != nil {
					return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
				}
				vars := urlx.FormFromMap(mux.Vars(r))
				var varErr error
				req.Parent = fmt.Sprintf("shelves/%s", vars.Get("shelf"))
				if varErr != nil {
					return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(varErr))
				}
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*Book)
				w.Header().Set("Content-Type", "application/json; charset=utf-8")
				w.WriteHeader(http1.StatusOK)
				if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
					return statusx.ErrInternal.With(statusx.Wrap(err))
				}
				return nil
			},
			http.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/CreateBook")),
			http.ServerBefore(httpx.TransportInjector(httpx.HttpServer)),
			http.ServerBefore(httpx.IncomingMetadata),
			http.ServerErrorEncoder(httpx.ErrorEncoder),
		),
		getBook: http.NewServer(
			endpoints.GetBook(context.TODO()),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &GetBookRequest{}
				vars := urlx.FormFromMap(mux.Vars(r))
				var varErr error
				req.Name = fmt.Sprintf("shelves/%s/books/%s", vars.Get("shelf"), vars.Get("book"))
				if varErr != nil {
					return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(varErr))
				}
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*Book)
				w.Header().Set("Content-Type", "application/json; charset=utf-8")
				w.WriteHeader(http1.StatusOK)
				if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
					return statusx.ErrInternal.With(statusx.Wrap(err))
				}
				return nil
			},
			http.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/GetBook")),
			http.ServerBefore(httpx.TransportInjector(httpx.HttpServer)),
			http.ServerBefore(httpx.IncomingMetadata),
			http.ServerErrorEncoder(httpx.ErrorEncoder),
		),
		listBooks: http.NewServer(
			endpoints.ListBooks(context.TODO()),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &ListBooksRequest{}
				vars := urlx.FormFromMap(mux.Vars(r))
				var varErr error
				req.Parent = fmt.Sprintf("shelves/%s", vars.Get("shelf"))
				if varErr != nil {
					return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(varErr))
				}
				queries := r.URL.Query()
				var queryErr error
				req.PageSize, queryErr = errorx.Break[int32](queryErr)(urlx.GetInt[int32](queries, "page_size"))
				req.PageToken = queries.Get("page_token")
				if queryErr != nil {
					return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(queryErr))
				}
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*ListBooksResponse)
				w.Header().Set("Content-Type", "application/json; charset=utf-8")
				w.WriteHeader(http1.StatusOK)
				if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
					return statusx.ErrInternal.With(statusx.Wrap(err))
				}
				return nil
			},
			http.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/ListBooks")),
			http.ServerBefore(httpx.TransportInjector(httpx.HttpServer)),
			http.ServerBefore(httpx.IncomingMetadata),
			http.ServerErrorEncoder(httpx.ErrorEncoder),
		),
		deleteBook: http.NewServer(
			endpoints.DeleteBook(context.TODO()),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &DeleteBookRequest{}
				vars := urlx.FormFromMap(mux.Vars(r))
				var varErr error
				req.Name = fmt.Sprintf("shelves/%s/books/%s", vars.Get("shelf"), vars.Get("book"))
				if varErr != nil {
					return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(varErr))
				}
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*emptypb.Empty)
				w.Header().Set("Content-Type", "application/json; charset=utf-8")
				w.WriteHeader(http1.StatusOK)
				if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
					return statusx.ErrInternal.With(statusx.Wrap(err))
				}
				return nil
			},
			http.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/DeleteBook")),
			http.ServerBefore(httpx.TransportInjector(httpx.HttpServer)),
			http.ServerBefore(httpx.IncomingMetadata),
			http.ServerErrorEncoder(httpx.ErrorEncoder),
		),
		updateBook: http.NewServer(
			endpoints.UpdateBook(context.TODO()),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &UpdateBookRequest{}
				if err := jsonx.NewDecoder(r.Body).Decode(&req.Book); err != nil {
					return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
				}
				vars := urlx.FormFromMap(mux.Vars(r))
				var varErr error
				if req.Book == nil {
					req.Book = &Book{}
				}
				req.Book.Name = fmt.Sprintf("shelves/%s/books/%s", vars.Get("shelf"), vars.Get("book"))
				if varErr != nil {
					return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(varErr))
				}
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*Book)
				w.Header().Set("Content-Type", "application/json; charset=utf-8")
				w.WriteHeader(http1.StatusOK)
				if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
					return statusx.ErrInternal.With(statusx.Wrap(err))
				}
				return nil
			},
			http.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/UpdateBook")),
			http.ServerBefore(httpx.TransportInjector(httpx.HttpServer)),
			http.ServerBefore(httpx.IncomingMetadata),
			http.ServerErrorEncoder(httpx.ErrorEncoder),
		),
		moveBook: http.NewServer(
			endpoints.MoveBook(context.TODO()),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &MoveBookRequest{}
				if err := jsonx.NewDecoder(r.Body).Decode(req); err != nil {
					return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
				}
				vars := urlx.FormFromMap(mux.Vars(r))
				var varErr error
				req.Name = fmt.Sprintf("shelves/%s/books/%s", vars.Get("shelf"), vars.Get("book"))
				if varErr != nil {
					return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(varErr))
				}
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*Book)
				w.Header().Set("Content-Type", "application/json; charset=utf-8")
				w.WriteHeader(http1.StatusOK)
				if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
					return statusx.ErrInternal.With(statusx.Wrap(err))
				}
				return nil
			},
			http.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/MoveBook")),
			http.ServerBefore(httpx.TransportInjector(httpx.HttpServer)),
			http.ServerBefore(httpx.IncomingMetadata),
			http.ServerErrorEncoder(httpx.ErrorEncoder),
		),
	}
}

func AppendLibraryServiceHttpRouter(router *mux.Router, svc LibraryServiceService, middlewares ...endpoint.Middleware) *mux.Router {
	endpoints := newLibraryServiceServerEndpoints(svc, middlewares...)
	transports := newLibraryServiceHttpServerTransports(endpoints)
	router.NewRoute().Name("/google.example.library.v1.LibraryService/CreateShelf").Methods("POST").Path("/v1/shelves").Handler(transports.CreateShelf())
	router.NewRoute().Name("/google.example.library.v1.LibraryService/GetShelf").Methods("GET").Path("/v1/shelves/{shelf}").Handler(transports.GetShelf())
	router.NewRoute().Name("/google.example.library.v1.LibraryService/ListShelves").Methods("GET").Path("/v1/shelves").Handler(transports.ListShelves())
	router.NewRoute().Name("/google.example.library.v1.LibraryService/DeleteShelf").Methods("DELETE").Path("/v1/shelves/{shelf}").Handler(transports.DeleteShelf())
	router.NewRoute().Name("/google.example.library.v1.LibraryService/MergeShelves").Methods("POST").Path("/v1/shelves/{shelf}:merge").Handler(transports.MergeShelves())
	router.NewRoute().Name("/google.example.library.v1.LibraryService/CreateBook").Methods("POST").Path("/v1/shelves/{shelf}/books").Handler(transports.CreateBook())
	router.NewRoute().Name("/google.example.library.v1.LibraryService/GetBook").Methods("GET").Path("/v1/shelves/{shelf}/books/{book}").Handler(transports.GetBook())
	router.NewRoute().Name("/google.example.library.v1.LibraryService/ListBooks").Methods("GET").Path("/v1/shelves/{shelf}/books").Handler(transports.ListBooks())
	router.NewRoute().Name("/google.example.library.v1.LibraryService/DeleteBook").Methods("DELETE").Path("/v1/shelves/{shelf}/books/{book}").Handler(transports.DeleteBook())
	router.NewRoute().Name("/google.example.library.v1.LibraryService/UpdateBook").Methods("PATCH").Path("/v1/shelves/{shelf}/books/{book}").Handler(transports.UpdateBook())
	router.NewRoute().Name("/google.example.library.v1.LibraryService/MoveBook").Methods("POST").Path("/v1/shelves/{shelf}/books/{book}:move").Handler(transports.MoveBook())
	return router
}

// =========================== http client ===========================

type libraryServiceHttpClientTransports struct {
	createShelf  transportx.ClientTransport
	getShelf     transportx.ClientTransport
	listShelves  transportx.ClientTransport
	deleteShelf  transportx.ClientTransport
	mergeShelves transportx.ClientTransport
	createBook   transportx.ClientTransport
	getBook      transportx.ClientTransport
	listBooks    transportx.ClientTransport
	deleteBook   transportx.ClientTransport
	updateBook   transportx.ClientTransport
	moveBook     transportx.ClientTransport
}

func (t *libraryServiceHttpClientTransports) CreateShelf() transportx.ClientTransport {
	return t.createShelf
}

func (t *libraryServiceHttpClientTransports) GetShelf() transportx.ClientTransport {
	return t.getShelf
}

func (t *libraryServiceHttpClientTransports) ListShelves() transportx.ClientTransport {
	return t.listShelves
}

func (t *libraryServiceHttpClientTransports) DeleteShelf() transportx.ClientTransport {
	return t.deleteShelf
}

func (t *libraryServiceHttpClientTransports) MergeShelves() transportx.ClientTransport {
	return t.mergeShelves
}

func (t *libraryServiceHttpClientTransports) CreateBook() transportx.ClientTransport {
	return t.createBook
}

func (t *libraryServiceHttpClientTransports) GetBook() transportx.ClientTransport {
	return t.getBook
}

func (t *libraryServiceHttpClientTransports) ListBooks() transportx.ClientTransport {
	return t.listBooks
}

func (t *libraryServiceHttpClientTransports) DeleteBook() transportx.ClientTransport {
	return t.deleteBook
}

func (t *libraryServiceHttpClientTransports) UpdateBook() transportx.ClientTransport {
	return t.updateBook
}

func (t *libraryServiceHttpClientTransports) MoveBook() transportx.ClientTransport {
	return t.moveBook
}

func NewLibraryServiceHttpClientTransports(target string, options ...transportx.ClientTransportOption) (LibraryServiceClientTransports, error) {
	router := mux.NewRouter()
	router.NewRoute().Name("/google.example.library.v1.LibraryService/CreateShelf").Methods("POST").Path("/v1/shelves")
	router.NewRoute().Name("/google.example.library.v1.LibraryService/GetShelf").Methods("GET").Path("/v1/shelves/{shelf}")
	router.NewRoute().Name("/google.example.library.v1.LibraryService/ListShelves").Methods("GET").Path("/v1/shelves")
	router.NewRoute().Name("/google.example.library.v1.LibraryService/DeleteShelf").Methods("DELETE").Path("/v1/shelves/{shelf}")
	router.NewRoute().Name("/google.example.library.v1.LibraryService/MergeShelves").Methods("POST").Path("/v1/shelves/{shelf}:merge")
	router.NewRoute().Name("/google.example.library.v1.LibraryService/CreateBook").Methods("POST").Path("/v1/shelves/{shelf}/books")
	router.NewRoute().Name("/google.example.library.v1.LibraryService/GetBook").Methods("GET").Path("/v1/shelves/{shelf}/books/{book}")
	router.NewRoute().Name("/google.example.library.v1.LibraryService/ListBooks").Methods("GET").Path("/v1/shelves/{shelf}/books")
	router.NewRoute().Name("/google.example.library.v1.LibraryService/DeleteBook").Methods("DELETE").Path("/v1/shelves/{shelf}/books/{book}")
	router.NewRoute().Name("/google.example.library.v1.LibraryService/UpdateBook").Methods("PATCH").Path("/v1/shelves/{shelf}/books/{book}")
	router.NewRoute().Name("/google.example.library.v1.LibraryService/MoveBook").Methods("POST").Path("/v1/shelves/{shelf}/books/{book}:move")
	t := &libraryServiceHttpClientTransports{}
	var err error
	t.createShelf, err = errorx.Break[transportx.ClientTransport](err)(func() (transportx.ClientTransport, error) {
		return transportx.NewClientTransport(
			target,
			httpx.ClientFactory(
				func(scheme string, instance string) http.CreateRequestFunc {
					return func(ctx context.Context, obj any) (*http1.Request, error) {
						if obj == nil {
							return nil, errors.New("request object is nil")
						}
						req, ok := obj.(*CreateShelfRequest)
						if !ok {
							return nil, fmt.Errorf("invalid request object type, %T", obj)
						}
						_ = req
						var body io.Reader
						var bodyBuf bytes.Buffer
						if err := jsonx.NewEncoder(&bodyBuf).Encode(req.GetShelf()); err != nil {
							return nil, err
						}
						body = &bodyBuf
						contentType := "application/json; charset=utf-8"
						var pairs []string
						path, err := router.Get("/google.example.library.v1.LibraryService/CreateShelf").URLPath(pairs...)
						if err != nil {
							return nil, err
						}
						queries := url.Values{}
						target := &url.URL{
							Scheme:   scheme,
							Host:     instance,
							Path:     path.Path,
							RawQuery: queries.Encode(),
						}
						r, err := http1.NewRequestWithContext(ctx, "POST", target.String(), body)
						if err != nil {
							return nil, err
						}
						r.Header.Set("Content-Type", contentType)
						return r, nil
					}
				},
				func(ctx context.Context, r *http1.Response) (any, error) {
					if httpx.IsErrorResponse(r) {
						return nil, httpx.ErrorDecoder(ctx, r)
					}
					resp := &Shelf{}
					if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
						return nil, err
					}
					return resp, nil
				},
				http.ClientBefore(httpx.OutgoingMetadata),
			),
			options...,
		)
	})
	t.getShelf, err = errorx.Break[transportx.ClientTransport](err)(func() (transportx.ClientTransport, error) {
		return transportx.NewClientTransport(
			target,
			httpx.ClientFactory(
				func(scheme string, instance string) http.CreateRequestFunc {
					return func(ctx context.Context, obj any) (*http1.Request, error) {
						if obj == nil {
							return nil, errors.New("request object is nil")
						}
						req, ok := obj.(*GetShelfRequest)
						if !ok {
							return nil, fmt.Errorf("invalid request object type, %T", obj)
						}
						_ = req
						var body io.Reader
						var pairs []string
						namedPathParameter := req.GetName()
						namedPathValues := strings.Split(namedPathParameter, "/")
						if len(namedPathValues) != 2 {
							return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
						}
						pairs = append(pairs, "shelf", namedPathValues[1])
						path, err := router.Get("/google.example.library.v1.LibraryService/GetShelf").URLPath(pairs...)
						if err != nil {
							return nil, err
						}
						queries := url.Values{}
						target := &url.URL{
							Scheme:   scheme,
							Host:     instance,
							Path:     path.Path,
							RawQuery: queries.Encode(),
						}
						r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
						if err != nil {
							return nil, err
						}
						return r, nil
					}
				},
				func(ctx context.Context, r *http1.Response) (any, error) {
					if httpx.IsErrorResponse(r) {
						return nil, httpx.ErrorDecoder(ctx, r)
					}
					resp := &Shelf{}
					if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
						return nil, err
					}
					return resp, nil
				},
				http.ClientBefore(httpx.OutgoingMetadata),
			),
			options...,
		)
	})
	t.listShelves, err = errorx.Break[transportx.ClientTransport](err)(func() (transportx.ClientTransport, error) {
		return transportx.NewClientTransport(
			target,
			httpx.ClientFactory(
				func(scheme string, instance string) http.CreateRequestFunc {
					return func(ctx context.Context, obj any) (*http1.Request, error) {
						if obj == nil {
							return nil, errors.New("request object is nil")
						}
						req, ok := obj.(*ListShelvesRequest)
						if !ok {
							return nil, fmt.Errorf("invalid request object type, %T", obj)
						}
						_ = req
						var body io.Reader
						var pairs []string
						path, err := router.Get("/google.example.library.v1.LibraryService/ListShelves").URLPath(pairs...)
						if err != nil {
							return nil, err
						}
						queries := url.Values{}
						queries["page_size"] = append(queries["page_size"], strconvx.FormatInt(req.GetPageSize(), 10))
						queries["page_token"] = append(queries["page_token"], req.GetPageToken())
						target := &url.URL{
							Scheme:   scheme,
							Host:     instance,
							Path:     path.Path,
							RawQuery: queries.Encode(),
						}
						r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
						if err != nil {
							return nil, err
						}
						return r, nil
					}
				},
				func(ctx context.Context, r *http1.Response) (any, error) {
					if httpx.IsErrorResponse(r) {
						return nil, httpx.ErrorDecoder(ctx, r)
					}
					resp := &ListShelvesResponse{}
					if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
						return nil, err
					}
					return resp, nil
				},
				http.ClientBefore(httpx.OutgoingMetadata),
			),
			options...,
		)
	})
	t.deleteShelf, err = errorx.Break[transportx.ClientTransport](err)(func() (transportx.ClientTransport, error) {
		return transportx.NewClientTransport(
			target,
			httpx.ClientFactory(
				func(scheme string, instance string) http.CreateRequestFunc {
					return func(ctx context.Context, obj any) (*http1.Request, error) {
						if obj == nil {
							return nil, errors.New("request object is nil")
						}
						req, ok := obj.(*DeleteShelfRequest)
						if !ok {
							return nil, fmt.Errorf("invalid request object type, %T", obj)
						}
						_ = req
						var body io.Reader
						var pairs []string
						namedPathParameter := req.GetName()
						namedPathValues := strings.Split(namedPathParameter, "/")
						if len(namedPathValues) != 2 {
							return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
						}
						pairs = append(pairs, "shelf", namedPathValues[1])
						path, err := router.Get("/google.example.library.v1.LibraryService/DeleteShelf").URLPath(pairs...)
						if err != nil {
							return nil, err
						}
						queries := url.Values{}
						target := &url.URL{
							Scheme:   scheme,
							Host:     instance,
							Path:     path.Path,
							RawQuery: queries.Encode(),
						}
						r, err := http1.NewRequestWithContext(ctx, "DELETE", target.String(), body)
						if err != nil {
							return nil, err
						}
						return r, nil
					}
				},
				func(ctx context.Context, r *http1.Response) (any, error) {
					if httpx.IsErrorResponse(r) {
						return nil, httpx.ErrorDecoder(ctx, r)
					}
					resp := &emptypb.Empty{}
					if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
						return nil, err
					}
					return resp, nil
				},
				http.ClientBefore(httpx.OutgoingMetadata),
			),
			options...,
		)
	})
	t.mergeShelves, err = errorx.Break[transportx.ClientTransport](err)(func() (transportx.ClientTransport, error) {
		return transportx.NewClientTransport(
			target,
			httpx.ClientFactory(
				func(scheme string, instance string) http.CreateRequestFunc {
					return func(ctx context.Context, obj any) (*http1.Request, error) {
						if obj == nil {
							return nil, errors.New("request object is nil")
						}
						req, ok := obj.(*MergeShelvesRequest)
						if !ok {
							return nil, fmt.Errorf("invalid request object type, %T", obj)
						}
						_ = req
						var body io.Reader
						var bodyBuf bytes.Buffer
						if err := jsonx.NewEncoder(&bodyBuf).Encode(req); err != nil {
							return nil, err
						}
						body = &bodyBuf
						contentType := "application/json; charset=utf-8"
						var pairs []string
						namedPathParameter := req.GetName()
						namedPathValues := strings.Split(namedPathParameter, "/")
						if len(namedPathValues) != 2 {
							return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
						}
						pairs = append(pairs, "shelf", namedPathValues[1])
						path, err := router.Get("/google.example.library.v1.LibraryService/MergeShelves").URLPath(pairs...)
						if err != nil {
							return nil, err
						}
						queries := url.Values{}
						target := &url.URL{
							Scheme:   scheme,
							Host:     instance,
							Path:     path.Path,
							RawQuery: queries.Encode(),
						}
						r, err := http1.NewRequestWithContext(ctx, "POST", target.String(), body)
						if err != nil {
							return nil, err
						}
						r.Header.Set("Content-Type", contentType)
						return r, nil
					}
				},
				func(ctx context.Context, r *http1.Response) (any, error) {
					if httpx.IsErrorResponse(r) {
						return nil, httpx.ErrorDecoder(ctx, r)
					}
					resp := &Shelf{}
					if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
						return nil, err
					}
					return resp, nil
				},
				http.ClientBefore(httpx.OutgoingMetadata),
			),
			options...,
		)
	})
	t.createBook, err = errorx.Break[transportx.ClientTransport](err)(func() (transportx.ClientTransport, error) {
		return transportx.NewClientTransport(
			target,
			httpx.ClientFactory(
				func(scheme string, instance string) http.CreateRequestFunc {
					return func(ctx context.Context, obj any) (*http1.Request, error) {
						if obj == nil {
							return nil, errors.New("request object is nil")
						}
						req, ok := obj.(*CreateBookRequest)
						if !ok {
							return nil, fmt.Errorf("invalid request object type, %T", obj)
						}
						_ = req
						var body io.Reader
						var bodyBuf bytes.Buffer
						if err := jsonx.NewEncoder(&bodyBuf).Encode(req.GetBook()); err != nil {
							return nil, err
						}
						body = &bodyBuf
						contentType := "application/json; charset=utf-8"
						var pairs []string
						namedPathParameter := req.GetParent()
						namedPathValues := strings.Split(namedPathParameter, "/")
						if len(namedPathValues) != 2 {
							return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
						}
						pairs = append(pairs, "shelf", namedPathValues[1])
						path, err := router.Get("/google.example.library.v1.LibraryService/CreateBook").URLPath(pairs...)
						if err != nil {
							return nil, err
						}
						queries := url.Values{}
						target := &url.URL{
							Scheme:   scheme,
							Host:     instance,
							Path:     path.Path,
							RawQuery: queries.Encode(),
						}
						r, err := http1.NewRequestWithContext(ctx, "POST", target.String(), body)
						if err != nil {
							return nil, err
						}
						r.Header.Set("Content-Type", contentType)
						return r, nil
					}
				},
				func(ctx context.Context, r *http1.Response) (any, error) {
					if httpx.IsErrorResponse(r) {
						return nil, httpx.ErrorDecoder(ctx, r)
					}
					resp := &Book{}
					if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
						return nil, err
					}
					return resp, nil
				},
				http.ClientBefore(httpx.OutgoingMetadata),
			),
			options...,
		)
	})
	t.getBook, err = errorx.Break[transportx.ClientTransport](err)(func() (transportx.ClientTransport, error) {
		return transportx.NewClientTransport(
			target,
			httpx.ClientFactory(
				func(scheme string, instance string) http.CreateRequestFunc {
					return func(ctx context.Context, obj any) (*http1.Request, error) {
						if obj == nil {
							return nil, errors.New("request object is nil")
						}
						req, ok := obj.(*GetBookRequest)
						if !ok {
							return nil, fmt.Errorf("invalid request object type, %T", obj)
						}
						_ = req
						var body io.Reader
						var pairs []string
						namedPathParameter := req.GetName()
						namedPathValues := strings.Split(namedPathParameter, "/")
						if len(namedPathValues) != 4 {
							return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
						}
						pairs = append(pairs, "shelf", namedPathValues[1], "book", namedPathValues[3])
						path, err := router.Get("/google.example.library.v1.LibraryService/GetBook").URLPath(pairs...)
						if err != nil {
							return nil, err
						}
						queries := url.Values{}
						target := &url.URL{
							Scheme:   scheme,
							Host:     instance,
							Path:     path.Path,
							RawQuery: queries.Encode(),
						}
						r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
						if err != nil {
							return nil, err
						}
						return r, nil
					}
				},
				func(ctx context.Context, r *http1.Response) (any, error) {
					if httpx.IsErrorResponse(r) {
						return nil, httpx.ErrorDecoder(ctx, r)
					}
					resp := &Book{}
					if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
						return nil, err
					}
					return resp, nil
				},
				http.ClientBefore(httpx.OutgoingMetadata),
			),
			options...,
		)
	})
	t.listBooks, err = errorx.Break[transportx.ClientTransport](err)(func() (transportx.ClientTransport, error) {
		return transportx.NewClientTransport(
			target,
			httpx.ClientFactory(
				func(scheme string, instance string) http.CreateRequestFunc {
					return func(ctx context.Context, obj any) (*http1.Request, error) {
						if obj == nil {
							return nil, errors.New("request object is nil")
						}
						req, ok := obj.(*ListBooksRequest)
						if !ok {
							return nil, fmt.Errorf("invalid request object type, %T", obj)
						}
						_ = req
						var body io.Reader
						var pairs []string
						namedPathParameter := req.GetParent()
						namedPathValues := strings.Split(namedPathParameter, "/")
						if len(namedPathValues) != 2 {
							return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
						}
						pairs = append(pairs, "shelf", namedPathValues[1])
						path, err := router.Get("/google.example.library.v1.LibraryService/ListBooks").URLPath(pairs...)
						if err != nil {
							return nil, err
						}
						queries := url.Values{}
						queries["page_size"] = append(queries["page_size"], strconvx.FormatInt(req.GetPageSize(), 10))
						queries["page_token"] = append(queries["page_token"], req.GetPageToken())
						target := &url.URL{
							Scheme:   scheme,
							Host:     instance,
							Path:     path.Path,
							RawQuery: queries.Encode(),
						}
						r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
						if err != nil {
							return nil, err
						}
						return r, nil
					}
				},
				func(ctx context.Context, r *http1.Response) (any, error) {
					if httpx.IsErrorResponse(r) {
						return nil, httpx.ErrorDecoder(ctx, r)
					}
					resp := &ListBooksResponse{}
					if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
						return nil, err
					}
					return resp, nil
				},
				http.ClientBefore(httpx.OutgoingMetadata),
			),
			options...,
		)
	})
	t.deleteBook, err = errorx.Break[transportx.ClientTransport](err)(func() (transportx.ClientTransport, error) {
		return transportx.NewClientTransport(
			target,
			httpx.ClientFactory(
				func(scheme string, instance string) http.CreateRequestFunc {
					return func(ctx context.Context, obj any) (*http1.Request, error) {
						if obj == nil {
							return nil, errors.New("request object is nil")
						}
						req, ok := obj.(*DeleteBookRequest)
						if !ok {
							return nil, fmt.Errorf("invalid request object type, %T", obj)
						}
						_ = req
						var body io.Reader
						var pairs []string
						namedPathParameter := req.GetName()
						namedPathValues := strings.Split(namedPathParameter, "/")
						if len(namedPathValues) != 4 {
							return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
						}
						pairs = append(pairs, "shelf", namedPathValues[1], "book", namedPathValues[3])
						path, err := router.Get("/google.example.library.v1.LibraryService/DeleteBook").URLPath(pairs...)
						if err != nil {
							return nil, err
						}
						queries := url.Values{}
						target := &url.URL{
							Scheme:   scheme,
							Host:     instance,
							Path:     path.Path,
							RawQuery: queries.Encode(),
						}
						r, err := http1.NewRequestWithContext(ctx, "DELETE", target.String(), body)
						if err != nil {
							return nil, err
						}
						return r, nil
					}
				},
				func(ctx context.Context, r *http1.Response) (any, error) {
					if httpx.IsErrorResponse(r) {
						return nil, httpx.ErrorDecoder(ctx, r)
					}
					resp := &emptypb.Empty{}
					if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
						return nil, err
					}
					return resp, nil
				},
				http.ClientBefore(httpx.OutgoingMetadata),
			),
			options...,
		)
	})
	t.updateBook, err = errorx.Break[transportx.ClientTransport](err)(func() (transportx.ClientTransport, error) {
		return transportx.NewClientTransport(
			target,
			httpx.ClientFactory(
				func(scheme string, instance string) http.CreateRequestFunc {
					return func(ctx context.Context, obj any) (*http1.Request, error) {
						if obj == nil {
							return nil, errors.New("request object is nil")
						}
						req, ok := obj.(*UpdateBookRequest)
						if !ok {
							return nil, fmt.Errorf("invalid request object type, %T", obj)
						}
						_ = req
						var body io.Reader
						var bodyBuf bytes.Buffer
						if err := jsonx.NewEncoder(&bodyBuf).Encode(req.GetBook()); err != nil {
							return nil, err
						}
						body = &bodyBuf
						contentType := "application/json; charset=utf-8"
						var pairs []string
						namedPathParameter := req.GetBook().GetName()
						namedPathValues := strings.Split(namedPathParameter, "/")
						if len(namedPathValues) != 4 {
							return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
						}
						pairs = append(pairs, "shelf", namedPathValues[1], "book", namedPathValues[3])
						path, err := router.Get("/google.example.library.v1.LibraryService/UpdateBook").URLPath(pairs...)
						if err != nil {
							return nil, err
						}
						queries := url.Values{}
						target := &url.URL{
							Scheme:   scheme,
							Host:     instance,
							Path:     path.Path,
							RawQuery: queries.Encode(),
						}
						r, err := http1.NewRequestWithContext(ctx, "PATCH", target.String(), body)
						if err != nil {
							return nil, err
						}
						r.Header.Set("Content-Type", contentType)
						return r, nil
					}
				},
				func(ctx context.Context, r *http1.Response) (any, error) {
					if httpx.IsErrorResponse(r) {
						return nil, httpx.ErrorDecoder(ctx, r)
					}
					resp := &Book{}
					if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
						return nil, err
					}
					return resp, nil
				},
				http.ClientBefore(httpx.OutgoingMetadata),
			),
			options...,
		)
	})
	t.moveBook, err = errorx.Break[transportx.ClientTransport](err)(func() (transportx.ClientTransport, error) {
		return transportx.NewClientTransport(
			target,
			httpx.ClientFactory(
				func(scheme string, instance string) http.CreateRequestFunc {
					return func(ctx context.Context, obj any) (*http1.Request, error) {
						if obj == nil {
							return nil, errors.New("request object is nil")
						}
						req, ok := obj.(*MoveBookRequest)
						if !ok {
							return nil, fmt.Errorf("invalid request object type, %T", obj)
						}
						_ = req
						var body io.Reader
						var bodyBuf bytes.Buffer
						if err := jsonx.NewEncoder(&bodyBuf).Encode(req); err != nil {
							return nil, err
						}
						body = &bodyBuf
						contentType := "application/json; charset=utf-8"
						var pairs []string
						namedPathParameter := req.GetName()
						namedPathValues := strings.Split(namedPathParameter, "/")
						if len(namedPathValues) != 4 {
							return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
						}
						pairs = append(pairs, "shelf", namedPathValues[1], "book", namedPathValues[3])
						path, err := router.Get("/google.example.library.v1.LibraryService/MoveBook").URLPath(pairs...)
						if err != nil {
							return nil, err
						}
						queries := url.Values{}
						target := &url.URL{
							Scheme:   scheme,
							Host:     instance,
							Path:     path.Path,
							RawQuery: queries.Encode(),
						}
						r, err := http1.NewRequestWithContext(ctx, "POST", target.String(), body)
						if err != nil {
							return nil, err
						}
						r.Header.Set("Content-Type", contentType)
						return r, nil
					}
				},
				func(ctx context.Context, r *http1.Response) (any, error) {
					if httpx.IsErrorResponse(r) {
						return nil, httpx.ErrorDecoder(ctx, r)
					}
					resp := &Book{}
					if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
						return nil, err
					}
					return resp, nil
				},
				http.ClientBefore(httpx.OutgoingMetadata),
			),
			options...,
		)
	})
	return t, err
}

type libraryServiceHttpClient struct {
	endpoints LibraryServiceEndpoints
}

func (c *libraryServiceHttpClient) CreateShelf(ctx context.Context, request *CreateShelfRequest) (*Shelf, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/CreateShelf")
	ctx = transportx.InjectName(ctx, httpx.HttpClient)
	rep, err := c.endpoints.CreateShelf(ctx)(ctx, request)
	if err != nil {
		return nil, statusx.From(err)
	}
	return rep.(*Shelf), nil
}

func (c *libraryServiceHttpClient) GetShelf(ctx context.Context, request *GetShelfRequest) (*Shelf, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/GetShelf")
	ctx = transportx.InjectName(ctx, httpx.HttpClient)
	rep, err := c.endpoints.GetShelf(ctx)(ctx, request)
	if err != nil {
		return nil, statusx.From(err)
	}
	return rep.(*Shelf), nil
}

func (c *libraryServiceHttpClient) ListShelves(ctx context.Context, request *ListShelvesRequest) (*ListShelvesResponse, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/ListShelves")
	ctx = transportx.InjectName(ctx, httpx.HttpClient)
	rep, err := c.endpoints.ListShelves(ctx)(ctx, request)
	if err != nil {
		return nil, statusx.From(err)
	}
	return rep.(*ListShelvesResponse), nil
}

func (c *libraryServiceHttpClient) DeleteShelf(ctx context.Context, request *DeleteShelfRequest) (*emptypb.Empty, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/DeleteShelf")
	ctx = transportx.InjectName(ctx, httpx.HttpClient)
	rep, err := c.endpoints.DeleteShelf(ctx)(ctx, request)
	if err != nil {
		return nil, statusx.From(err)
	}
	return rep.(*emptypb.Empty), nil
}

func (c *libraryServiceHttpClient) MergeShelves(ctx context.Context, request *MergeShelvesRequest) (*Shelf, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/MergeShelves")
	ctx = transportx.InjectName(ctx, httpx.HttpClient)
	rep, err := c.endpoints.MergeShelves(ctx)(ctx, request)
	if err != nil {
		return nil, statusx.From(err)
	}
	return rep.(*Shelf), nil
}

func (c *libraryServiceHttpClient) CreateBook(ctx context.Context, request *CreateBookRequest) (*Book, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/CreateBook")
	ctx = transportx.InjectName(ctx, httpx.HttpClient)
	rep, err := c.endpoints.CreateBook(ctx)(ctx, request)
	if err != nil {
		return nil, statusx.From(err)
	}
	return rep.(*Book), nil
}

func (c *libraryServiceHttpClient) GetBook(ctx context.Context, request *GetBookRequest) (*Book, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/GetBook")
	ctx = transportx.InjectName(ctx, httpx.HttpClient)
	rep, err := c.endpoints.GetBook(ctx)(ctx, request)
	if err != nil {
		return nil, statusx.From(err)
	}
	return rep.(*Book), nil
}

func (c *libraryServiceHttpClient) ListBooks(ctx context.Context, request *ListBooksRequest) (*ListBooksResponse, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/ListBooks")
	ctx = transportx.InjectName(ctx, httpx.HttpClient)
	rep, err := c.endpoints.ListBooks(ctx)(ctx, request)
	if err != nil {
		return nil, statusx.From(err)
	}
	return rep.(*ListBooksResponse), nil
}

func (c *libraryServiceHttpClient) DeleteBook(ctx context.Context, request *DeleteBookRequest) (*emptypb.Empty, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/DeleteBook")
	ctx = transportx.InjectName(ctx, httpx.HttpClient)
	rep, err := c.endpoints.DeleteBook(ctx)(ctx, request)
	if err != nil {
		return nil, statusx.From(err)
	}
	return rep.(*emptypb.Empty), nil
}

func (c *libraryServiceHttpClient) UpdateBook(ctx context.Context, request *UpdateBookRequest) (*Book, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/UpdateBook")
	ctx = transportx.InjectName(ctx, httpx.HttpClient)
	rep, err := c.endpoints.UpdateBook(ctx)(ctx, request)
	if err != nil {
		return nil, statusx.From(err)
	}
	return rep.(*Book), nil
}

func (c *libraryServiceHttpClient) MoveBook(ctx context.Context, request *MoveBookRequest) (*Book, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/MoveBook")
	ctx = transportx.InjectName(ctx, httpx.HttpClient)
	rep, err := c.endpoints.MoveBook(ctx)(ctx, request)
	if err != nil {
		return nil, statusx.From(err)
	}
	return rep.(*Book), nil
}

func NewLibraryServiceHttpClient(transports LibraryServiceClientTransports, middlewares ...endpoint.Middleware) LibraryServiceService {
	endpoints := newLibraryServiceClientEndpoints(transports, middlewares...)
	return &libraryServiceHttpClient{endpoints: endpoints}
}
