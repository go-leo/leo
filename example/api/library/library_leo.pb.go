// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package library

import (
	bytes "bytes"
	context "context"
	errors "errors"
	fmt "fmt"
	endpoint "github.com/go-kit/kit/endpoint"
	sd "github.com/go-kit/kit/sd"
	grpc "github.com/go-kit/kit/transport/grpc"
	http "github.com/go-kit/kit/transport/http"
	jsonx "github.com/go-leo/gox/encodingx/jsonx"
	errorx "github.com/go-leo/gox/errorx"
	urlx "github.com/go-leo/gox/netx/urlx"
	strconvx "github.com/go-leo/gox/strconvx"
	endpointx "github.com/go-leo/leo/v3/endpointx"
	statusx "github.com/go-leo/leo/v3/statusx"
	transportx "github.com/go-leo/leo/v3/transportx"
	grpcx "github.com/go-leo/leo/v3/transportx/grpcx"
	httpx "github.com/go-leo/leo/v3/transportx/httpx"
	mux "github.com/gorilla/mux"
	grpc1 "google.golang.org/grpc"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	io "io"
	http1 "net/http"
	url "net/url"
	strings "strings"
)

// =========================== endpoints ===========================

type LibraryServiceService interface {
	CreateShelf(ctx context.Context, request *CreateShelfRequest) (*Shelf, error)
	GetShelf(ctx context.Context, request *GetShelfRequest) (*Shelf, error)
	ListShelves(ctx context.Context, request *ListShelvesRequest) (*ListShelvesResponse, error)
	DeleteShelf(ctx context.Context, request *DeleteShelfRequest) (*emptypb.Empty, error)
	MergeShelves(ctx context.Context, request *MergeShelvesRequest) (*Shelf, error)
	CreateBook(ctx context.Context, request *CreateBookRequest) (*Book, error)
	GetBook(ctx context.Context, request *GetBookRequest) (*Book, error)
	ListBooks(ctx context.Context, request *ListBooksRequest) (*ListBooksResponse, error)
	DeleteBook(ctx context.Context, request *DeleteBookRequest) (*emptypb.Empty, error)
	UpdateBook(ctx context.Context, request *UpdateBookRequest) (*Book, error)
	MoveBook(ctx context.Context, request *MoveBookRequest) (*Book, error)
}

type LibraryServiceEndpoints interface {
	CreateShelf() endpoint.Endpoint
	GetShelf() endpoint.Endpoint
	ListShelves() endpoint.Endpoint
	DeleteShelf() endpoint.Endpoint
	MergeShelves() endpoint.Endpoint
	CreateBook() endpoint.Endpoint
	GetBook() endpoint.Endpoint
	ListBooks() endpoint.Endpoint
	DeleteBook() endpoint.Endpoint
	UpdateBook() endpoint.Endpoint
	MoveBook() endpoint.Endpoint
}

type LibraryServiceTransports interface {
	CreateShelf() transportx.Transport
	GetShelf() transportx.Transport
	ListShelves() transportx.Transport
	DeleteShelf() transportx.Transport
	MergeShelves() transportx.Transport
	CreateBook() transportx.Transport
	GetBook() transportx.Transport
	ListBooks() transportx.Transport
	DeleteBook() transportx.Transport
	UpdateBook() transportx.Transport
	MoveBook() transportx.Transport
}

type LibraryServiceFactories interface {
	CreateShelf(middlewares ...endpoint.Middleware) sd.Factory
	GetShelf(middlewares ...endpoint.Middleware) sd.Factory
	ListShelves(middlewares ...endpoint.Middleware) sd.Factory
	DeleteShelf(middlewares ...endpoint.Middleware) sd.Factory
	MergeShelves(middlewares ...endpoint.Middleware) sd.Factory
	CreateBook(middlewares ...endpoint.Middleware) sd.Factory
	GetBook(middlewares ...endpoint.Middleware) sd.Factory
	ListBooks(middlewares ...endpoint.Middleware) sd.Factory
	DeleteBook(middlewares ...endpoint.Middleware) sd.Factory
	UpdateBook(middlewares ...endpoint.Middleware) sd.Factory
	MoveBook(middlewares ...endpoint.Middleware) sd.Factory
}

type LibraryServiceEndpointers interface {
	CreateShelf() sd.Endpointer
	GetShelf() sd.Endpointer
	ListShelves() sd.Endpointer
	DeleteShelf() sd.Endpointer
	MergeShelves() sd.Endpointer
	CreateBook() sd.Endpointer
	GetBook() sd.Endpointer
	ListBooks() sd.Endpointer
	DeleteBook() sd.Endpointer
	UpdateBook() sd.Endpointer
	MoveBook() sd.Endpointer
}

type libraryServiceEndpoints struct {
	svc         LibraryServiceService
	middlewares []endpoint.Middleware
}

func (e *libraryServiceEndpoints) CreateShelf() endpoint.Endpoint {
	component := func(ctx context.Context, request any) (any, error) {
		return e.svc.CreateShelf(ctx, request.(*CreateShelfRequest))
	}
	return endpointx.Chain(component, e.middlewares...)
}

func (e *libraryServiceEndpoints) GetShelf() endpoint.Endpoint {
	component := func(ctx context.Context, request any) (any, error) {
		return e.svc.GetShelf(ctx, request.(*GetShelfRequest))
	}
	return endpointx.Chain(component, e.middlewares...)
}

func (e *libraryServiceEndpoints) ListShelves() endpoint.Endpoint {
	component := func(ctx context.Context, request any) (any, error) {
		return e.svc.ListShelves(ctx, request.(*ListShelvesRequest))
	}
	return endpointx.Chain(component, e.middlewares...)
}

func (e *libraryServiceEndpoints) DeleteShelf() endpoint.Endpoint {
	component := func(ctx context.Context, request any) (any, error) {
		return e.svc.DeleteShelf(ctx, request.(*DeleteShelfRequest))
	}
	return endpointx.Chain(component, e.middlewares...)
}

func (e *libraryServiceEndpoints) MergeShelves() endpoint.Endpoint {
	component := func(ctx context.Context, request any) (any, error) {
		return e.svc.MergeShelves(ctx, request.(*MergeShelvesRequest))
	}
	return endpointx.Chain(component, e.middlewares...)
}

func (e *libraryServiceEndpoints) CreateBook() endpoint.Endpoint {
	component := func(ctx context.Context, request any) (any, error) {
		return e.svc.CreateBook(ctx, request.(*CreateBookRequest))
	}
	return endpointx.Chain(component, e.middlewares...)
}

func (e *libraryServiceEndpoints) GetBook() endpoint.Endpoint {
	component := func(ctx context.Context, request any) (any, error) {
		return e.svc.GetBook(ctx, request.(*GetBookRequest))
	}
	return endpointx.Chain(component, e.middlewares...)
}

func (e *libraryServiceEndpoints) ListBooks() endpoint.Endpoint {
	component := func(ctx context.Context, request any) (any, error) {
		return e.svc.ListBooks(ctx, request.(*ListBooksRequest))
	}
	return endpointx.Chain(component, e.middlewares...)
}

func (e *libraryServiceEndpoints) DeleteBook() endpoint.Endpoint {
	component := func(ctx context.Context, request any) (any, error) {
		return e.svc.DeleteBook(ctx, request.(*DeleteBookRequest))
	}
	return endpointx.Chain(component, e.middlewares...)
}

func (e *libraryServiceEndpoints) UpdateBook() endpoint.Endpoint {
	component := func(ctx context.Context, request any) (any, error) {
		return e.svc.UpdateBook(ctx, request.(*UpdateBookRequest))
	}
	return endpointx.Chain(component, e.middlewares...)
}

func (e *libraryServiceEndpoints) MoveBook() endpoint.Endpoint {
	component := func(ctx context.Context, request any) (any, error) {
		return e.svc.MoveBook(ctx, request.(*MoveBookRequest))
	}
	return endpointx.Chain(component, e.middlewares...)
}

func NewLibraryServiceEndpoints(svc LibraryServiceService, middlewares ...endpoint.Middleware) LibraryServiceEndpoints {
	return &libraryServiceEndpoints{svc: svc, middlewares: middlewares}
}

// =========================== cqrs ===========================

// =========================== grpc server ===========================

type LibraryServiceGrpcServerTransports interface {
	CreateShelf() *grpc.Server
	GetShelf() *grpc.Server
	ListShelves() *grpc.Server
	DeleteShelf() *grpc.Server
	MergeShelves() *grpc.Server
	CreateBook() *grpc.Server
	GetBook() *grpc.Server
	ListBooks() *grpc.Server
	DeleteBook() *grpc.Server
	UpdateBook() *grpc.Server
	MoveBook() *grpc.Server
}

type libraryServiceGrpcServerTransports struct {
	createShelf  *grpc.Server
	getShelf     *grpc.Server
	listShelves  *grpc.Server
	deleteShelf  *grpc.Server
	mergeShelves *grpc.Server
	createBook   *grpc.Server
	getBook      *grpc.Server
	listBooks    *grpc.Server
	deleteBook   *grpc.Server
	updateBook   *grpc.Server
	moveBook     *grpc.Server
}

func (t *libraryServiceGrpcServerTransports) CreateShelf() *grpc.Server {
	return t.createShelf
}

func (t *libraryServiceGrpcServerTransports) GetShelf() *grpc.Server {
	return t.getShelf
}

func (t *libraryServiceGrpcServerTransports) ListShelves() *grpc.Server {
	return t.listShelves
}

func (t *libraryServiceGrpcServerTransports) DeleteShelf() *grpc.Server {
	return t.deleteShelf
}

func (t *libraryServiceGrpcServerTransports) MergeShelves() *grpc.Server {
	return t.mergeShelves
}

func (t *libraryServiceGrpcServerTransports) CreateBook() *grpc.Server {
	return t.createBook
}

func (t *libraryServiceGrpcServerTransports) GetBook() *grpc.Server {
	return t.getBook
}

func (t *libraryServiceGrpcServerTransports) ListBooks() *grpc.Server {
	return t.listBooks
}

func (t *libraryServiceGrpcServerTransports) DeleteBook() *grpc.Server {
	return t.deleteBook
}

func (t *libraryServiceGrpcServerTransports) UpdateBook() *grpc.Server {
	return t.updateBook
}

func (t *libraryServiceGrpcServerTransports) MoveBook() *grpc.Server {
	return t.moveBook
}

func NewLibraryServiceGrpcServerTransports(endpoints LibraryServiceEndpoints) LibraryServiceGrpcServerTransports {
	return &libraryServiceGrpcServerTransports{
		createShelf: grpc.NewServer(
			endpoints.CreateShelf(),
			func(_ context.Context, v any) (any, error) { return v, nil },
			func(_ context.Context, v any) (any, error) { return v, nil },
			grpc.ServerBefore(grpcx.ServerEndpointInjector("/google.example.library.v1.LibraryService/CreateShelf")),
			grpc.ServerBefore(grpcx.ServerTransportInjector),
			grpc.ServerBefore(grpcx.IncomingMetadata),
		),
		getShelf: grpc.NewServer(
			endpoints.GetShelf(),
			func(_ context.Context, v any) (any, error) { return v, nil },
			func(_ context.Context, v any) (any, error) { return v, nil },
			grpc.ServerBefore(grpcx.ServerEndpointInjector("/google.example.library.v1.LibraryService/GetShelf")),
			grpc.ServerBefore(grpcx.ServerTransportInjector),
			grpc.ServerBefore(grpcx.IncomingMetadata),
		),
		listShelves: grpc.NewServer(
			endpoints.ListShelves(),
			func(_ context.Context, v any) (any, error) { return v, nil },
			func(_ context.Context, v any) (any, error) { return v, nil },
			grpc.ServerBefore(grpcx.ServerEndpointInjector("/google.example.library.v1.LibraryService/ListShelves")),
			grpc.ServerBefore(grpcx.ServerTransportInjector),
			grpc.ServerBefore(grpcx.IncomingMetadata),
		),
		deleteShelf: grpc.NewServer(
			endpoints.DeleteShelf(),
			func(_ context.Context, v any) (any, error) { return v, nil },
			func(_ context.Context, v any) (any, error) { return v, nil },
			grpc.ServerBefore(grpcx.ServerEndpointInjector("/google.example.library.v1.LibraryService/DeleteShelf")),
			grpc.ServerBefore(grpcx.ServerTransportInjector),
			grpc.ServerBefore(grpcx.IncomingMetadata),
		),
		mergeShelves: grpc.NewServer(
			endpoints.MergeShelves(),
			func(_ context.Context, v any) (any, error) { return v, nil },
			func(_ context.Context, v any) (any, error) { return v, nil },
			grpc.ServerBefore(grpcx.ServerEndpointInjector("/google.example.library.v1.LibraryService/MergeShelves")),
			grpc.ServerBefore(grpcx.ServerTransportInjector),
			grpc.ServerBefore(grpcx.IncomingMetadata),
		),
		createBook: grpc.NewServer(
			endpoints.CreateBook(),
			func(_ context.Context, v any) (any, error) { return v, nil },
			func(_ context.Context, v any) (any, error) { return v, nil },
			grpc.ServerBefore(grpcx.ServerEndpointInjector("/google.example.library.v1.LibraryService/CreateBook")),
			grpc.ServerBefore(grpcx.ServerTransportInjector),
			grpc.ServerBefore(grpcx.IncomingMetadata),
		),
		getBook: grpc.NewServer(
			endpoints.GetBook(),
			func(_ context.Context, v any) (any, error) { return v, nil },
			func(_ context.Context, v any) (any, error) { return v, nil },
			grpc.ServerBefore(grpcx.ServerEndpointInjector("/google.example.library.v1.LibraryService/GetBook")),
			grpc.ServerBefore(grpcx.ServerTransportInjector),
			grpc.ServerBefore(grpcx.IncomingMetadata),
		),
		listBooks: grpc.NewServer(
			endpoints.ListBooks(),
			func(_ context.Context, v any) (any, error) { return v, nil },
			func(_ context.Context, v any) (any, error) { return v, nil },
			grpc.ServerBefore(grpcx.ServerEndpointInjector("/google.example.library.v1.LibraryService/ListBooks")),
			grpc.ServerBefore(grpcx.ServerTransportInjector),
			grpc.ServerBefore(grpcx.IncomingMetadata),
		),
		deleteBook: grpc.NewServer(
			endpoints.DeleteBook(),
			func(_ context.Context, v any) (any, error) { return v, nil },
			func(_ context.Context, v any) (any, error) { return v, nil },
			grpc.ServerBefore(grpcx.ServerEndpointInjector("/google.example.library.v1.LibraryService/DeleteBook")),
			grpc.ServerBefore(grpcx.ServerTransportInjector),
			grpc.ServerBefore(grpcx.IncomingMetadata),
		),
		updateBook: grpc.NewServer(
			endpoints.UpdateBook(),
			func(_ context.Context, v any) (any, error) { return v, nil },
			func(_ context.Context, v any) (any, error) { return v, nil },
			grpc.ServerBefore(grpcx.ServerEndpointInjector("/google.example.library.v1.LibraryService/UpdateBook")),
			grpc.ServerBefore(grpcx.ServerTransportInjector),
			grpc.ServerBefore(grpcx.IncomingMetadata),
		),
		moveBook: grpc.NewServer(
			endpoints.MoveBook(),
			func(_ context.Context, v any) (any, error) { return v, nil },
			func(_ context.Context, v any) (any, error) { return v, nil },
			grpc.ServerBefore(grpcx.ServerEndpointInjector("/google.example.library.v1.LibraryService/MoveBook")),
			grpc.ServerBefore(grpcx.ServerTransportInjector),
			grpc.ServerBefore(grpcx.IncomingMetadata),
		),
	}
}

type libraryServiceGrpcServer struct {
	createShelf  *grpc.Server
	getShelf     *grpc.Server
	listShelves  *grpc.Server
	deleteShelf  *grpc.Server
	mergeShelves *grpc.Server
	createBook   *grpc.Server
	getBook      *grpc.Server
	listBooks    *grpc.Server
	deleteBook   *grpc.Server
	updateBook   *grpc.Server
	moveBook     *grpc.Server
}

func (s *libraryServiceGrpcServer) CreateShelf(ctx context.Context, request *CreateShelfRequest) (*Shelf, error) {
	ctx, rep, err := s.createShelf.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*Shelf), nil
}

func (s *libraryServiceGrpcServer) GetShelf(ctx context.Context, request *GetShelfRequest) (*Shelf, error) {
	ctx, rep, err := s.getShelf.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*Shelf), nil
}

func (s *libraryServiceGrpcServer) ListShelves(ctx context.Context, request *ListShelvesRequest) (*ListShelvesResponse, error) {
	ctx, rep, err := s.listShelves.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*ListShelvesResponse), nil
}

func (s *libraryServiceGrpcServer) DeleteShelf(ctx context.Context, request *DeleteShelfRequest) (*emptypb.Empty, error) {
	ctx, rep, err := s.deleteShelf.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*emptypb.Empty), nil
}

func (s *libraryServiceGrpcServer) MergeShelves(ctx context.Context, request *MergeShelvesRequest) (*Shelf, error) {
	ctx, rep, err := s.mergeShelves.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*Shelf), nil
}

func (s *libraryServiceGrpcServer) CreateBook(ctx context.Context, request *CreateBookRequest) (*Book, error) {
	ctx, rep, err := s.createBook.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*Book), nil
}

func (s *libraryServiceGrpcServer) GetBook(ctx context.Context, request *GetBookRequest) (*Book, error) {
	ctx, rep, err := s.getBook.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*Book), nil
}

func (s *libraryServiceGrpcServer) ListBooks(ctx context.Context, request *ListBooksRequest) (*ListBooksResponse, error) {
	ctx, rep, err := s.listBooks.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*ListBooksResponse), nil
}

func (s *libraryServiceGrpcServer) DeleteBook(ctx context.Context, request *DeleteBookRequest) (*emptypb.Empty, error) {
	ctx, rep, err := s.deleteBook.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*emptypb.Empty), nil
}

func (s *libraryServiceGrpcServer) UpdateBook(ctx context.Context, request *UpdateBookRequest) (*Book, error) {
	ctx, rep, err := s.updateBook.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*Book), nil
}

func (s *libraryServiceGrpcServer) MoveBook(ctx context.Context, request *MoveBookRequest) (*Book, error) {
	ctx, rep, err := s.moveBook.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*Book), nil
}

func NewLibraryServiceGrpcServer(transports LibraryServiceGrpcServerTransports) LibraryServiceService {
	return &libraryServiceGrpcServer{
		createShelf:  transports.CreateShelf(),
		getShelf:     transports.GetShelf(),
		listShelves:  transports.ListShelves(),
		deleteShelf:  transports.DeleteShelf(),
		mergeShelves: transports.MergeShelves(),
		createBook:   transports.CreateBook(),
		getBook:      transports.GetBook(),
		listBooks:    transports.ListBooks(),
		deleteBook:   transports.DeleteBook(),
		updateBook:   transports.UpdateBook(),
		moveBook:     transports.MoveBook(),
	}
}

// =========================== grpc client ===========================

type libraryServiceGrpcClientTransports struct {
	createShelf  transportx.Transport
	getShelf     transportx.Transport
	listShelves  transportx.Transport
	deleteShelf  transportx.Transport
	mergeShelves transportx.Transport
	createBook   transportx.Transport
	getBook      transportx.Transport
	listBooks    transportx.Transport
	deleteBook   transportx.Transport
	updateBook   transportx.Transport
	moveBook     transportx.Transport
}

func (t *libraryServiceGrpcClientTransports) CreateShelf() transportx.Transport {
	return t.createShelf
}

func (t *libraryServiceGrpcClientTransports) GetShelf() transportx.Transport {
	return t.getShelf
}

func (t *libraryServiceGrpcClientTransports) ListShelves() transportx.Transport {
	return t.listShelves
}

func (t *libraryServiceGrpcClientTransports) DeleteShelf() transportx.Transport {
	return t.deleteShelf
}

func (t *libraryServiceGrpcClientTransports) MergeShelves() transportx.Transport {
	return t.mergeShelves
}

func (t *libraryServiceGrpcClientTransports) CreateBook() transportx.Transport {
	return t.createBook
}

func (t *libraryServiceGrpcClientTransports) GetBook() transportx.Transport {
	return t.getBook
}

func (t *libraryServiceGrpcClientTransports) ListBooks() transportx.Transport {
	return t.listBooks
}

func (t *libraryServiceGrpcClientTransports) DeleteBook() transportx.Transport {
	return t.deleteBook
}

func (t *libraryServiceGrpcClientTransports) UpdateBook() transportx.Transport {
	return t.updateBook
}

func (t *libraryServiceGrpcClientTransports) MoveBook() transportx.Transport {
	return t.moveBook
}

func NewLibraryServiceGrpcClientTransports(conn *grpc1.ClientConn) LibraryServiceTransports {
	return &libraryServiceGrpcClientTransports{
		createShelf: grpc.NewClient(
			conn,
			"google.example.library.v1.LibraryService",
			"CreateShelf",
			func(_ context.Context, v any) (any, error) { return v, nil },
			func(_ context.Context, v any) (any, error) { return v, nil },
			Shelf{},
			grpc.ClientBefore(grpcx.OutgoingMetadata),
		),
		getShelf: grpc.NewClient(
			conn,
			"google.example.library.v1.LibraryService",
			"GetShelf",
			func(_ context.Context, v any) (any, error) { return v, nil },
			func(_ context.Context, v any) (any, error) { return v, nil },
			Shelf{},
			grpc.ClientBefore(grpcx.OutgoingMetadata),
		),
		listShelves: grpc.NewClient(
			conn,
			"google.example.library.v1.LibraryService",
			"ListShelves",
			func(_ context.Context, v any) (any, error) { return v, nil },
			func(_ context.Context, v any) (any, error) { return v, nil },
			ListShelvesResponse{},
			grpc.ClientBefore(grpcx.OutgoingMetadata),
		),
		deleteShelf: grpc.NewClient(
			conn,
			"google.example.library.v1.LibraryService",
			"DeleteShelf",
			func(_ context.Context, v any) (any, error) { return v, nil },
			func(_ context.Context, v any) (any, error) { return v, nil },
			emptypb.Empty{},
			grpc.ClientBefore(grpcx.OutgoingMetadata),
		),
		mergeShelves: grpc.NewClient(
			conn,
			"google.example.library.v1.LibraryService",
			"MergeShelves",
			func(_ context.Context, v any) (any, error) { return v, nil },
			func(_ context.Context, v any) (any, error) { return v, nil },
			Shelf{},
			grpc.ClientBefore(grpcx.OutgoingMetadata),
		),
		createBook: grpc.NewClient(
			conn,
			"google.example.library.v1.LibraryService",
			"CreateBook",
			func(_ context.Context, v any) (any, error) { return v, nil },
			func(_ context.Context, v any) (any, error) { return v, nil },
			Book{},
			grpc.ClientBefore(grpcx.OutgoingMetadata),
		),
		getBook: grpc.NewClient(
			conn,
			"google.example.library.v1.LibraryService",
			"GetBook",
			func(_ context.Context, v any) (any, error) { return v, nil },
			func(_ context.Context, v any) (any, error) { return v, nil },
			Book{},
			grpc.ClientBefore(grpcx.OutgoingMetadata),
		),
		listBooks: grpc.NewClient(
			conn,
			"google.example.library.v1.LibraryService",
			"ListBooks",
			func(_ context.Context, v any) (any, error) { return v, nil },
			func(_ context.Context, v any) (any, error) { return v, nil },
			ListBooksResponse{},
			grpc.ClientBefore(grpcx.OutgoingMetadata),
		),
		deleteBook: grpc.NewClient(
			conn,
			"google.example.library.v1.LibraryService",
			"DeleteBook",
			func(_ context.Context, v any) (any, error) { return v, nil },
			func(_ context.Context, v any) (any, error) { return v, nil },
			emptypb.Empty{},
			grpc.ClientBefore(grpcx.OutgoingMetadata),
		),
		updateBook: grpc.NewClient(
			conn,
			"google.example.library.v1.LibraryService",
			"UpdateBook",
			func(_ context.Context, v any) (any, error) { return v, nil },
			func(_ context.Context, v any) (any, error) { return v, nil },
			Book{},
			grpc.ClientBefore(grpcx.OutgoingMetadata),
		),
		moveBook: grpc.NewClient(
			conn,
			"google.example.library.v1.LibraryService",
			"MoveBook",
			func(_ context.Context, v any) (any, error) { return v, nil },
			func(_ context.Context, v any) (any, error) { return v, nil },
			Book{},
			grpc.ClientBefore(grpcx.OutgoingMetadata),
		),
	}
}

type libraryServiceGrpcClientEndpoints struct {
	transports  LibraryServiceTransports
	middlewares []endpoint.Middleware
}

func (e *libraryServiceGrpcClientEndpoints) CreateShelf() endpoint.Endpoint {
	return endpointx.Chain(e.transports.CreateShelf().Endpoint(), e.middlewares...)
}

func (e *libraryServiceGrpcClientEndpoints) GetShelf() endpoint.Endpoint {
	return endpointx.Chain(e.transports.GetShelf().Endpoint(), e.middlewares...)
}

func (e *libraryServiceGrpcClientEndpoints) ListShelves() endpoint.Endpoint {
	return endpointx.Chain(e.transports.ListShelves().Endpoint(), e.middlewares...)
}

func (e *libraryServiceGrpcClientEndpoints) DeleteShelf() endpoint.Endpoint {
	return endpointx.Chain(e.transports.DeleteShelf().Endpoint(), e.middlewares...)
}

func (e *libraryServiceGrpcClientEndpoints) MergeShelves() endpoint.Endpoint {
	return endpointx.Chain(e.transports.MergeShelves().Endpoint(), e.middlewares...)
}

func (e *libraryServiceGrpcClientEndpoints) CreateBook() endpoint.Endpoint {
	return endpointx.Chain(e.transports.CreateBook().Endpoint(), e.middlewares...)
}

func (e *libraryServiceGrpcClientEndpoints) GetBook() endpoint.Endpoint {
	return endpointx.Chain(e.transports.GetBook().Endpoint(), e.middlewares...)
}

func (e *libraryServiceGrpcClientEndpoints) ListBooks() endpoint.Endpoint {
	return endpointx.Chain(e.transports.ListBooks().Endpoint(), e.middlewares...)
}

func (e *libraryServiceGrpcClientEndpoints) DeleteBook() endpoint.Endpoint {
	return endpointx.Chain(e.transports.DeleteBook().Endpoint(), e.middlewares...)
}

func (e *libraryServiceGrpcClientEndpoints) UpdateBook() endpoint.Endpoint {
	return endpointx.Chain(e.transports.UpdateBook().Endpoint(), e.middlewares...)
}

func (e *libraryServiceGrpcClientEndpoints) MoveBook() endpoint.Endpoint {
	return endpointx.Chain(e.transports.MoveBook().Endpoint(), e.middlewares...)
}

func NewLibraryServiceGrpcClientEndpoints(transports LibraryServiceTransports, middlewares ...endpoint.Middleware) LibraryServiceEndpoints {
	return &libraryServiceGrpcClientEndpoints{transports: transports, middlewares: middlewares}
}

type libraryServiceGrpcClient struct {
	createShelf  endpoint.Endpoint
	getShelf     endpoint.Endpoint
	listShelves  endpoint.Endpoint
	deleteShelf  endpoint.Endpoint
	mergeShelves endpoint.Endpoint
	createBook   endpoint.Endpoint
	getBook      endpoint.Endpoint
	listBooks    endpoint.Endpoint
	deleteBook   endpoint.Endpoint
	updateBook   endpoint.Endpoint
	moveBook     endpoint.Endpoint
}

func (c *libraryServiceGrpcClient) CreateShelf(ctx context.Context, request *CreateShelfRequest) (*Shelf, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/CreateShelf")
	ctx = transportx.InjectName(ctx, grpcx.GrpcClient)
	rep, err := c.createShelf(ctx, request)
	if err != nil {
		return nil, statusx.FromGrpcError(err)
	}
	return rep.(*Shelf), nil
}

func (c *libraryServiceGrpcClient) GetShelf(ctx context.Context, request *GetShelfRequest) (*Shelf, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/GetShelf")
	ctx = transportx.InjectName(ctx, grpcx.GrpcClient)
	rep, err := c.getShelf(ctx, request)
	if err != nil {
		return nil, statusx.FromGrpcError(err)
	}
	return rep.(*Shelf), nil
}

func (c *libraryServiceGrpcClient) ListShelves(ctx context.Context, request *ListShelvesRequest) (*ListShelvesResponse, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/ListShelves")
	ctx = transportx.InjectName(ctx, grpcx.GrpcClient)
	rep, err := c.listShelves(ctx, request)
	if err != nil {
		return nil, statusx.FromGrpcError(err)
	}
	return rep.(*ListShelvesResponse), nil
}

func (c *libraryServiceGrpcClient) DeleteShelf(ctx context.Context, request *DeleteShelfRequest) (*emptypb.Empty, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/DeleteShelf")
	ctx = transportx.InjectName(ctx, grpcx.GrpcClient)
	rep, err := c.deleteShelf(ctx, request)
	if err != nil {
		return nil, statusx.FromGrpcError(err)
	}
	return rep.(*emptypb.Empty), nil
}

func (c *libraryServiceGrpcClient) MergeShelves(ctx context.Context, request *MergeShelvesRequest) (*Shelf, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/MergeShelves")
	ctx = transportx.InjectName(ctx, grpcx.GrpcClient)
	rep, err := c.mergeShelves(ctx, request)
	if err != nil {
		return nil, statusx.FromGrpcError(err)
	}
	return rep.(*Shelf), nil
}

func (c *libraryServiceGrpcClient) CreateBook(ctx context.Context, request *CreateBookRequest) (*Book, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/CreateBook")
	ctx = transportx.InjectName(ctx, grpcx.GrpcClient)
	rep, err := c.createBook(ctx, request)
	if err != nil {
		return nil, statusx.FromGrpcError(err)
	}
	return rep.(*Book), nil
}

func (c *libraryServiceGrpcClient) GetBook(ctx context.Context, request *GetBookRequest) (*Book, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/GetBook")
	ctx = transportx.InjectName(ctx, grpcx.GrpcClient)
	rep, err := c.getBook(ctx, request)
	if err != nil {
		return nil, statusx.FromGrpcError(err)
	}
	return rep.(*Book), nil
}

func (c *libraryServiceGrpcClient) ListBooks(ctx context.Context, request *ListBooksRequest) (*ListBooksResponse, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/ListBooks")
	ctx = transportx.InjectName(ctx, grpcx.GrpcClient)
	rep, err := c.listBooks(ctx, request)
	if err != nil {
		return nil, statusx.FromGrpcError(err)
	}
	return rep.(*ListBooksResponse), nil
}

func (c *libraryServiceGrpcClient) DeleteBook(ctx context.Context, request *DeleteBookRequest) (*emptypb.Empty, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/DeleteBook")
	ctx = transportx.InjectName(ctx, grpcx.GrpcClient)
	rep, err := c.deleteBook(ctx, request)
	if err != nil {
		return nil, statusx.FromGrpcError(err)
	}
	return rep.(*emptypb.Empty), nil
}

func (c *libraryServiceGrpcClient) UpdateBook(ctx context.Context, request *UpdateBookRequest) (*Book, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/UpdateBook")
	ctx = transportx.InjectName(ctx, grpcx.GrpcClient)
	rep, err := c.updateBook(ctx, request)
	if err != nil {
		return nil, statusx.FromGrpcError(err)
	}
	return rep.(*Book), nil
}

func (c *libraryServiceGrpcClient) MoveBook(ctx context.Context, request *MoveBookRequest) (*Book, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/MoveBook")
	ctx = transportx.InjectName(ctx, grpcx.GrpcClient)
	rep, err := c.moveBook(ctx, request)
	if err != nil {
		return nil, statusx.FromGrpcError(err)
	}
	return rep.(*Book), nil
}

func NewLibraryServiceGrpcClient(endpoints LibraryServiceEndpoints) LibraryServiceService {
	return &libraryServiceGrpcClient{
		createShelf:  endpoints.CreateShelf(),
		getShelf:     endpoints.GetShelf(),
		listShelves:  endpoints.ListShelves(),
		deleteShelf:  endpoints.DeleteShelf(),
		mergeShelves: endpoints.MergeShelves(),
		createBook:   endpoints.CreateBook(),
		getBook:      endpoints.GetBook(),
		listBooks:    endpoints.ListBooks(),
		deleteBook:   endpoints.DeleteBook(),
		updateBook:   endpoints.UpdateBook(),
		moveBook:     endpoints.MoveBook(),
	}
}

type libraryServiceGrpcClientFactories struct {
	opts []grpc1.DialOption
}

func (f *libraryServiceGrpcClientFactories) CreateShelf(middlewares ...endpoint.Middleware) sd.Factory {
	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
		conn, err := grpc1.NewClient(instance, f.opts...)
		if err != nil {
			return nil, nil, err
		}
		transports := NewLibraryServiceGrpcClientTransports(conn)
		endpoints := NewLibraryServiceGrpcClientEndpoints(transports, middlewares...)
		return endpoints.CreateShelf(), conn, nil
	}
}

func (f *libraryServiceGrpcClientFactories) GetShelf(middlewares ...endpoint.Middleware) sd.Factory {
	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
		conn, err := grpc1.NewClient(instance, f.opts...)
		if err != nil {
			return nil, nil, err
		}
		transports := NewLibraryServiceGrpcClientTransports(conn)
		endpoints := NewLibraryServiceGrpcClientEndpoints(transports, middlewares...)
		return endpoints.GetShelf(), conn, nil
	}
}

func (f *libraryServiceGrpcClientFactories) ListShelves(middlewares ...endpoint.Middleware) sd.Factory {
	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
		conn, err := grpc1.NewClient(instance, f.opts...)
		if err != nil {
			return nil, nil, err
		}
		transports := NewLibraryServiceGrpcClientTransports(conn)
		endpoints := NewLibraryServiceGrpcClientEndpoints(transports, middlewares...)
		return endpoints.ListShelves(), conn, nil
	}
}

func (f *libraryServiceGrpcClientFactories) DeleteShelf(middlewares ...endpoint.Middleware) sd.Factory {
	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
		conn, err := grpc1.NewClient(instance, f.opts...)
		if err != nil {
			return nil, nil, err
		}
		transports := NewLibraryServiceGrpcClientTransports(conn)
		endpoints := NewLibraryServiceGrpcClientEndpoints(transports, middlewares...)
		return endpoints.DeleteShelf(), conn, nil
	}
}

func (f *libraryServiceGrpcClientFactories) MergeShelves(middlewares ...endpoint.Middleware) sd.Factory {
	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
		conn, err := grpc1.NewClient(instance, f.opts...)
		if err != nil {
			return nil, nil, err
		}
		transports := NewLibraryServiceGrpcClientTransports(conn)
		endpoints := NewLibraryServiceGrpcClientEndpoints(transports, middlewares...)
		return endpoints.MergeShelves(), conn, nil
	}
}

func (f *libraryServiceGrpcClientFactories) CreateBook(middlewares ...endpoint.Middleware) sd.Factory {
	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
		conn, err := grpc1.NewClient(instance, f.opts...)
		if err != nil {
			return nil, nil, err
		}
		transports := NewLibraryServiceGrpcClientTransports(conn)
		endpoints := NewLibraryServiceGrpcClientEndpoints(transports, middlewares...)
		return endpoints.CreateBook(), conn, nil
	}
}

func (f *libraryServiceGrpcClientFactories) GetBook(middlewares ...endpoint.Middleware) sd.Factory {
	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
		conn, err := grpc1.NewClient(instance, f.opts...)
		if err != nil {
			return nil, nil, err
		}
		transports := NewLibraryServiceGrpcClientTransports(conn)
		endpoints := NewLibraryServiceGrpcClientEndpoints(transports, middlewares...)
		return endpoints.GetBook(), conn, nil
	}
}

func (f *libraryServiceGrpcClientFactories) ListBooks(middlewares ...endpoint.Middleware) sd.Factory {
	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
		conn, err := grpc1.NewClient(instance, f.opts...)
		if err != nil {
			return nil, nil, err
		}
		transports := NewLibraryServiceGrpcClientTransports(conn)
		endpoints := NewLibraryServiceGrpcClientEndpoints(transports, middlewares...)
		return endpoints.ListBooks(), conn, nil
	}
}

func (f *libraryServiceGrpcClientFactories) DeleteBook(middlewares ...endpoint.Middleware) sd.Factory {
	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
		conn, err := grpc1.NewClient(instance, f.opts...)
		if err != nil {
			return nil, nil, err
		}
		transports := NewLibraryServiceGrpcClientTransports(conn)
		endpoints := NewLibraryServiceGrpcClientEndpoints(transports, middlewares...)
		return endpoints.DeleteBook(), conn, nil
	}
}

func (f *libraryServiceGrpcClientFactories) UpdateBook(middlewares ...endpoint.Middleware) sd.Factory {
	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
		conn, err := grpc1.NewClient(instance, f.opts...)
		if err != nil {
			return nil, nil, err
		}
		transports := NewLibraryServiceGrpcClientTransports(conn)
		endpoints := NewLibraryServiceGrpcClientEndpoints(transports, middlewares...)
		return endpoints.UpdateBook(), conn, nil
	}
}

func (f *libraryServiceGrpcClientFactories) MoveBook(middlewares ...endpoint.Middleware) sd.Factory {
	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
		conn, err := grpc1.NewClient(instance, f.opts...)
		if err != nil {
			return nil, nil, err
		}
		transports := NewLibraryServiceGrpcClientTransports(conn)
		endpoints := NewLibraryServiceGrpcClientEndpoints(transports, middlewares...)
		return endpoints.MoveBook(), conn, nil
	}
}

func NewLibraryServiceGrpcClientFactories(opts ...grpc1.DialOption) LibraryServiceFactories {
	return &libraryServiceGrpcClientFactories{opts: opts}
}

// =========================== http server ===========================

type LibraryServiceHttpServerTransports interface {
	CreateShelf() *http.Server
	GetShelf() *http.Server
	ListShelves() *http.Server
	DeleteShelf() *http.Server
	MergeShelves() *http.Server
	CreateBook() *http.Server
	GetBook() *http.Server
	ListBooks() *http.Server
	DeleteBook() *http.Server
	UpdateBook() *http.Server
	MoveBook() *http.Server
}

type libraryServiceHttpServerTransports struct {
	createShelf  *http.Server
	getShelf     *http.Server
	listShelves  *http.Server
	deleteShelf  *http.Server
	mergeShelves *http.Server
	createBook   *http.Server
	getBook      *http.Server
	listBooks    *http.Server
	deleteBook   *http.Server
	updateBook   *http.Server
	moveBook     *http.Server
}

func (t *libraryServiceHttpServerTransports) CreateShelf() *http.Server {
	return t.createShelf
}

func (t *libraryServiceHttpServerTransports) GetShelf() *http.Server {
	return t.getShelf
}

func (t *libraryServiceHttpServerTransports) ListShelves() *http.Server {
	return t.listShelves
}

func (t *libraryServiceHttpServerTransports) DeleteShelf() *http.Server {
	return t.deleteShelf
}

func (t *libraryServiceHttpServerTransports) MergeShelves() *http.Server {
	return t.mergeShelves
}

func (t *libraryServiceHttpServerTransports) CreateBook() *http.Server {
	return t.createBook
}

func (t *libraryServiceHttpServerTransports) GetBook() *http.Server {
	return t.getBook
}

func (t *libraryServiceHttpServerTransports) ListBooks() *http.Server {
	return t.listBooks
}

func (t *libraryServiceHttpServerTransports) DeleteBook() *http.Server {
	return t.deleteBook
}

func (t *libraryServiceHttpServerTransports) UpdateBook() *http.Server {
	return t.updateBook
}

func (t *libraryServiceHttpServerTransports) MoveBook() *http.Server {
	return t.moveBook
}

func NewLibraryServiceHttpServerTransports(endpoints LibraryServiceEndpoints) LibraryServiceHttpServerTransports {
	return &libraryServiceHttpServerTransports{
		createShelf: http.NewServer(
			endpoints.CreateShelf(),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &CreateShelfRequest{}
				if err := jsonx.NewDecoder(r.Body).Decode(&req.Shelf); err != nil {
					return nil, err
				}
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*Shelf)
				w.Header().Set("Content-Type", "application/json; charset=utf-8")
				w.WriteHeader(http1.StatusOK)
				if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
					return err
				}
				return nil
			},
			http.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/CreateShelf")),
			http.ServerBefore(httpx.TransportInjector(httpx.HttpServer)),
			http.ServerBefore(httpx.IncomingMetadata),
			http.ServerErrorEncoder(httpx.ErrorEncoder),
		),
		getShelf: http.NewServer(
			endpoints.GetShelf(),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &GetShelfRequest{}
				vars := urlx.FormFromMap(mux.Vars(r))
				var varErr error
				req.Name = fmt.Sprintf("shelves/%s", vars.Get("shelf"))
				if varErr != nil {
					return nil, varErr
				}
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*Shelf)
				w.Header().Set("Content-Type", "application/json; charset=utf-8")
				w.WriteHeader(http1.StatusOK)
				if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
					return err
				}
				return nil
			},
			http.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/GetShelf")),
			http.ServerBefore(httpx.TransportInjector(httpx.HttpServer)),
			http.ServerBefore(httpx.IncomingMetadata),
			http.ServerErrorEncoder(httpx.ErrorEncoder),
		),
		listShelves: http.NewServer(
			endpoints.ListShelves(),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &ListShelvesRequest{}
				queries := r.URL.Query()
				var queryErr error
				req.PageSize, queryErr = errorx.Break[int32](queryErr)(urlx.GetInt[int32](queries, "page_size"))
				req.PageToken = queries.Get("page_token")
				if queryErr != nil {
					return nil, queryErr
				}
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*ListShelvesResponse)
				w.Header().Set("Content-Type", "application/json; charset=utf-8")
				w.WriteHeader(http1.StatusOK)
				if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
					return err
				}
				return nil
			},
			http.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/ListShelves")),
			http.ServerBefore(httpx.TransportInjector(httpx.HttpServer)),
			http.ServerBefore(httpx.IncomingMetadata),
			http.ServerErrorEncoder(httpx.ErrorEncoder),
		),
		deleteShelf: http.NewServer(
			endpoints.DeleteShelf(),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &DeleteShelfRequest{}
				vars := urlx.FormFromMap(mux.Vars(r))
				var varErr error
				req.Name = fmt.Sprintf("shelves/%s", vars.Get("shelf"))
				if varErr != nil {
					return nil, varErr
				}
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*emptypb.Empty)
				w.Header().Set("Content-Type", "application/json; charset=utf-8")
				w.WriteHeader(http1.StatusOK)
				if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
					return err
				}
				return nil
			},
			http.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/DeleteShelf")),
			http.ServerBefore(httpx.TransportInjector(httpx.HttpServer)),
			http.ServerBefore(httpx.IncomingMetadata),
			http.ServerErrorEncoder(httpx.ErrorEncoder),
		),
		mergeShelves: http.NewServer(
			endpoints.MergeShelves(),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &MergeShelvesRequest{}
				if err := jsonx.NewDecoder(r.Body).Decode(req); err != nil {
					return nil, err
				}
				vars := urlx.FormFromMap(mux.Vars(r))
				var varErr error
				req.Name = fmt.Sprintf("shelves/%s", vars.Get("shelf"))
				if varErr != nil {
					return nil, varErr
				}
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*Shelf)
				w.Header().Set("Content-Type", "application/json; charset=utf-8")
				w.WriteHeader(http1.StatusOK)
				if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
					return err
				}
				return nil
			},
			http.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/MergeShelves")),
			http.ServerBefore(httpx.TransportInjector(httpx.HttpServer)),
			http.ServerBefore(httpx.IncomingMetadata),
			http.ServerErrorEncoder(httpx.ErrorEncoder),
		),
		createBook: http.NewServer(
			endpoints.CreateBook(),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &CreateBookRequest{}
				if err := jsonx.NewDecoder(r.Body).Decode(&req.Book); err != nil {
					return nil, err
				}
				vars := urlx.FormFromMap(mux.Vars(r))
				var varErr error
				req.Parent = fmt.Sprintf("shelves/%s", vars.Get("shelf"))
				if varErr != nil {
					return nil, varErr
				}
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*Book)
				w.Header().Set("Content-Type", "application/json; charset=utf-8")
				w.WriteHeader(http1.StatusOK)
				if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
					return err
				}
				return nil
			},
			http.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/CreateBook")),
			http.ServerBefore(httpx.TransportInjector(httpx.HttpServer)),
			http.ServerBefore(httpx.IncomingMetadata),
			http.ServerErrorEncoder(httpx.ErrorEncoder),
		),
		getBook: http.NewServer(
			endpoints.GetBook(),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &GetBookRequest{}
				vars := urlx.FormFromMap(mux.Vars(r))
				var varErr error
				req.Name = fmt.Sprintf("shelves/%s/books/%s", vars.Get("shelf"), vars.Get("book"))
				if varErr != nil {
					return nil, varErr
				}
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*Book)
				w.Header().Set("Content-Type", "application/json; charset=utf-8")
				w.WriteHeader(http1.StatusOK)
				if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
					return err
				}
				return nil
			},
			http.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/GetBook")),
			http.ServerBefore(httpx.TransportInjector(httpx.HttpServer)),
			http.ServerBefore(httpx.IncomingMetadata),
			http.ServerErrorEncoder(httpx.ErrorEncoder),
		),
		listBooks: http.NewServer(
			endpoints.ListBooks(),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &ListBooksRequest{}
				vars := urlx.FormFromMap(mux.Vars(r))
				var varErr error
				req.Parent = fmt.Sprintf("shelves/%s", vars.Get("shelf"))
				if varErr != nil {
					return nil, varErr
				}
				queries := r.URL.Query()
				var queryErr error
				req.PageSize, queryErr = errorx.Break[int32](queryErr)(urlx.GetInt[int32](queries, "page_size"))
				req.PageToken = queries.Get("page_token")
				if queryErr != nil {
					return nil, queryErr
				}
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*ListBooksResponse)
				w.Header().Set("Content-Type", "application/json; charset=utf-8")
				w.WriteHeader(http1.StatusOK)
				if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
					return err
				}
				return nil
			},
			http.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/ListBooks")),
			http.ServerBefore(httpx.TransportInjector(httpx.HttpServer)),
			http.ServerBefore(httpx.IncomingMetadata),
			http.ServerErrorEncoder(httpx.ErrorEncoder),
		),
		deleteBook: http.NewServer(
			endpoints.DeleteBook(),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &DeleteBookRequest{}
				vars := urlx.FormFromMap(mux.Vars(r))
				var varErr error
				req.Name = fmt.Sprintf("shelves/%s/books/%s", vars.Get("shelf"), vars.Get("book"))
				if varErr != nil {
					return nil, varErr
				}
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*emptypb.Empty)
				w.Header().Set("Content-Type", "application/json; charset=utf-8")
				w.WriteHeader(http1.StatusOK)
				if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
					return err
				}
				return nil
			},
			http.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/DeleteBook")),
			http.ServerBefore(httpx.TransportInjector(httpx.HttpServer)),
			http.ServerBefore(httpx.IncomingMetadata),
			http.ServerErrorEncoder(httpx.ErrorEncoder),
		),
		updateBook: http.NewServer(
			endpoints.UpdateBook(),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &UpdateBookRequest{}
				if err := jsonx.NewDecoder(r.Body).Decode(&req.Book); err != nil {
					return nil, err
				}
				vars := urlx.FormFromMap(mux.Vars(r))
				var varErr error
				if req.Book == nil {
					req.Book = &Book{}
				}
				req.Book.Name = fmt.Sprintf("shelves/%s/books/%s", vars.Get("shelf"), vars.Get("book"))
				if varErr != nil {
					return nil, varErr
				}
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*Book)
				w.Header().Set("Content-Type", "application/json; charset=utf-8")
				w.WriteHeader(http1.StatusOK)
				if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
					return err
				}
				return nil
			},
			http.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/UpdateBook")),
			http.ServerBefore(httpx.TransportInjector(httpx.HttpServer)),
			http.ServerBefore(httpx.IncomingMetadata),
			http.ServerErrorEncoder(httpx.ErrorEncoder),
		),
		moveBook: http.NewServer(
			endpoints.MoveBook(),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &MoveBookRequest{}
				if err := jsonx.NewDecoder(r.Body).Decode(req); err != nil {
					return nil, err
				}
				vars := urlx.FormFromMap(mux.Vars(r))
				var varErr error
				req.Name = fmt.Sprintf("shelves/%s/books/%s", vars.Get("shelf"), vars.Get("book"))
				if varErr != nil {
					return nil, varErr
				}
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*Book)
				w.Header().Set("Content-Type", "application/json; charset=utf-8")
				w.WriteHeader(http1.StatusOK)
				if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
					return err
				}
				return nil
			},
			http.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/MoveBook")),
			http.ServerBefore(httpx.TransportInjector(httpx.HttpServer)),
			http.ServerBefore(httpx.IncomingMetadata),
			http.ServerErrorEncoder(httpx.ErrorEncoder),
		),
	}
}

func NewLibraryServiceHttpServerHandler(endpoints LibraryServiceHttpServerTransports) http1.Handler {
	router := mux.NewRouter()
	router.NewRoute().Name("/google.example.library.v1.LibraryService/CreateShelf").Methods("POST").Path("/v1/shelves").Handler(endpoints.CreateShelf())
	router.NewRoute().Name("/google.example.library.v1.LibraryService/GetShelf").Methods("GET").Path("/v1/shelves/{shelf}").Handler(endpoints.GetShelf())
	router.NewRoute().Name("/google.example.library.v1.LibraryService/ListShelves").Methods("GET").Path("/v1/shelves").Handler(endpoints.ListShelves())
	router.NewRoute().Name("/google.example.library.v1.LibraryService/DeleteShelf").Methods("DELETE").Path("/v1/shelves/{shelf}").Handler(endpoints.DeleteShelf())
	router.NewRoute().Name("/google.example.library.v1.LibraryService/MergeShelves").Methods("POST").Path("/v1/shelves/{shelf}:merge").Handler(endpoints.MergeShelves())
	router.NewRoute().Name("/google.example.library.v1.LibraryService/CreateBook").Methods("POST").Path("/v1/shelves/{shelf}/books").Handler(endpoints.CreateBook())
	router.NewRoute().Name("/google.example.library.v1.LibraryService/GetBook").Methods("GET").Path("/v1/shelves/{shelf}/books/{book}").Handler(endpoints.GetBook())
	router.NewRoute().Name("/google.example.library.v1.LibraryService/ListBooks").Methods("GET").Path("/v1/shelves/{shelf}/books").Handler(endpoints.ListBooks())
	router.NewRoute().Name("/google.example.library.v1.LibraryService/DeleteBook").Methods("DELETE").Path("/v1/shelves/{shelf}/books/{book}").Handler(endpoints.DeleteBook())
	router.NewRoute().Name("/google.example.library.v1.LibraryService/UpdateBook").Methods("PATCH").Path("/v1/shelves/{shelf}/books/{book}").Handler(endpoints.UpdateBook())
	router.NewRoute().Name("/google.example.library.v1.LibraryService/MoveBook").Methods("POST").Path("/v1/shelves/{shelf}/books/{book}:move").Handler(endpoints.MoveBook())
	return router
}

// =========================== http client ===========================

type libraryServiceHttpClientTransports struct {
	createShelf  transportx.Transport
	getShelf     transportx.Transport
	listShelves  transportx.Transport
	deleteShelf  transportx.Transport
	mergeShelves transportx.Transport
	createBook   transportx.Transport
	getBook      transportx.Transport
	listBooks    transportx.Transport
	deleteBook   transportx.Transport
	updateBook   transportx.Transport
	moveBook     transportx.Transport
}

func (t *libraryServiceHttpClientTransports) CreateShelf() transportx.Transport {
	return t.createShelf
}

func (t *libraryServiceHttpClientTransports) GetShelf() transportx.Transport {
	return t.getShelf
}

func (t *libraryServiceHttpClientTransports) ListShelves() transportx.Transport {
	return t.listShelves
}

func (t *libraryServiceHttpClientTransports) DeleteShelf() transportx.Transport {
	return t.deleteShelf
}

func (t *libraryServiceHttpClientTransports) MergeShelves() transportx.Transport {
	return t.mergeShelves
}

func (t *libraryServiceHttpClientTransports) CreateBook() transportx.Transport {
	return t.createBook
}

func (t *libraryServiceHttpClientTransports) GetBook() transportx.Transport {
	return t.getBook
}

func (t *libraryServiceHttpClientTransports) ListBooks() transportx.Transport {
	return t.listBooks
}

func (t *libraryServiceHttpClientTransports) DeleteBook() transportx.Transport {
	return t.deleteBook
}

func (t *libraryServiceHttpClientTransports) UpdateBook() transportx.Transport {
	return t.updateBook
}

func (t *libraryServiceHttpClientTransports) MoveBook() transportx.Transport {
	return t.moveBook
}

func NewLibraryServiceHttpClientTransports(scheme string, instance string) LibraryServiceTransports {
	router := mux.NewRouter()
	router.NewRoute().Name("/google.example.library.v1.LibraryService/CreateShelf").Methods("POST").Path("/v1/shelves")
	router.NewRoute().Name("/google.example.library.v1.LibraryService/GetShelf").Methods("GET").Path("/v1/shelves/{shelf}")
	router.NewRoute().Name("/google.example.library.v1.LibraryService/ListShelves").Methods("GET").Path("/v1/shelves")
	router.NewRoute().Name("/google.example.library.v1.LibraryService/DeleteShelf").Methods("DELETE").Path("/v1/shelves/{shelf}")
	router.NewRoute().Name("/google.example.library.v1.LibraryService/MergeShelves").Methods("POST").Path("/v1/shelves/{shelf}:merge")
	router.NewRoute().Name("/google.example.library.v1.LibraryService/CreateBook").Methods("POST").Path("/v1/shelves/{shelf}/books")
	router.NewRoute().Name("/google.example.library.v1.LibraryService/GetBook").Methods("GET").Path("/v1/shelves/{shelf}/books/{book}")
	router.NewRoute().Name("/google.example.library.v1.LibraryService/ListBooks").Methods("GET").Path("/v1/shelves/{shelf}/books")
	router.NewRoute().Name("/google.example.library.v1.LibraryService/DeleteBook").Methods("DELETE").Path("/v1/shelves/{shelf}/books/{book}")
	router.NewRoute().Name("/google.example.library.v1.LibraryService/UpdateBook").Methods("PATCH").Path("/v1/shelves/{shelf}/books/{book}")
	router.NewRoute().Name("/google.example.library.v1.LibraryService/MoveBook").Methods("POST").Path("/v1/shelves/{shelf}/books/{book}:move")
	return &libraryServiceHttpClientTransports{
		createShelf: http.NewExplicitClient(
			func(ctx context.Context, obj any) (*http1.Request, error) {
				if obj == nil {
					return nil, errors.New("request object is nil")
				}
				req, ok := obj.(*CreateShelfRequest)
				if !ok {
					return nil, fmt.Errorf("invalid request object type, %T", obj)
				}
				_ = req
				var body io.Reader
				var bodyBuf bytes.Buffer
				if err := jsonx.NewEncoder(&bodyBuf).Encode(req.GetShelf()); err != nil {
					return nil, err
				}
				body = &bodyBuf
				contentType := "application/json; charset=utf-8"
				var pairs []string
				path, err := router.Get("/google.example.library.v1.LibraryService/CreateShelf").URLPath(pairs...)
				if err != nil {
					return nil, err
				}
				queries := url.Values{}
				target := &url.URL{
					Scheme:   scheme,
					Host:     instance,
					Path:     path.Path,
					RawQuery: queries.Encode(),
				}
				r, err := http1.NewRequestWithContext(ctx, "POST", target.String(), body)
				if err != nil {
					return nil, err
				}
				r.Header.Set("Content-Type", contentType)
				return r, nil
			},
			func(ctx context.Context, r *http1.Response) (any, error) {
				if httpx.IsErrorResponse(r) {
					return nil, httpx.ErrorDecoder(ctx, r)
				}
				resp := &Shelf{}
				if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
					return nil, err
				}
				return resp, nil
			},
			http.ClientBefore(httpx.OutgoingMetadata),
		),
		getShelf: http.NewExplicitClient(
			func(ctx context.Context, obj any) (*http1.Request, error) {
				if obj == nil {
					return nil, errors.New("request object is nil")
				}
				req, ok := obj.(*GetShelfRequest)
				if !ok {
					return nil, fmt.Errorf("invalid request object type, %T", obj)
				}
				_ = req
				var body io.Reader
				var pairs []string
				namedPathParameter := req.GetName()
				namedPathValues := strings.Split(namedPathParameter, "/")
				if len(namedPathValues) != 2 {
					return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
				}
				pairs = append(pairs, "shelf", namedPathValues[1])
				path, err := router.Get("/google.example.library.v1.LibraryService/GetShelf").URLPath(pairs...)
				if err != nil {
					return nil, err
				}
				queries := url.Values{}
				target := &url.URL{
					Scheme:   scheme,
					Host:     instance,
					Path:     path.Path,
					RawQuery: queries.Encode(),
				}
				r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
				if err != nil {
					return nil, err
				}
				return r, nil
			},
			func(ctx context.Context, r *http1.Response) (any, error) {
				if httpx.IsErrorResponse(r) {
					return nil, httpx.ErrorDecoder(ctx, r)
				}
				resp := &Shelf{}
				if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
					return nil, err
				}
				return resp, nil
			},
			http.ClientBefore(httpx.OutgoingMetadata),
		),
		listShelves: http.NewExplicitClient(
			func(ctx context.Context, obj any) (*http1.Request, error) {
				if obj == nil {
					return nil, errors.New("request object is nil")
				}
				req, ok := obj.(*ListShelvesRequest)
				if !ok {
					return nil, fmt.Errorf("invalid request object type, %T", obj)
				}
				_ = req
				var body io.Reader
				var pairs []string
				path, err := router.Get("/google.example.library.v1.LibraryService/ListShelves").URLPath(pairs...)
				if err != nil {
					return nil, err
				}
				queries := url.Values{}
				queries["page_size"] = append(queries["page_size"], strconvx.FormatInt(req.GetPageSize(), 10))
				queries["page_token"] = append(queries["page_token"], req.GetPageToken())
				target := &url.URL{
					Scheme:   scheme,
					Host:     instance,
					Path:     path.Path,
					RawQuery: queries.Encode(),
				}
				r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
				if err != nil {
					return nil, err
				}
				return r, nil
			},
			func(ctx context.Context, r *http1.Response) (any, error) {
				if httpx.IsErrorResponse(r) {
					return nil, httpx.ErrorDecoder(ctx, r)
				}
				resp := &ListShelvesResponse{}
				if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
					return nil, err
				}
				return resp, nil
			},
			http.ClientBefore(httpx.OutgoingMetadata),
		),
		deleteShelf: http.NewExplicitClient(
			func(ctx context.Context, obj any) (*http1.Request, error) {
				if obj == nil {
					return nil, errors.New("request object is nil")
				}
				req, ok := obj.(*DeleteShelfRequest)
				if !ok {
					return nil, fmt.Errorf("invalid request object type, %T", obj)
				}
				_ = req
				var body io.Reader
				var pairs []string
				namedPathParameter := req.GetName()
				namedPathValues := strings.Split(namedPathParameter, "/")
				if len(namedPathValues) != 2 {
					return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
				}
				pairs = append(pairs, "shelf", namedPathValues[1])
				path, err := router.Get("/google.example.library.v1.LibraryService/DeleteShelf").URLPath(pairs...)
				if err != nil {
					return nil, err
				}
				queries := url.Values{}
				target := &url.URL{
					Scheme:   scheme,
					Host:     instance,
					Path:     path.Path,
					RawQuery: queries.Encode(),
				}
				r, err := http1.NewRequestWithContext(ctx, "DELETE", target.String(), body)
				if err != nil {
					return nil, err
				}
				return r, nil
			},
			func(ctx context.Context, r *http1.Response) (any, error) {
				if httpx.IsErrorResponse(r) {
					return nil, httpx.ErrorDecoder(ctx, r)
				}
				resp := &emptypb.Empty{}
				if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
					return nil, err
				}
				return resp, nil
			},
			http.ClientBefore(httpx.OutgoingMetadata),
		),
		mergeShelves: http.NewExplicitClient(
			func(ctx context.Context, obj any) (*http1.Request, error) {
				if obj == nil {
					return nil, errors.New("request object is nil")
				}
				req, ok := obj.(*MergeShelvesRequest)
				if !ok {
					return nil, fmt.Errorf("invalid request object type, %T", obj)
				}
				_ = req
				var body io.Reader
				var bodyBuf bytes.Buffer
				if err := jsonx.NewEncoder(&bodyBuf).Encode(req); err != nil {
					return nil, err
				}
				body = &bodyBuf
				contentType := "application/json; charset=utf-8"
				var pairs []string
				namedPathParameter := req.GetName()
				namedPathValues := strings.Split(namedPathParameter, "/")
				if len(namedPathValues) != 2 {
					return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
				}
				pairs = append(pairs, "shelf", namedPathValues[1])
				path, err := router.Get("/google.example.library.v1.LibraryService/MergeShelves").URLPath(pairs...)
				if err != nil {
					return nil, err
				}
				queries := url.Values{}
				target := &url.URL{
					Scheme:   scheme,
					Host:     instance,
					Path:     path.Path,
					RawQuery: queries.Encode(),
				}
				r, err := http1.NewRequestWithContext(ctx, "POST", target.String(), body)
				if err != nil {
					return nil, err
				}
				r.Header.Set("Content-Type", contentType)
				return r, nil
			},
			func(ctx context.Context, r *http1.Response) (any, error) {
				if httpx.IsErrorResponse(r) {
					return nil, httpx.ErrorDecoder(ctx, r)
				}
				resp := &Shelf{}
				if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
					return nil, err
				}
				return resp, nil
			},
			http.ClientBefore(httpx.OutgoingMetadata),
		),
		createBook: http.NewExplicitClient(
			func(ctx context.Context, obj any) (*http1.Request, error) {
				if obj == nil {
					return nil, errors.New("request object is nil")
				}
				req, ok := obj.(*CreateBookRequest)
				if !ok {
					return nil, fmt.Errorf("invalid request object type, %T", obj)
				}
				_ = req
				var body io.Reader
				var bodyBuf bytes.Buffer
				if err := jsonx.NewEncoder(&bodyBuf).Encode(req.GetBook()); err != nil {
					return nil, err
				}
				body = &bodyBuf
				contentType := "application/json; charset=utf-8"
				var pairs []string
				namedPathParameter := req.GetParent()
				namedPathValues := strings.Split(namedPathParameter, "/")
				if len(namedPathValues) != 2 {
					return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
				}
				pairs = append(pairs, "shelf", namedPathValues[1])
				path, err := router.Get("/google.example.library.v1.LibraryService/CreateBook").URLPath(pairs...)
				if err != nil {
					return nil, err
				}
				queries := url.Values{}
				target := &url.URL{
					Scheme:   scheme,
					Host:     instance,
					Path:     path.Path,
					RawQuery: queries.Encode(),
				}
				r, err := http1.NewRequestWithContext(ctx, "POST", target.String(), body)
				if err != nil {
					return nil, err
				}
				r.Header.Set("Content-Type", contentType)
				return r, nil
			},
			func(ctx context.Context, r *http1.Response) (any, error) {
				if httpx.IsErrorResponse(r) {
					return nil, httpx.ErrorDecoder(ctx, r)
				}
				resp := &Book{}
				if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
					return nil, err
				}
				return resp, nil
			},
			http.ClientBefore(httpx.OutgoingMetadata),
		),
		getBook: http.NewExplicitClient(
			func(ctx context.Context, obj any) (*http1.Request, error) {
				if obj == nil {
					return nil, errors.New("request object is nil")
				}
				req, ok := obj.(*GetBookRequest)
				if !ok {
					return nil, fmt.Errorf("invalid request object type, %T", obj)
				}
				_ = req
				var body io.Reader
				var pairs []string
				namedPathParameter := req.GetName()
				namedPathValues := strings.Split(namedPathParameter, "/")
				if len(namedPathValues) != 4 {
					return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
				}
				pairs = append(pairs, "shelf", namedPathValues[1], "book", namedPathValues[3])
				path, err := router.Get("/google.example.library.v1.LibraryService/GetBook").URLPath(pairs...)
				if err != nil {
					return nil, err
				}
				queries := url.Values{}
				target := &url.URL{
					Scheme:   scheme,
					Host:     instance,
					Path:     path.Path,
					RawQuery: queries.Encode(),
				}
				r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
				if err != nil {
					return nil, err
				}
				return r, nil
			},
			func(ctx context.Context, r *http1.Response) (any, error) {
				if httpx.IsErrorResponse(r) {
					return nil, httpx.ErrorDecoder(ctx, r)
				}
				resp := &Book{}
				if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
					return nil, err
				}
				return resp, nil
			},
			http.ClientBefore(httpx.OutgoingMetadata),
		),
		listBooks: http.NewExplicitClient(
			func(ctx context.Context, obj any) (*http1.Request, error) {
				if obj == nil {
					return nil, errors.New("request object is nil")
				}
				req, ok := obj.(*ListBooksRequest)
				if !ok {
					return nil, fmt.Errorf("invalid request object type, %T", obj)
				}
				_ = req
				var body io.Reader
				var pairs []string
				namedPathParameter := req.GetParent()
				namedPathValues := strings.Split(namedPathParameter, "/")
				if len(namedPathValues) != 2 {
					return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
				}
				pairs = append(pairs, "shelf", namedPathValues[1])
				path, err := router.Get("/google.example.library.v1.LibraryService/ListBooks").URLPath(pairs...)
				if err != nil {
					return nil, err
				}
				queries := url.Values{}
				queries["page_size"] = append(queries["page_size"], strconvx.FormatInt(req.GetPageSize(), 10))
				queries["page_token"] = append(queries["page_token"], req.GetPageToken())
				target := &url.URL{
					Scheme:   scheme,
					Host:     instance,
					Path:     path.Path,
					RawQuery: queries.Encode(),
				}
				r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
				if err != nil {
					return nil, err
				}
				return r, nil
			},
			func(ctx context.Context, r *http1.Response) (any, error) {
				if httpx.IsErrorResponse(r) {
					return nil, httpx.ErrorDecoder(ctx, r)
				}
				resp := &ListBooksResponse{}
				if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
					return nil, err
				}
				return resp, nil
			},
			http.ClientBefore(httpx.OutgoingMetadata),
		),
		deleteBook: http.NewExplicitClient(
			func(ctx context.Context, obj any) (*http1.Request, error) {
				if obj == nil {
					return nil, errors.New("request object is nil")
				}
				req, ok := obj.(*DeleteBookRequest)
				if !ok {
					return nil, fmt.Errorf("invalid request object type, %T", obj)
				}
				_ = req
				var body io.Reader
				var pairs []string
				namedPathParameter := req.GetName()
				namedPathValues := strings.Split(namedPathParameter, "/")
				if len(namedPathValues) != 4 {
					return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
				}
				pairs = append(pairs, "shelf", namedPathValues[1], "book", namedPathValues[3])
				path, err := router.Get("/google.example.library.v1.LibraryService/DeleteBook").URLPath(pairs...)
				if err != nil {
					return nil, err
				}
				queries := url.Values{}
				target := &url.URL{
					Scheme:   scheme,
					Host:     instance,
					Path:     path.Path,
					RawQuery: queries.Encode(),
				}
				r, err := http1.NewRequestWithContext(ctx, "DELETE", target.String(), body)
				if err != nil {
					return nil, err
				}
				return r, nil
			},
			func(ctx context.Context, r *http1.Response) (any, error) {
				if httpx.IsErrorResponse(r) {
					return nil, httpx.ErrorDecoder(ctx, r)
				}
				resp := &emptypb.Empty{}
				if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
					return nil, err
				}
				return resp, nil
			},
			http.ClientBefore(httpx.OutgoingMetadata),
		),
		updateBook: http.NewExplicitClient(
			func(ctx context.Context, obj any) (*http1.Request, error) {
				if obj == nil {
					return nil, errors.New("request object is nil")
				}
				req, ok := obj.(*UpdateBookRequest)
				if !ok {
					return nil, fmt.Errorf("invalid request object type, %T", obj)
				}
				_ = req
				var body io.Reader
				var bodyBuf bytes.Buffer
				if err := jsonx.NewEncoder(&bodyBuf).Encode(req.GetBook()); err != nil {
					return nil, err
				}
				body = &bodyBuf
				contentType := "application/json; charset=utf-8"
				var pairs []string
				namedPathParameter := req.GetBook().GetName()
				namedPathValues := strings.Split(namedPathParameter, "/")
				if len(namedPathValues) != 4 {
					return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
				}
				pairs = append(pairs, "shelf", namedPathValues[1], "book", namedPathValues[3])
				path, err := router.Get("/google.example.library.v1.LibraryService/UpdateBook").URLPath(pairs...)
				if err != nil {
					return nil, err
				}
				queries := url.Values{}
				target := &url.URL{
					Scheme:   scheme,
					Host:     instance,
					Path:     path.Path,
					RawQuery: queries.Encode(),
				}
				r, err := http1.NewRequestWithContext(ctx, "PATCH", target.String(), body)
				if err != nil {
					return nil, err
				}
				r.Header.Set("Content-Type", contentType)
				return r, nil
			},
			func(ctx context.Context, r *http1.Response) (any, error) {
				if httpx.IsErrorResponse(r) {
					return nil, httpx.ErrorDecoder(ctx, r)
				}
				resp := &Book{}
				if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
					return nil, err
				}
				return resp, nil
			},
			http.ClientBefore(httpx.OutgoingMetadata),
		),
		moveBook: http.NewExplicitClient(
			func(ctx context.Context, obj any) (*http1.Request, error) {
				if obj == nil {
					return nil, errors.New("request object is nil")
				}
				req, ok := obj.(*MoveBookRequest)
				if !ok {
					return nil, fmt.Errorf("invalid request object type, %T", obj)
				}
				_ = req
				var body io.Reader
				var bodyBuf bytes.Buffer
				if err := jsonx.NewEncoder(&bodyBuf).Encode(req); err != nil {
					return nil, err
				}
				body = &bodyBuf
				contentType := "application/json; charset=utf-8"
				var pairs []string
				namedPathParameter := req.GetName()
				namedPathValues := strings.Split(namedPathParameter, "/")
				if len(namedPathValues) != 4 {
					return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
				}
				pairs = append(pairs, "shelf", namedPathValues[1], "book", namedPathValues[3])
				path, err := router.Get("/google.example.library.v1.LibraryService/MoveBook").URLPath(pairs...)
				if err != nil {
					return nil, err
				}
				queries := url.Values{}
				target := &url.URL{
					Scheme:   scheme,
					Host:     instance,
					Path:     path.Path,
					RawQuery: queries.Encode(),
				}
				r, err := http1.NewRequestWithContext(ctx, "POST", target.String(), body)
				if err != nil {
					return nil, err
				}
				r.Header.Set("Content-Type", contentType)
				return r, nil
			},
			func(ctx context.Context, r *http1.Response) (any, error) {
				if httpx.IsErrorResponse(r) {
					return nil, httpx.ErrorDecoder(ctx, r)
				}
				resp := &Book{}
				if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
					return nil, err
				}
				return resp, nil
			},
			http.ClientBefore(httpx.OutgoingMetadata),
		),
	}
}

type libraryServiceHttpClient struct {
	createShelf  endpoint.Endpoint
	getShelf     endpoint.Endpoint
	listShelves  endpoint.Endpoint
	deleteShelf  endpoint.Endpoint
	mergeShelves endpoint.Endpoint
	createBook   endpoint.Endpoint
	getBook      endpoint.Endpoint
	listBooks    endpoint.Endpoint
	deleteBook   endpoint.Endpoint
	updateBook   endpoint.Endpoint
	moveBook     endpoint.Endpoint
}

func (c *libraryServiceHttpClient) CreateShelf(ctx context.Context, request *CreateShelfRequest) (*Shelf, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/CreateShelf")
	ctx = transportx.InjectName(ctx, httpx.HttpClient)
	rep, err := c.createShelf(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*Shelf), nil
}

func (c *libraryServiceHttpClient) GetShelf(ctx context.Context, request *GetShelfRequest) (*Shelf, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/GetShelf")
	ctx = transportx.InjectName(ctx, httpx.HttpClient)
	rep, err := c.getShelf(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*Shelf), nil
}

func (c *libraryServiceHttpClient) ListShelves(ctx context.Context, request *ListShelvesRequest) (*ListShelvesResponse, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/ListShelves")
	ctx = transportx.InjectName(ctx, httpx.HttpClient)
	rep, err := c.listShelves(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*ListShelvesResponse), nil
}

func (c *libraryServiceHttpClient) DeleteShelf(ctx context.Context, request *DeleteShelfRequest) (*emptypb.Empty, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/DeleteShelf")
	ctx = transportx.InjectName(ctx, httpx.HttpClient)
	rep, err := c.deleteShelf(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *libraryServiceHttpClient) MergeShelves(ctx context.Context, request *MergeShelvesRequest) (*Shelf, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/MergeShelves")
	ctx = transportx.InjectName(ctx, httpx.HttpClient)
	rep, err := c.mergeShelves(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*Shelf), nil
}

func (c *libraryServiceHttpClient) CreateBook(ctx context.Context, request *CreateBookRequest) (*Book, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/CreateBook")
	ctx = transportx.InjectName(ctx, httpx.HttpClient)
	rep, err := c.createBook(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*Book), nil
}

func (c *libraryServiceHttpClient) GetBook(ctx context.Context, request *GetBookRequest) (*Book, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/GetBook")
	ctx = transportx.InjectName(ctx, httpx.HttpClient)
	rep, err := c.getBook(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*Book), nil
}

func (c *libraryServiceHttpClient) ListBooks(ctx context.Context, request *ListBooksRequest) (*ListBooksResponse, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/ListBooks")
	ctx = transportx.InjectName(ctx, httpx.HttpClient)
	rep, err := c.listBooks(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*ListBooksResponse), nil
}

func (c *libraryServiceHttpClient) DeleteBook(ctx context.Context, request *DeleteBookRequest) (*emptypb.Empty, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/DeleteBook")
	ctx = transportx.InjectName(ctx, httpx.HttpClient)
	rep, err := c.deleteBook(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *libraryServiceHttpClient) UpdateBook(ctx context.Context, request *UpdateBookRequest) (*Book, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/UpdateBook")
	ctx = transportx.InjectName(ctx, httpx.HttpClient)
	rep, err := c.updateBook(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*Book), nil
}

func (c *libraryServiceHttpClient) MoveBook(ctx context.Context, request *MoveBookRequest) (*Book, error) {
	ctx = endpointx.InjectName(ctx, "/google.example.library.v1.LibraryService/MoveBook")
	ctx = transportx.InjectName(ctx, httpx.HttpClient)
	rep, err := c.moveBook(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*Book), nil
}

func NewLibraryServiceHttpClient(transports LibraryServiceTransports, middlewares ...endpoint.Middleware) LibraryServiceService {
	return &libraryServiceHttpClient{
		createShelf:  endpointx.Chain(transports.CreateShelf().Endpoint(), middlewares...),
		getShelf:     endpointx.Chain(transports.GetShelf().Endpoint(), middlewares...),
		listShelves:  endpointx.Chain(transports.ListShelves().Endpoint(), middlewares...),
		deleteShelf:  endpointx.Chain(transports.DeleteShelf().Endpoint(), middlewares...),
		mergeShelves: endpointx.Chain(transports.MergeShelves().Endpoint(), middlewares...),
		createBook:   endpointx.Chain(transports.CreateBook().Endpoint(), middlewares...),
		getBook:      endpointx.Chain(transports.GetBook().Endpoint(), middlewares...),
		listBooks:    endpointx.Chain(transports.ListBooks().Endpoint(), middlewares...),
		deleteBook:   endpointx.Chain(transports.DeleteBook().Endpoint(), middlewares...),
		updateBook:   endpointx.Chain(transports.UpdateBook().Endpoint(), middlewares...),
		moveBook:     endpointx.Chain(transports.MoveBook().Endpoint(), middlewares...),
	}
}
