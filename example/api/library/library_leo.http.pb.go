// Code generated by protoc-gen-leo-http. DO NOT EDIT.

package library

import (
	bytes "bytes"
	context "context"
	fmt "fmt"
	endpoint "github.com/go-kit/kit/endpoint"
	http1 "github.com/go-kit/kit/transport/http"
	jsonx "github.com/go-leo/gox/encodingx/jsonx"
	errorx "github.com/go-leo/gox/errorx"
	urlx "github.com/go-leo/gox/netx/urlx"
	strconvx "github.com/go-leo/gox/strconvx"
	endpointx "github.com/go-leo/leo/v3/endpointx"
	statusx "github.com/go-leo/leo/v3/statusx"
	httpx "github.com/go-leo/leo/v3/transportx/httpx"
	mux "github.com/gorilla/mux"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	io "io"
	http "net/http"
	url "net/url"
	strings "strings"
)

func appendLibraryServiceHttpRoutes(router *mux.Router) *mux.Router {
	router.NewRoute().Name("/google.example.library.v1.LibraryService/CreateShelf").Methods("POST").Path("/v1/shelves")
	router.NewRoute().Name("/google.example.library.v1.LibraryService/GetShelf").Methods("GET").Path("/v1/shelves/{shelf}")
	router.NewRoute().Name("/google.example.library.v1.LibraryService/ListShelves").Methods("GET").Path("/v1/shelves")
	router.NewRoute().Name("/google.example.library.v1.LibraryService/DeleteShelf").Methods("DELETE").Path("/v1/shelves/{shelf}")
	router.NewRoute().Name("/google.example.library.v1.LibraryService/MergeShelves").Methods("POST").Path("/v1/shelves/{shelf}:merge")
	router.NewRoute().Name("/google.example.library.v1.LibraryService/CreateBook").Methods("POST").Path("/v1/shelves/{shelf}/books")
	router.NewRoute().Name("/google.example.library.v1.LibraryService/GetBook").Methods("GET").Path("/v1/shelves/{shelf}/books/{book}")
	router.NewRoute().Name("/google.example.library.v1.LibraryService/ListBooks").Methods("GET").Path("/v1/shelves/{shelf}/books")
	router.NewRoute().Name("/google.example.library.v1.LibraryService/DeleteBook").Methods("DELETE").Path("/v1/shelves/{shelf}/books/{book}")
	router.NewRoute().Name("/google.example.library.v1.LibraryService/UpdateBook").Methods("PATCH").Path("/v1/shelves/{shelf}/books/{book}")
	router.NewRoute().Name("/google.example.library.v1.LibraryService/MoveBook").Methods("POST").Path("/v1/shelves/{shelf}/books/{book}:move")
	return router
}
func AppendLibraryServiceHttpServerRoutes(router *mux.Router, svc LibraryServiceService, middlewares ...endpoint.Middleware) *mux.Router {
	transports := newLibraryServiceHttpServerTransports(svc, middlewares...)
	router = appendLibraryServiceHttpRoutes(router)
	router.Get("/google.example.library.v1.LibraryService/CreateShelf").Handler(transports.CreateShelf())
	router.Get("/google.example.library.v1.LibraryService/GetShelf").Handler(transports.GetShelf())
	router.Get("/google.example.library.v1.LibraryService/ListShelves").Handler(transports.ListShelves())
	router.Get("/google.example.library.v1.LibraryService/DeleteShelf").Handler(transports.DeleteShelf())
	router.Get("/google.example.library.v1.LibraryService/MergeShelves").Handler(transports.MergeShelves())
	router.Get("/google.example.library.v1.LibraryService/CreateBook").Handler(transports.CreateBook())
	router.Get("/google.example.library.v1.LibraryService/GetBook").Handler(transports.GetBook())
	router.Get("/google.example.library.v1.LibraryService/ListBooks").Handler(transports.ListBooks())
	router.Get("/google.example.library.v1.LibraryService/DeleteBook").Handler(transports.DeleteBook())
	router.Get("/google.example.library.v1.LibraryService/UpdateBook").Handler(transports.UpdateBook())
	router.Get("/google.example.library.v1.LibraryService/MoveBook").Handler(transports.MoveBook())
	return router
}

func NewLibraryServiceHttpClient(target string, opts ...httpx.ClientOption) LibraryServiceService {
	options := httpx.NewClientOptions(opts...)
	transports := newLibraryServiceHttpClientTransports(options.Scheme(), options.ClientTransportOptions(), options.Middlewares())
	endpoints := newLibraryServiceClientEndpoints(target, transports, options.Builder(), options.EndpointerOptions(), options.BalancerFactory(), options.Logger())
	return newLibraryServiceClientService(endpoints, httpx.HttpClient)
}

type LibraryServiceHttpServerTransports interface {
	CreateShelf() http.Handler
	GetShelf() http.Handler
	ListShelves() http.Handler
	DeleteShelf() http.Handler
	MergeShelves() http.Handler
	CreateBook() http.Handler
	GetBook() http.Handler
	ListBooks() http.Handler
	DeleteBook() http.Handler
	UpdateBook() http.Handler
	MoveBook() http.Handler
}

type LibraryServiceHttpServerRequestDecoder interface {
	CreateShelf() http1.DecodeRequestFunc
	GetShelf() http1.DecodeRequestFunc
	ListShelves() http1.DecodeRequestFunc
	DeleteShelf() http1.DecodeRequestFunc
	MergeShelves() http1.DecodeRequestFunc
	CreateBook() http1.DecodeRequestFunc
	GetBook() http1.DecodeRequestFunc
	ListBooks() http1.DecodeRequestFunc
	DeleteBook() http1.DecodeRequestFunc
	UpdateBook() http1.DecodeRequestFunc
	MoveBook() http1.DecodeRequestFunc
}

type LibraryServiceHttpServerResponseEncoder interface {
	CreateShelf() http1.EncodeResponseFunc
	GetShelf() http1.EncodeResponseFunc
	ListShelves() http1.EncodeResponseFunc
	DeleteShelf() http1.EncodeResponseFunc
	MergeShelves() http1.EncodeResponseFunc
	CreateBook() http1.EncodeResponseFunc
	GetBook() http1.EncodeResponseFunc
	ListBooks() http1.EncodeResponseFunc
	DeleteBook() http1.EncodeResponseFunc
	UpdateBook() http1.EncodeResponseFunc
	MoveBook() http1.EncodeResponseFunc
}

type LibraryServiceHttpClientRequestEncoder interface {
	CreateShelf(instance string) http1.CreateRequestFunc
	GetShelf(instance string) http1.CreateRequestFunc
	ListShelves(instance string) http1.CreateRequestFunc
	DeleteShelf(instance string) http1.CreateRequestFunc
	MergeShelves(instance string) http1.CreateRequestFunc
	CreateBook(instance string) http1.CreateRequestFunc
	GetBook(instance string) http1.CreateRequestFunc
	ListBooks(instance string) http1.CreateRequestFunc
	DeleteBook(instance string) http1.CreateRequestFunc
	UpdateBook(instance string) http1.CreateRequestFunc
	MoveBook(instance string) http1.CreateRequestFunc
}

type LibraryServiceHttpClientResponseDecoder interface {
	CreateShelf() http1.DecodeResponseFunc
	GetShelf() http1.DecodeResponseFunc
	ListShelves() http1.DecodeResponseFunc
	DeleteShelf() http1.DecodeResponseFunc
	MergeShelves() http1.DecodeResponseFunc
	CreateBook() http1.DecodeResponseFunc
	GetBook() http1.DecodeResponseFunc
	ListBooks() http1.DecodeResponseFunc
	DeleteBook() http1.DecodeResponseFunc
	UpdateBook() http1.DecodeResponseFunc
	MoveBook() http1.DecodeResponseFunc
}

type libraryServiceHttpServerTransports struct {
	endpoints       LibraryServiceServerEndpoints
	requestDecoder  LibraryServiceHttpServerRequestDecoder
	responseEncoder LibraryServiceHttpServerResponseEncoder
}

func (t *libraryServiceHttpServerTransports) CreateShelf() http.Handler {
	return http1.NewServer(
		t.endpoints.CreateShelf(context.TODO()),
		t.requestDecoder.CreateShelf(),
		t.responseEncoder.CreateShelf(),
		http1.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/CreateShelf")),
		http1.ServerBefore(httpx.ServerTransportInjector),
		http1.ServerBefore(httpx.IncomingMetadataInjector),
		http1.ServerBefore(httpx.IncomingTimeLimitInjector),
		http1.ServerBefore(httpx.IncomingStainInjector),
		http1.ServerFinalizer(httpx.CancelInvoker),
		http1.ServerErrorEncoder(httpx.ErrorEncoder),
	)
}

func (t *libraryServiceHttpServerTransports) GetShelf() http.Handler {
	return http1.NewServer(
		t.endpoints.GetShelf(context.TODO()),
		t.requestDecoder.GetShelf(),
		t.responseEncoder.GetShelf(),
		http1.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/GetShelf")),
		http1.ServerBefore(httpx.ServerTransportInjector),
		http1.ServerBefore(httpx.IncomingMetadataInjector),
		http1.ServerBefore(httpx.IncomingTimeLimitInjector),
		http1.ServerBefore(httpx.IncomingStainInjector),
		http1.ServerFinalizer(httpx.CancelInvoker),
		http1.ServerErrorEncoder(httpx.ErrorEncoder),
	)
}

func (t *libraryServiceHttpServerTransports) ListShelves() http.Handler {
	return http1.NewServer(
		t.endpoints.ListShelves(context.TODO()),
		t.requestDecoder.ListShelves(),
		t.responseEncoder.ListShelves(),
		http1.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/ListShelves")),
		http1.ServerBefore(httpx.ServerTransportInjector),
		http1.ServerBefore(httpx.IncomingMetadataInjector),
		http1.ServerBefore(httpx.IncomingTimeLimitInjector),
		http1.ServerBefore(httpx.IncomingStainInjector),
		http1.ServerFinalizer(httpx.CancelInvoker),
		http1.ServerErrorEncoder(httpx.ErrorEncoder),
	)
}

func (t *libraryServiceHttpServerTransports) DeleteShelf() http.Handler {
	return http1.NewServer(
		t.endpoints.DeleteShelf(context.TODO()),
		t.requestDecoder.DeleteShelf(),
		t.responseEncoder.DeleteShelf(),
		http1.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/DeleteShelf")),
		http1.ServerBefore(httpx.ServerTransportInjector),
		http1.ServerBefore(httpx.IncomingMetadataInjector),
		http1.ServerBefore(httpx.IncomingTimeLimitInjector),
		http1.ServerBefore(httpx.IncomingStainInjector),
		http1.ServerFinalizer(httpx.CancelInvoker),
		http1.ServerErrorEncoder(httpx.ErrorEncoder),
	)
}

func (t *libraryServiceHttpServerTransports) MergeShelves() http.Handler {
	return http1.NewServer(
		t.endpoints.MergeShelves(context.TODO()),
		t.requestDecoder.MergeShelves(),
		t.responseEncoder.MergeShelves(),
		http1.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/MergeShelves")),
		http1.ServerBefore(httpx.ServerTransportInjector),
		http1.ServerBefore(httpx.IncomingMetadataInjector),
		http1.ServerBefore(httpx.IncomingTimeLimitInjector),
		http1.ServerBefore(httpx.IncomingStainInjector),
		http1.ServerFinalizer(httpx.CancelInvoker),
		http1.ServerErrorEncoder(httpx.ErrorEncoder),
	)
}

func (t *libraryServiceHttpServerTransports) CreateBook() http.Handler {
	return http1.NewServer(
		t.endpoints.CreateBook(context.TODO()),
		t.requestDecoder.CreateBook(),
		t.responseEncoder.CreateBook(),
		http1.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/CreateBook")),
		http1.ServerBefore(httpx.ServerTransportInjector),
		http1.ServerBefore(httpx.IncomingMetadataInjector),
		http1.ServerBefore(httpx.IncomingTimeLimitInjector),
		http1.ServerBefore(httpx.IncomingStainInjector),
		http1.ServerFinalizer(httpx.CancelInvoker),
		http1.ServerErrorEncoder(httpx.ErrorEncoder),
	)
}

func (t *libraryServiceHttpServerTransports) GetBook() http.Handler {
	return http1.NewServer(
		t.endpoints.GetBook(context.TODO()),
		t.requestDecoder.GetBook(),
		t.responseEncoder.GetBook(),
		http1.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/GetBook")),
		http1.ServerBefore(httpx.ServerTransportInjector),
		http1.ServerBefore(httpx.IncomingMetadataInjector),
		http1.ServerBefore(httpx.IncomingTimeLimitInjector),
		http1.ServerBefore(httpx.IncomingStainInjector),
		http1.ServerFinalizer(httpx.CancelInvoker),
		http1.ServerErrorEncoder(httpx.ErrorEncoder),
	)
}

func (t *libraryServiceHttpServerTransports) ListBooks() http.Handler {
	return http1.NewServer(
		t.endpoints.ListBooks(context.TODO()),
		t.requestDecoder.ListBooks(),
		t.responseEncoder.ListBooks(),
		http1.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/ListBooks")),
		http1.ServerBefore(httpx.ServerTransportInjector),
		http1.ServerBefore(httpx.IncomingMetadataInjector),
		http1.ServerBefore(httpx.IncomingTimeLimitInjector),
		http1.ServerBefore(httpx.IncomingStainInjector),
		http1.ServerFinalizer(httpx.CancelInvoker),
		http1.ServerErrorEncoder(httpx.ErrorEncoder),
	)
}

func (t *libraryServiceHttpServerTransports) DeleteBook() http.Handler {
	return http1.NewServer(
		t.endpoints.DeleteBook(context.TODO()),
		t.requestDecoder.DeleteBook(),
		t.responseEncoder.DeleteBook(),
		http1.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/DeleteBook")),
		http1.ServerBefore(httpx.ServerTransportInjector),
		http1.ServerBefore(httpx.IncomingMetadataInjector),
		http1.ServerBefore(httpx.IncomingTimeLimitInjector),
		http1.ServerBefore(httpx.IncomingStainInjector),
		http1.ServerFinalizer(httpx.CancelInvoker),
		http1.ServerErrorEncoder(httpx.ErrorEncoder),
	)
}

func (t *libraryServiceHttpServerTransports) UpdateBook() http.Handler {
	return http1.NewServer(
		t.endpoints.UpdateBook(context.TODO()),
		t.requestDecoder.UpdateBook(),
		t.responseEncoder.UpdateBook(),
		http1.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/UpdateBook")),
		http1.ServerBefore(httpx.ServerTransportInjector),
		http1.ServerBefore(httpx.IncomingMetadataInjector),
		http1.ServerBefore(httpx.IncomingTimeLimitInjector),
		http1.ServerBefore(httpx.IncomingStainInjector),
		http1.ServerFinalizer(httpx.CancelInvoker),
		http1.ServerErrorEncoder(httpx.ErrorEncoder),
	)
}

func (t *libraryServiceHttpServerTransports) MoveBook() http.Handler {
	return http1.NewServer(
		t.endpoints.MoveBook(context.TODO()),
		t.requestDecoder.MoveBook(),
		t.responseEncoder.MoveBook(),
		http1.ServerBefore(httpx.EndpointInjector("/google.example.library.v1.LibraryService/MoveBook")),
		http1.ServerBefore(httpx.ServerTransportInjector),
		http1.ServerBefore(httpx.IncomingMetadataInjector),
		http1.ServerBefore(httpx.IncomingTimeLimitInjector),
		http1.ServerBefore(httpx.IncomingStainInjector),
		http1.ServerFinalizer(httpx.CancelInvoker),
		http1.ServerErrorEncoder(httpx.ErrorEncoder),
	)
}

func newLibraryServiceHttpServerTransports(svc LibraryServiceService, middlewares ...endpoint.Middleware) LibraryServiceHttpServerTransports {
	endpoints := newLibraryServiceServerEndpoints(svc, middlewares...)
	return &libraryServiceHttpServerTransports{
		endpoints:       endpoints,
		requestDecoder:  libraryServiceHttpServerRequestDecoder{},
		responseEncoder: libraryServiceHttpServerResponseEncoder{},
	}
}

type libraryServiceHttpServerRequestDecoder struct{}

func (libraryServiceHttpServerRequestDecoder) CreateShelf() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &CreateShelfRequest{}
		if err := jsonx.NewDecoder(r.Body).Decode(&req.Shelf); err != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
		}
		return req, nil
	}
}
func (libraryServiceHttpServerRequestDecoder) GetShelf() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &GetShelfRequest{}
		vars := urlx.FormFromMap(mux.Vars(r))
		var varErr error
		req.Name = fmt.Sprintf("shelves/%s", vars.Get("shelf"))
		if varErr != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(varErr))
		}
		return req, nil
	}
}
func (libraryServiceHttpServerRequestDecoder) ListShelves() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &ListShelvesRequest{}
		queries := r.URL.Query()
		var queryErr error
		req.PageSize, queryErr = errorx.Break[int32](queryErr)(urlx.GetInt[int32](queries, "page_size"))
		req.PageToken = queries.Get("page_token")
		if queryErr != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(queryErr))
		}
		return req, nil
	}
}
func (libraryServiceHttpServerRequestDecoder) DeleteShelf() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &DeleteShelfRequest{}
		vars := urlx.FormFromMap(mux.Vars(r))
		var varErr error
		req.Name = fmt.Sprintf("shelves/%s", vars.Get("shelf"))
		if varErr != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(varErr))
		}
		return req, nil
	}
}
func (libraryServiceHttpServerRequestDecoder) MergeShelves() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &MergeShelvesRequest{}
		if err := jsonx.NewDecoder(r.Body).Decode(req); err != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
		}
		vars := urlx.FormFromMap(mux.Vars(r))
		var varErr error
		req.Name = fmt.Sprintf("shelves/%s", vars.Get("shelf"))
		if varErr != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(varErr))
		}
		return req, nil
	}
}
func (libraryServiceHttpServerRequestDecoder) CreateBook() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &CreateBookRequest{}
		if err := jsonx.NewDecoder(r.Body).Decode(&req.Book); err != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
		}
		vars := urlx.FormFromMap(mux.Vars(r))
		var varErr error
		req.Parent = fmt.Sprintf("shelves/%s", vars.Get("shelf"))
		if varErr != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(varErr))
		}
		return req, nil
	}
}
func (libraryServiceHttpServerRequestDecoder) GetBook() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &GetBookRequest{}
		vars := urlx.FormFromMap(mux.Vars(r))
		var varErr error
		req.Name = fmt.Sprintf("shelves/%s/books/%s", vars.Get("shelf"), vars.Get("book"))
		if varErr != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(varErr))
		}
		return req, nil
	}
}
func (libraryServiceHttpServerRequestDecoder) ListBooks() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &ListBooksRequest{}
		vars := urlx.FormFromMap(mux.Vars(r))
		var varErr error
		req.Parent = fmt.Sprintf("shelves/%s", vars.Get("shelf"))
		if varErr != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(varErr))
		}
		queries := r.URL.Query()
		var queryErr error
		req.PageSize, queryErr = errorx.Break[int32](queryErr)(urlx.GetInt[int32](queries, "page_size"))
		req.PageToken = queries.Get("page_token")
		if queryErr != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(queryErr))
		}
		return req, nil
	}
}
func (libraryServiceHttpServerRequestDecoder) DeleteBook() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &DeleteBookRequest{}
		vars := urlx.FormFromMap(mux.Vars(r))
		var varErr error
		req.Name = fmt.Sprintf("shelves/%s/books/%s", vars.Get("shelf"), vars.Get("book"))
		if varErr != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(varErr))
		}
		return req, nil
	}
}
func (libraryServiceHttpServerRequestDecoder) UpdateBook() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &UpdateBookRequest{}
		if err := jsonx.NewDecoder(r.Body).Decode(&req.Book); err != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
		}
		vars := urlx.FormFromMap(mux.Vars(r))
		var varErr error
		if req.Book == nil {
			req.Book = &Book{}
		}
		req.Book.Name = fmt.Sprintf("shelves/%s/books/%s", vars.Get("shelf"), vars.Get("book"))
		if varErr != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(varErr))
		}
		return req, nil
	}
}
func (libraryServiceHttpServerRequestDecoder) MoveBook() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &MoveBookRequest{}
		if err := jsonx.NewDecoder(r.Body).Decode(req); err != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
		}
		vars := urlx.FormFromMap(mux.Vars(r))
		var varErr error
		req.Name = fmt.Sprintf("shelves/%s/books/%s", vars.Get("shelf"), vars.Get("book"))
		if varErr != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(varErr))
		}
		return req, nil
	}
}

type libraryServiceHttpServerResponseEncoder struct{}

func (libraryServiceHttpServerResponseEncoder) CreateShelf() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*Shelf)
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(http.StatusOK)
		if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
			return statusx.ErrInternal.With(statusx.Wrap(err))
		}
		return nil
	}
}
func (libraryServiceHttpServerResponseEncoder) GetShelf() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*Shelf)
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(http.StatusOK)
		if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
			return statusx.ErrInternal.With(statusx.Wrap(err))
		}
		return nil
	}
}
func (libraryServiceHttpServerResponseEncoder) ListShelves() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*ListShelvesResponse)
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(http.StatusOK)
		if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
			return statusx.ErrInternal.With(statusx.Wrap(err))
		}
		return nil
	}
}
func (libraryServiceHttpServerResponseEncoder) DeleteShelf() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*emptypb.Empty)
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(http.StatusOK)
		if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
			return statusx.ErrInternal.With(statusx.Wrap(err))
		}
		return nil
	}
}
func (libraryServiceHttpServerResponseEncoder) MergeShelves() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*Shelf)
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(http.StatusOK)
		if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
			return statusx.ErrInternal.With(statusx.Wrap(err))
		}
		return nil
	}
}
func (libraryServiceHttpServerResponseEncoder) CreateBook() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*Book)
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(http.StatusOK)
		if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
			return statusx.ErrInternal.With(statusx.Wrap(err))
		}
		return nil
	}
}
func (libraryServiceHttpServerResponseEncoder) GetBook() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*Book)
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(http.StatusOK)
		if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
			return statusx.ErrInternal.With(statusx.Wrap(err))
		}
		return nil
	}
}
func (libraryServiceHttpServerResponseEncoder) ListBooks() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*ListBooksResponse)
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(http.StatusOK)
		if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
			return statusx.ErrInternal.With(statusx.Wrap(err))
		}
		return nil
	}
}
func (libraryServiceHttpServerResponseEncoder) DeleteBook() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*emptypb.Empty)
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(http.StatusOK)
		if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
			return statusx.ErrInternal.With(statusx.Wrap(err))
		}
		return nil
	}
}
func (libraryServiceHttpServerResponseEncoder) UpdateBook() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*Book)
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(http.StatusOK)
		if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
			return statusx.ErrInternal.With(statusx.Wrap(err))
		}
		return nil
	}
}
func (libraryServiceHttpServerResponseEncoder) MoveBook() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*Book)
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(http.StatusOK)
		if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
			return statusx.ErrInternal.With(statusx.Wrap(err))
		}
		return nil
	}
}

type libraryServiceHttpClientTransports struct {
	clientOptions   []http1.ClientOption
	middlewares     []endpoint.Middleware
	requestEncoder  LibraryServiceHttpClientRequestEncoder
	responseDecoder LibraryServiceHttpClientResponseDecoder
}

func (t *libraryServiceHttpClientTransports) CreateShelf(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(httpx.OutgoingMetadataInjector),
		http1.ClientBefore(httpx.OutgoingTimeLimitInjector),
		http1.ClientBefore(httpx.OutgoingStainInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.CreateShelf(instance),
		t.responseDecoder.CreateShelf(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func (t *libraryServiceHttpClientTransports) GetShelf(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(httpx.OutgoingMetadataInjector),
		http1.ClientBefore(httpx.OutgoingTimeLimitInjector),
		http1.ClientBefore(httpx.OutgoingStainInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.GetShelf(instance),
		t.responseDecoder.GetShelf(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func (t *libraryServiceHttpClientTransports) ListShelves(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(httpx.OutgoingMetadataInjector),
		http1.ClientBefore(httpx.OutgoingTimeLimitInjector),
		http1.ClientBefore(httpx.OutgoingStainInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.ListShelves(instance),
		t.responseDecoder.ListShelves(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func (t *libraryServiceHttpClientTransports) DeleteShelf(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(httpx.OutgoingMetadataInjector),
		http1.ClientBefore(httpx.OutgoingTimeLimitInjector),
		http1.ClientBefore(httpx.OutgoingStainInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.DeleteShelf(instance),
		t.responseDecoder.DeleteShelf(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func (t *libraryServiceHttpClientTransports) MergeShelves(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(httpx.OutgoingMetadataInjector),
		http1.ClientBefore(httpx.OutgoingTimeLimitInjector),
		http1.ClientBefore(httpx.OutgoingStainInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.MergeShelves(instance),
		t.responseDecoder.MergeShelves(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func (t *libraryServiceHttpClientTransports) CreateBook(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(httpx.OutgoingMetadataInjector),
		http1.ClientBefore(httpx.OutgoingTimeLimitInjector),
		http1.ClientBefore(httpx.OutgoingStainInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.CreateBook(instance),
		t.responseDecoder.CreateBook(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func (t *libraryServiceHttpClientTransports) GetBook(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(httpx.OutgoingMetadataInjector),
		http1.ClientBefore(httpx.OutgoingTimeLimitInjector),
		http1.ClientBefore(httpx.OutgoingStainInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.GetBook(instance),
		t.responseDecoder.GetBook(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func (t *libraryServiceHttpClientTransports) ListBooks(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(httpx.OutgoingMetadataInjector),
		http1.ClientBefore(httpx.OutgoingTimeLimitInjector),
		http1.ClientBefore(httpx.OutgoingStainInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.ListBooks(instance),
		t.responseDecoder.ListBooks(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func (t *libraryServiceHttpClientTransports) DeleteBook(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(httpx.OutgoingMetadataInjector),
		http1.ClientBefore(httpx.OutgoingTimeLimitInjector),
		http1.ClientBefore(httpx.OutgoingStainInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.DeleteBook(instance),
		t.responseDecoder.DeleteBook(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func (t *libraryServiceHttpClientTransports) UpdateBook(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(httpx.OutgoingMetadataInjector),
		http1.ClientBefore(httpx.OutgoingTimeLimitInjector),
		http1.ClientBefore(httpx.OutgoingStainInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.UpdateBook(instance),
		t.responseDecoder.UpdateBook(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func (t *libraryServiceHttpClientTransports) MoveBook(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(httpx.OutgoingMetadataInjector),
		http1.ClientBefore(httpx.OutgoingTimeLimitInjector),
		http1.ClientBefore(httpx.OutgoingStainInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.MoveBook(instance),
		t.responseDecoder.MoveBook(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func newLibraryServiceHttpClientTransports(scheme string, clientOptions []http1.ClientOption, middlewares []endpoint.Middleware) LibraryServiceClientTransports {
	return &libraryServiceHttpClientTransports{
		clientOptions: clientOptions,
		middlewares:   middlewares,
		requestEncoder: libraryServiceHttpClientRequestEncoder{
			scheme: scheme,
			router: appendLibraryServiceHttpRoutes(mux.NewRouter()),
		},
		responseDecoder: libraryServiceHttpClientResponseDecoder{},
	}
}

type libraryServiceHttpClientRequestEncoder struct {
	router *mux.Router
	scheme string
}

func (e libraryServiceHttpClientRequestEncoder) CreateShelf(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Message("request is nil"))
		}
		req, ok := obj.(*CreateShelfRequest)
		if !ok {
			return nil, statusx.ErrInvalidArgument.With(statusx.Message("invalid request type, %T", obj))
		}
		_ = req
		var body io.Reader
		var bodyBuf bytes.Buffer
		if err := jsonx.NewEncoder(&bodyBuf).Encode(req.GetShelf()); err != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
		}
		body = &bodyBuf
		contentType := "application/json; charset=utf-8"
		var pairs []string
		path, err := e.router.Get("/google.example.library.v1.LibraryService/CreateShelf").URLPath(pairs...)
		if err != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
		}
		queries := url.Values{}
		target := &url.URL{
			Scheme:   e.scheme,
			Host:     instance,
			Path:     path.Path,
			RawQuery: queries.Encode(),
		}
		r, err := http.NewRequestWithContext(ctx, "POST", target.String(), body)
		if err != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
		}
		r.Header.Set("Content-Type", contentType)
		return r, nil
	}
}
func (e libraryServiceHttpClientRequestEncoder) GetShelf(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Message("request is nil"))
		}
		req, ok := obj.(*GetShelfRequest)
		if !ok {
			return nil, statusx.ErrInvalidArgument.With(statusx.Message("invalid request type, %T", obj))
		}
		_ = req
		var body io.Reader
		var pairs []string
		namedPathParameter := req.GetName()
		namedPathValues := strings.Split(namedPathParameter, "/")
		if len(namedPathValues) != 2 {
			return nil, statusx.ErrInvalidArgument.With(statusx.Message("invalid named path parameter, %s", namedPathParameter))
		}
		pairs = append(pairs, "shelf", namedPathValues[1])
		path, err := e.router.Get("/google.example.library.v1.LibraryService/GetShelf").URLPath(pairs...)
		if err != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
		}
		queries := url.Values{}
		target := &url.URL{
			Scheme:   e.scheme,
			Host:     instance,
			Path:     path.Path,
			RawQuery: queries.Encode(),
		}
		r, err := http.NewRequestWithContext(ctx, "GET", target.String(), body)
		if err != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
		}
		return r, nil
	}
}
func (e libraryServiceHttpClientRequestEncoder) ListShelves(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Message("request is nil"))
		}
		req, ok := obj.(*ListShelvesRequest)
		if !ok {
			return nil, statusx.ErrInvalidArgument.With(statusx.Message("invalid request type, %T", obj))
		}
		_ = req
		var body io.Reader
		var pairs []string
		path, err := e.router.Get("/google.example.library.v1.LibraryService/ListShelves").URLPath(pairs...)
		if err != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
		}
		queries := url.Values{}
		queries["page_size"] = append(queries["page_size"], strconvx.FormatInt(req.GetPageSize(), 10))
		queries["page_token"] = append(queries["page_token"], req.GetPageToken())
		target := &url.URL{
			Scheme:   e.scheme,
			Host:     instance,
			Path:     path.Path,
			RawQuery: queries.Encode(),
		}
		r, err := http.NewRequestWithContext(ctx, "GET", target.String(), body)
		if err != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
		}
		return r, nil
	}
}
func (e libraryServiceHttpClientRequestEncoder) DeleteShelf(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Message("request is nil"))
		}
		req, ok := obj.(*DeleteShelfRequest)
		if !ok {
			return nil, statusx.ErrInvalidArgument.With(statusx.Message("invalid request type, %T", obj))
		}
		_ = req
		var body io.Reader
		var pairs []string
		namedPathParameter := req.GetName()
		namedPathValues := strings.Split(namedPathParameter, "/")
		if len(namedPathValues) != 2 {
			return nil, statusx.ErrInvalidArgument.With(statusx.Message("invalid named path parameter, %s", namedPathParameter))
		}
		pairs = append(pairs, "shelf", namedPathValues[1])
		path, err := e.router.Get("/google.example.library.v1.LibraryService/DeleteShelf").URLPath(pairs...)
		if err != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
		}
		queries := url.Values{}
		target := &url.URL{
			Scheme:   e.scheme,
			Host:     instance,
			Path:     path.Path,
			RawQuery: queries.Encode(),
		}
		r, err := http.NewRequestWithContext(ctx, "DELETE", target.String(), body)
		if err != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
		}
		return r, nil
	}
}
func (e libraryServiceHttpClientRequestEncoder) MergeShelves(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Message("request is nil"))
		}
		req, ok := obj.(*MergeShelvesRequest)
		if !ok {
			return nil, statusx.ErrInvalidArgument.With(statusx.Message("invalid request type, %T", obj))
		}
		_ = req
		var body io.Reader
		var bodyBuf bytes.Buffer
		if err := jsonx.NewEncoder(&bodyBuf).Encode(req); err != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
		}
		body = &bodyBuf
		contentType := "application/json; charset=utf-8"
		var pairs []string
		namedPathParameter := req.GetName()
		namedPathValues := strings.Split(namedPathParameter, "/")
		if len(namedPathValues) != 2 {
			return nil, statusx.ErrInvalidArgument.With(statusx.Message("invalid named path parameter, %s", namedPathParameter))
		}
		pairs = append(pairs, "shelf", namedPathValues[1])
		path, err := e.router.Get("/google.example.library.v1.LibraryService/MergeShelves").URLPath(pairs...)
		if err != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
		}
		queries := url.Values{}
		target := &url.URL{
			Scheme:   e.scheme,
			Host:     instance,
			Path:     path.Path,
			RawQuery: queries.Encode(),
		}
		r, err := http.NewRequestWithContext(ctx, "POST", target.String(), body)
		if err != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
		}
		r.Header.Set("Content-Type", contentType)
		return r, nil
	}
}
func (e libraryServiceHttpClientRequestEncoder) CreateBook(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Message("request is nil"))
		}
		req, ok := obj.(*CreateBookRequest)
		if !ok {
			return nil, statusx.ErrInvalidArgument.With(statusx.Message("invalid request type, %T", obj))
		}
		_ = req
		var body io.Reader
		var bodyBuf bytes.Buffer
		if err := jsonx.NewEncoder(&bodyBuf).Encode(req.GetBook()); err != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
		}
		body = &bodyBuf
		contentType := "application/json; charset=utf-8"
		var pairs []string
		namedPathParameter := req.GetParent()
		namedPathValues := strings.Split(namedPathParameter, "/")
		if len(namedPathValues) != 2 {
			return nil, statusx.ErrInvalidArgument.With(statusx.Message("invalid named path parameter, %s", namedPathParameter))
		}
		pairs = append(pairs, "shelf", namedPathValues[1])
		path, err := e.router.Get("/google.example.library.v1.LibraryService/CreateBook").URLPath(pairs...)
		if err != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
		}
		queries := url.Values{}
		target := &url.URL{
			Scheme:   e.scheme,
			Host:     instance,
			Path:     path.Path,
			RawQuery: queries.Encode(),
		}
		r, err := http.NewRequestWithContext(ctx, "POST", target.String(), body)
		if err != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
		}
		r.Header.Set("Content-Type", contentType)
		return r, nil
	}
}
func (e libraryServiceHttpClientRequestEncoder) GetBook(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Message("request is nil"))
		}
		req, ok := obj.(*GetBookRequest)
		if !ok {
			return nil, statusx.ErrInvalidArgument.With(statusx.Message("invalid request type, %T", obj))
		}
		_ = req
		var body io.Reader
		var pairs []string
		namedPathParameter := req.GetName()
		namedPathValues := strings.Split(namedPathParameter, "/")
		if len(namedPathValues) != 4 {
			return nil, statusx.ErrInvalidArgument.With(statusx.Message("invalid named path parameter, %s", namedPathParameter))
		}
		pairs = append(pairs, "shelf", namedPathValues[1], "book", namedPathValues[3])
		path, err := e.router.Get("/google.example.library.v1.LibraryService/GetBook").URLPath(pairs...)
		if err != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
		}
		queries := url.Values{}
		target := &url.URL{
			Scheme:   e.scheme,
			Host:     instance,
			Path:     path.Path,
			RawQuery: queries.Encode(),
		}
		r, err := http.NewRequestWithContext(ctx, "GET", target.String(), body)
		if err != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
		}
		return r, nil
	}
}
func (e libraryServiceHttpClientRequestEncoder) ListBooks(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Message("request is nil"))
		}
		req, ok := obj.(*ListBooksRequest)
		if !ok {
			return nil, statusx.ErrInvalidArgument.With(statusx.Message("invalid request type, %T", obj))
		}
		_ = req
		var body io.Reader
		var pairs []string
		namedPathParameter := req.GetParent()
		namedPathValues := strings.Split(namedPathParameter, "/")
		if len(namedPathValues) != 2 {
			return nil, statusx.ErrInvalidArgument.With(statusx.Message("invalid named path parameter, %s", namedPathParameter))
		}
		pairs = append(pairs, "shelf", namedPathValues[1])
		path, err := e.router.Get("/google.example.library.v1.LibraryService/ListBooks").URLPath(pairs...)
		if err != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
		}
		queries := url.Values{}
		queries["page_size"] = append(queries["page_size"], strconvx.FormatInt(req.GetPageSize(), 10))
		queries["page_token"] = append(queries["page_token"], req.GetPageToken())
		target := &url.URL{
			Scheme:   e.scheme,
			Host:     instance,
			Path:     path.Path,
			RawQuery: queries.Encode(),
		}
		r, err := http.NewRequestWithContext(ctx, "GET", target.String(), body)
		if err != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
		}
		return r, nil
	}
}
func (e libraryServiceHttpClientRequestEncoder) DeleteBook(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Message("request is nil"))
		}
		req, ok := obj.(*DeleteBookRequest)
		if !ok {
			return nil, statusx.ErrInvalidArgument.With(statusx.Message("invalid request type, %T", obj))
		}
		_ = req
		var body io.Reader
		var pairs []string
		namedPathParameter := req.GetName()
		namedPathValues := strings.Split(namedPathParameter, "/")
		if len(namedPathValues) != 4 {
			return nil, statusx.ErrInvalidArgument.With(statusx.Message("invalid named path parameter, %s", namedPathParameter))
		}
		pairs = append(pairs, "shelf", namedPathValues[1], "book", namedPathValues[3])
		path, err := e.router.Get("/google.example.library.v1.LibraryService/DeleteBook").URLPath(pairs...)
		if err != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
		}
		queries := url.Values{}
		target := &url.URL{
			Scheme:   e.scheme,
			Host:     instance,
			Path:     path.Path,
			RawQuery: queries.Encode(),
		}
		r, err := http.NewRequestWithContext(ctx, "DELETE", target.String(), body)
		if err != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
		}
		return r, nil
	}
}
func (e libraryServiceHttpClientRequestEncoder) UpdateBook(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Message("request is nil"))
		}
		req, ok := obj.(*UpdateBookRequest)
		if !ok {
			return nil, statusx.ErrInvalidArgument.With(statusx.Message("invalid request type, %T", obj))
		}
		_ = req
		var body io.Reader
		var bodyBuf bytes.Buffer
		if err := jsonx.NewEncoder(&bodyBuf).Encode(req.GetBook()); err != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
		}
		body = &bodyBuf
		contentType := "application/json; charset=utf-8"
		var pairs []string
		namedPathParameter := req.GetBook().GetName()
		namedPathValues := strings.Split(namedPathParameter, "/")
		if len(namedPathValues) != 4 {
			return nil, statusx.ErrInvalidArgument.With(statusx.Message("invalid named path parameter, %s", namedPathParameter))
		}
		pairs = append(pairs, "shelf", namedPathValues[1], "book", namedPathValues[3])
		path, err := e.router.Get("/google.example.library.v1.LibraryService/UpdateBook").URLPath(pairs...)
		if err != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
		}
		queries := url.Values{}
		target := &url.URL{
			Scheme:   e.scheme,
			Host:     instance,
			Path:     path.Path,
			RawQuery: queries.Encode(),
		}
		r, err := http.NewRequestWithContext(ctx, "PATCH", target.String(), body)
		if err != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
		}
		r.Header.Set("Content-Type", contentType)
		return r, nil
	}
}
func (e libraryServiceHttpClientRequestEncoder) MoveBook(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Message("request is nil"))
		}
		req, ok := obj.(*MoveBookRequest)
		if !ok {
			return nil, statusx.ErrInvalidArgument.With(statusx.Message("invalid request type, %T", obj))
		}
		_ = req
		var body io.Reader
		var bodyBuf bytes.Buffer
		if err := jsonx.NewEncoder(&bodyBuf).Encode(req); err != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
		}
		body = &bodyBuf
		contentType := "application/json; charset=utf-8"
		var pairs []string
		namedPathParameter := req.GetName()
		namedPathValues := strings.Split(namedPathParameter, "/")
		if len(namedPathValues) != 4 {
			return nil, statusx.ErrInvalidArgument.With(statusx.Message("invalid named path parameter, %s", namedPathParameter))
		}
		pairs = append(pairs, "shelf", namedPathValues[1], "book", namedPathValues[3])
		path, err := e.router.Get("/google.example.library.v1.LibraryService/MoveBook").URLPath(pairs...)
		if err != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
		}
		queries := url.Values{}
		target := &url.URL{
			Scheme:   e.scheme,
			Host:     instance,
			Path:     path.Path,
			RawQuery: queries.Encode(),
		}
		r, err := http.NewRequestWithContext(ctx, "POST", target.String(), body)
		if err != nil {
			return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
		}
		r.Header.Set("Content-Type", contentType)
		return r, nil
	}
}

type libraryServiceHttpClientResponseDecoder struct{}

func (libraryServiceHttpClientResponseDecoder) CreateShelf() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if httpx.IsErrorResponse(r) {
			return nil, httpx.ErrorDecoder(ctx, r)
		}
		resp := &Shelf{}
		if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
			return nil, err
		}
		return resp, nil
	}
}
func (libraryServiceHttpClientResponseDecoder) GetShelf() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if httpx.IsErrorResponse(r) {
			return nil, httpx.ErrorDecoder(ctx, r)
		}
		resp := &Shelf{}
		if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
			return nil, err
		}
		return resp, nil
	}
}
func (libraryServiceHttpClientResponseDecoder) ListShelves() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if httpx.IsErrorResponse(r) {
			return nil, httpx.ErrorDecoder(ctx, r)
		}
		resp := &ListShelvesResponse{}
		if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
			return nil, err
		}
		return resp, nil
	}
}
func (libraryServiceHttpClientResponseDecoder) DeleteShelf() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if httpx.IsErrorResponse(r) {
			return nil, httpx.ErrorDecoder(ctx, r)
		}
		resp := &emptypb.Empty{}
		if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
			return nil, err
		}
		return resp, nil
	}
}
func (libraryServiceHttpClientResponseDecoder) MergeShelves() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if httpx.IsErrorResponse(r) {
			return nil, httpx.ErrorDecoder(ctx, r)
		}
		resp := &Shelf{}
		if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
			return nil, err
		}
		return resp, nil
	}
}
func (libraryServiceHttpClientResponseDecoder) CreateBook() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if httpx.IsErrorResponse(r) {
			return nil, httpx.ErrorDecoder(ctx, r)
		}
		resp := &Book{}
		if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
			return nil, err
		}
		return resp, nil
	}
}
func (libraryServiceHttpClientResponseDecoder) GetBook() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if httpx.IsErrorResponse(r) {
			return nil, httpx.ErrorDecoder(ctx, r)
		}
		resp := &Book{}
		if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
			return nil, err
		}
		return resp, nil
	}
}
func (libraryServiceHttpClientResponseDecoder) ListBooks() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if httpx.IsErrorResponse(r) {
			return nil, httpx.ErrorDecoder(ctx, r)
		}
		resp := &ListBooksResponse{}
		if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
			return nil, err
		}
		return resp, nil
	}
}
func (libraryServiceHttpClientResponseDecoder) DeleteBook() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if httpx.IsErrorResponse(r) {
			return nil, httpx.ErrorDecoder(ctx, r)
		}
		resp := &emptypb.Empty{}
		if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
			return nil, err
		}
		return resp, nil
	}
}
func (libraryServiceHttpClientResponseDecoder) UpdateBook() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if httpx.IsErrorResponse(r) {
			return nil, httpx.ErrorDecoder(ctx, r)
		}
		resp := &Book{}
		if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
			return nil, err
		}
		return resp, nil
	}
}
func (libraryServiceHttpClientResponseDecoder) MoveBook() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if httpx.IsErrorResponse(r) {
			return nil, httpx.ErrorDecoder(ctx, r)
		}
		resp := &Book{}
		if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
			return nil, err
		}
		return resp, nil
	}
}
