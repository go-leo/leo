// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package path

import (
	context "context"
	fmt "fmt"
	endpoint "github.com/go-kit/kit/endpoint"
	http "github.com/go-kit/kit/transport/http"
	endpointx "github.com/go-leo/leo/v3/endpointx"
	mux "github.com/gorilla/mux"
	protojson "google.golang.org/protobuf/encoding/protojson"
	proto "google.golang.org/protobuf/proto"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	io "io"
	http1 "net/http"
	strings "strings"
)

func NewPathHTTPServer(
	endpoints interface {
		String() endpoint.Endpoint
		OptString() endpoint.Endpoint
		WrapString() endpoint.Endpoint
		EmbedString() endpoint.Endpoint
		EmbedOptString() endpoint.Endpoint
		EmbedWrapString() endpoint.Endpoint
	},
	mdw []endpoint.Middleware,
	opts ...http.ServerOption,
) http1.Handler {
	router := mux.NewRouter()
	router.NewRoute().
		Name("/leo.example.demo.v1.Path/String").
		Methods("GET").
		Path("/v1/string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}").
		Handler(http.NewServer(
			endpointx.Chain(endpoints.String(), mdw...),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &NamedPathRequest{}
				vars := mux.Vars(r)
				req.String_ = fmt.Sprintf("classes/%s/shelves/%s/books/%s/families/%s", vars["class"], vars["shelf"], vars["book"], vars["family"])
				queries := r.URL.Query()
				req.OptString = proto.String(queries.Get("opt_string"))
				req.WrapString = wrapperspb.String(queries.Get("wrap_string"))
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*emptypb.Empty)
				_ = resp
				w.WriteHeader(http1.StatusOK)
				data, err := protojson.Marshal(resp)
				if err != nil {
					return err
				}
				if _, err := w.Write(data); err != nil {
					return err
				}
				return nil
			},
			opts...,
		))
	router.NewRoute().
		Name("/leo.example.demo.v1.Path/OptString").
		Methods("GET").
		Path("/v1/opt_string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}").
		Handler(http.NewServer(
			endpointx.Chain(endpoints.OptString(), mdw...),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &NamedPathRequest{}
				vars := mux.Vars(r)
				req.OptString = proto.String(fmt.Sprintf("classes/%s/shelves/%s/books/%s/families/%s", vars["class"], vars["shelf"], vars["book"], vars["family"]))
				queries := r.URL.Query()
				req.String_ = queries.Get("string")
				req.WrapString = wrapperspb.String(queries.Get("wrap_string"))
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*emptypb.Empty)
				_ = resp
				w.WriteHeader(http1.StatusOK)
				data, err := protojson.Marshal(resp)
				if err != nil {
					return err
				}
				if _, err := w.Write(data); err != nil {
					return err
				}
				return nil
			},
			opts...,
		))
	router.NewRoute().
		Name("/leo.example.demo.v1.Path/WrapString").
		Methods("GET").
		Path("/v1/wrap_string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}").
		Handler(http.NewServer(
			endpointx.Chain(endpoints.WrapString(), mdw...),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &NamedPathRequest{}
				vars := mux.Vars(r)
				req.WrapString = wrapperspb.String(fmt.Sprintf("classes/%s/shelves/%s/books/%s/families/%s", vars["class"], vars["shelf"], vars["book"], vars["family"]))
				queries := r.URL.Query()
				req.String_ = queries.Get("string")
				req.OptString = proto.String(queries.Get("opt_string"))
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*emptypb.Empty)
				_ = resp
				w.WriteHeader(http1.StatusOK)
				data, err := protojson.Marshal(resp)
				if err != nil {
					return err
				}
				if _, err := w.Write(data); err != nil {
					return err
				}
				return nil
			},
			opts...,
		))
	router.NewRoute().
		Name("/leo.example.demo.v1.Path/EmbedString").
		Methods("GET").
		Path("/v1/embed/string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}").
		Handler(http.NewServer(
			endpointx.Chain(endpoints.EmbedString(), mdw...),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &EmbedNamedPathRequest{}
				vars := mux.Vars(r)
				if req.Embed == nil {
					req.Embed = &NamedPathRequest{}
				}
				req.Embed.String_ = fmt.Sprintf("classes/%s/shelves/%s/books/%s/families/%s", vars["class"], vars["shelf"], vars["book"], vars["family"])
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*emptypb.Empty)
				_ = resp
				w.WriteHeader(http1.StatusOK)
				data, err := protojson.Marshal(resp)
				if err != nil {
					return err
				}
				if _, err := w.Write(data); err != nil {
					return err
				}
				return nil
			},
			opts...,
		))
	router.NewRoute().
		Name("/leo.example.demo.v1.Path/EmbedOptString").
		Methods("GET").
		Path("/v1/embed/opt_string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}").
		Handler(http.NewServer(
			endpointx.Chain(endpoints.EmbedOptString(), mdw...),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &EmbedNamedPathRequest{}
				vars := mux.Vars(r)
				if req.Embed == nil {
					req.Embed = &NamedPathRequest{}
				}
				req.Embed.OptString = proto.String(fmt.Sprintf("classes/%s/shelves/%s/books/%s/families/%s", vars["class"], vars["shelf"], vars["book"], vars["family"]))
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*emptypb.Empty)
				_ = resp
				w.WriteHeader(http1.StatusOK)
				data, err := protojson.Marshal(resp)
				if err != nil {
					return err
				}
				if _, err := w.Write(data); err != nil {
					return err
				}
				return nil
			},
			opts...,
		))
	router.NewRoute().
		Name("/leo.example.demo.v1.Path/EmbedWrapString").
		Methods("GET").
		Path("/v1/embed/wrap_string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}").
		Handler(http.NewServer(
			endpointx.Chain(endpoints.EmbedWrapString(), mdw...),
			func(ctx context.Context, r *http1.Request) (any, error) {
				req := &EmbedNamedPathRequest{}
				vars := mux.Vars(r)
				if req.Embed == nil {
					req.Embed = &NamedPathRequest{}
				}
				req.Embed.WrapString = wrapperspb.String(fmt.Sprintf("classes/%s/shelves/%s/books/%s/families/%s", vars["class"], vars["shelf"], vars["book"], vars["family"]))
				return req, nil
			},
			func(ctx context.Context, w http1.ResponseWriter, obj any) error {
				resp := obj.(*emptypb.Empty)
				_ = resp
				w.WriteHeader(http1.StatusOK)
				data, err := protojson.Marshal(resp)
				if err != nil {
					return err
				}
				if _, err := w.Write(data); err != nil {
					return err
				}
				return nil
			},
			opts...,
		))
	return router
}

type httpPathClient struct {
	string          endpoint.Endpoint
	optString       endpoint.Endpoint
	wrapString      endpoint.Endpoint
	embedString     endpoint.Endpoint
	embedOptString  endpoint.Endpoint
	embedWrapString endpoint.Endpoint
}

func (c *httpPathClient) String(ctx context.Context, request *NamedPathRequest) (*emptypb.Empty, error) {
	rep, err := c.string(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpPathClient) OptString(ctx context.Context, request *NamedPathRequest) (*emptypb.Empty, error) {
	rep, err := c.optString(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpPathClient) WrapString(ctx context.Context, request *NamedPathRequest) (*emptypb.Empty, error) {
	rep, err := c.wrapString(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpPathClient) EmbedString(ctx context.Context, request *EmbedNamedPathRequest) (*emptypb.Empty, error) {
	rep, err := c.embedString(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpPathClient) EmbedOptString(ctx context.Context, request *EmbedNamedPathRequest) (*emptypb.Empty, error) {
	rep, err := c.embedOptString(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpPathClient) EmbedWrapString(ctx context.Context, request *EmbedNamedPathRequest) (*emptypb.Empty, error) {
	rep, err := c.embedWrapString(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func NewPathHTTPClient(
	instance string,
	mdw []endpoint.Middleware,
	opts ...http.ClientOption,
) interface {
	String(ctx context.Context, request *NamedPathRequest) (*emptypb.Empty, error)
	OptString(ctx context.Context, request *NamedPathRequest) (*emptypb.Empty, error)
	WrapString(ctx context.Context, request *NamedPathRequest) (*emptypb.Empty, error)
	EmbedString(ctx context.Context, request *EmbedNamedPathRequest) (*emptypb.Empty, error)
	EmbedOptString(ctx context.Context, request *EmbedNamedPathRequest) (*emptypb.Empty, error)
	EmbedWrapString(ctx context.Context, request *EmbedNamedPathRequest) (*emptypb.Empty, error)
} {
	router := mux.NewRouter()
	router.NewRoute().
		Name("/leo.example.demo.v1.Path/String").
		Methods("GET").
		Path("/v1/string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}")
	router.NewRoute().
		Name("/leo.example.demo.v1.Path/OptString").
		Methods("GET").
		Path("/v1/opt_string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}")
	router.NewRoute().
		Name("/leo.example.demo.v1.Path/WrapString").
		Methods("GET").
		Path("/v1/wrap_string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}")
	router.NewRoute().
		Name("/leo.example.demo.v1.Path/EmbedString").
		Methods("GET").
		Path("/v1/embed/string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}")
	router.NewRoute().
		Name("/leo.example.demo.v1.Path/EmbedOptString").
		Methods("GET").
		Path("/v1/embed/opt_string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}")
	router.NewRoute().
		Name("/leo.example.demo.v1.Path/EmbedWrapString").
		Methods("GET").
		Path("/v1/embed/wrap_string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}")
	return &httpPathClient{
		string: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					req, ok := obj.(*NamedPathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, fmt.Errorf("request object is nil")
					}
					var method = "GET"
					var url string
					var body io.Reader
					var pairs []string
					// string
					// classes/%s/shelves/%s/books/%s/families/%s
					// class.shelf.book.family
					namedPathParameter := req.String_
					namedPathValues := strings.Split(namedPathParameter, "/")
					if len(namedPathValues) != 8 {
						return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
					}
					pairs = append(pairs, "class", namedPathValues[1], "shelf", namedPathValues[3], "book", namedPathValues[5], "family", namedPathValues[7])
					path, err := router.Get("/leo.example.demo.v1.Path/String").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http1.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		optString: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					req, ok := obj.(*NamedPathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, fmt.Errorf("request object is nil")
					}
					var method = "GET"
					var url string
					var body io.Reader
					var pairs []string
					// opt_string
					// classes/%s/shelves/%s/books/%s/families/%s
					// class.shelf.book.family
					namedPathParameter := *req.OptString
					namedPathValues := strings.Split(namedPathParameter, "/")
					if len(namedPathValues) != 8 {
						return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
					}
					pairs = append(pairs, "class", namedPathValues[1], "shelf", namedPathValues[3], "book", namedPathValues[5], "family", namedPathValues[7])
					path, err := router.Get("/leo.example.demo.v1.Path/OptString").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http1.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		wrapString: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					req, ok := obj.(*NamedPathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, fmt.Errorf("request object is nil")
					}
					var method = "GET"
					var url string
					var body io.Reader
					var pairs []string
					// wrap_string
					// classes/%s/shelves/%s/books/%s/families/%s
					// class.shelf.book.family
					namedPathParameter := req.WrapString.Value
					namedPathValues := strings.Split(namedPathParameter, "/")
					if len(namedPathValues) != 8 {
						return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
					}
					pairs = append(pairs, "class", namedPathValues[1], "shelf", namedPathValues[3], "book", namedPathValues[5], "family", namedPathValues[7])
					path, err := router.Get("/leo.example.demo.v1.Path/WrapString").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http1.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		embedString: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					req, ok := obj.(*EmbedNamedPathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, fmt.Errorf("request object is nil")
					}
					var method = "GET"
					var url string
					var body io.Reader
					var pairs []string
					if req.Embed == nil {
						return nil, fmt.Errorf("%s is nil", "req.Embed")
					}
					// embed.string
					// classes/%s/shelves/%s/books/%s/families/%s
					// class.shelf.book.family
					namedPathParameter := req.Embed.String_
					namedPathValues := strings.Split(namedPathParameter, "/")
					if len(namedPathValues) != 8 {
						return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
					}
					pairs = append(pairs, "class", namedPathValues[1], "shelf", namedPathValues[3], "book", namedPathValues[5], "family", namedPathValues[7])
					path, err := router.Get("/leo.example.demo.v1.Path/EmbedString").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http1.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		embedOptString: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					req, ok := obj.(*EmbedNamedPathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, fmt.Errorf("request object is nil")
					}
					var method = "GET"
					var url string
					var body io.Reader
					var pairs []string
					if req.Embed == nil {
						return nil, fmt.Errorf("%s is nil", "req.Embed")
					}
					// embed.opt_string
					// classes/%s/shelves/%s/books/%s/families/%s
					// class.shelf.book.family
					namedPathParameter := *req.Embed.OptString
					namedPathValues := strings.Split(namedPathParameter, "/")
					if len(namedPathValues) != 8 {
						return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
					}
					pairs = append(pairs, "class", namedPathValues[1], "shelf", namedPathValues[3], "book", namedPathValues[5], "family", namedPathValues[7])
					path, err := router.Get("/leo.example.demo.v1.Path/EmbedOptString").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http1.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		embedWrapString: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					req, ok := obj.(*EmbedNamedPathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, fmt.Errorf("request object is nil")
					}
					var method = "GET"
					var url string
					var body io.Reader
					var pairs []string
					if req.Embed == nil {
						return nil, fmt.Errorf("%s is nil", "req.Embed")
					}
					// embed.wrap_string
					// classes/%s/shelves/%s/books/%s/families/%s
					// class.shelf.book.family
					namedPathParameter := req.Embed.WrapString.Value
					namedPathValues := strings.Split(namedPathParameter, "/")
					if len(namedPathValues) != 8 {
						return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
					}
					pairs = append(pairs, "class", namedPathValues[1], "shelf", namedPathValues[3], "book", namedPathValues[5], "family", namedPathValues[7])
					path, err := router.Get("/leo.example.demo.v1.Path/EmbedWrapString").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http1.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
	}
}
