// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package path

import (
	context "context"
	errors "errors"
	fmt "fmt"
	endpoint "github.com/go-kit/kit/endpoint"
	http "github.com/go-kit/kit/transport/http"
	endpointx "github.com/go-leo/leo/v3/endpointx"
	mux "github.com/gorilla/mux"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	io "io"
	http1 "net/http"
	url "net/url"
	strconv "strconv"
	strings "strings"
)

type pathHTTPClient struct {
	namedPathString          endpoint.Endpoint
	namedPathOptString       endpoint.Endpoint
	namedPathWrapString      endpoint.Endpoint
	embedNamedPathString     endpoint.Endpoint
	embedNamedPathOptString  endpoint.Endpoint
	embedNamedPathWrapString endpoint.Endpoint
	boolPath                 endpoint.Endpoint
	int32Path                endpoint.Endpoint
	int64Path                endpoint.Endpoint
	uint32Path               endpoint.Endpoint
	uint64Path               endpoint.Endpoint
	floatPath                endpoint.Endpoint
	doublePath               endpoint.Endpoint
	stringPath               endpoint.Endpoint
	enumPath                 endpoint.Endpoint
	mixPath                  endpoint.Endpoint
}

func (c *pathHTTPClient) NamedPathString(ctx context.Context, request *NamedPathRequest) (*emptypb.Empty, error) {
	rep, err := c.namedPathString(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *pathHTTPClient) NamedPathOptString(ctx context.Context, request *NamedPathRequest) (*emptypb.Empty, error) {
	rep, err := c.namedPathOptString(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *pathHTTPClient) NamedPathWrapString(ctx context.Context, request *NamedPathRequest) (*emptypb.Empty, error) {
	rep, err := c.namedPathWrapString(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *pathHTTPClient) EmbedNamedPathString(ctx context.Context, request *EmbedNamedPathRequest) (*emptypb.Empty, error) {
	rep, err := c.embedNamedPathString(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *pathHTTPClient) EmbedNamedPathOptString(ctx context.Context, request *EmbedNamedPathRequest) (*emptypb.Empty, error) {
	rep, err := c.embedNamedPathOptString(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *pathHTTPClient) EmbedNamedPathWrapString(ctx context.Context, request *EmbedNamedPathRequest) (*emptypb.Empty, error) {
	rep, err := c.embedNamedPathWrapString(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *pathHTTPClient) BoolPath(ctx context.Context, request *PathRequest) (*emptypb.Empty, error) {
	rep, err := c.boolPath(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *pathHTTPClient) Int32Path(ctx context.Context, request *PathRequest) (*emptypb.Empty, error) {
	rep, err := c.int32Path(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *pathHTTPClient) Int64Path(ctx context.Context, request *PathRequest) (*emptypb.Empty, error) {
	rep, err := c.int64Path(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *pathHTTPClient) Uint32Path(ctx context.Context, request *PathRequest) (*emptypb.Empty, error) {
	rep, err := c.uint32Path(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *pathHTTPClient) Uint64Path(ctx context.Context, request *PathRequest) (*emptypb.Empty, error) {
	rep, err := c.uint64Path(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *pathHTTPClient) FloatPath(ctx context.Context, request *PathRequest) (*emptypb.Empty, error) {
	rep, err := c.floatPath(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *pathHTTPClient) DoublePath(ctx context.Context, request *PathRequest) (*emptypb.Empty, error) {
	rep, err := c.doublePath(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *pathHTTPClient) StringPath(ctx context.Context, request *PathRequest) (*emptypb.Empty, error) {
	rep, err := c.stringPath(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *pathHTTPClient) EnumPath(ctx context.Context, request *PathRequest) (*emptypb.Empty, error) {
	rep, err := c.enumPath(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *pathHTTPClient) MixPath(ctx context.Context, request *MixPathRequest) (*emptypb.Empty, error) {
	rep, err := c.mixPath(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func NewPathHTTPClient(
	scheme string,
	instance string,
	mdw []endpoint.Middleware,
	opts ...http.ClientOption,
) interface {
	NamedPathString(ctx context.Context, request *NamedPathRequest) (*emptypb.Empty, error)
	NamedPathOptString(ctx context.Context, request *NamedPathRequest) (*emptypb.Empty, error)
	NamedPathWrapString(ctx context.Context, request *NamedPathRequest) (*emptypb.Empty, error)
	EmbedNamedPathString(ctx context.Context, request *EmbedNamedPathRequest) (*emptypb.Empty, error)
	EmbedNamedPathOptString(ctx context.Context, request *EmbedNamedPathRequest) (*emptypb.Empty, error)
	EmbedNamedPathWrapString(ctx context.Context, request *EmbedNamedPathRequest) (*emptypb.Empty, error)
	BoolPath(ctx context.Context, request *PathRequest) (*emptypb.Empty, error)
	Int32Path(ctx context.Context, request *PathRequest) (*emptypb.Empty, error)
	Int64Path(ctx context.Context, request *PathRequest) (*emptypb.Empty, error)
	Uint32Path(ctx context.Context, request *PathRequest) (*emptypb.Empty, error)
	Uint64Path(ctx context.Context, request *PathRequest) (*emptypb.Empty, error)
	FloatPath(ctx context.Context, request *PathRequest) (*emptypb.Empty, error)
	DoublePath(ctx context.Context, request *PathRequest) (*emptypb.Empty, error)
	StringPath(ctx context.Context, request *PathRequest) (*emptypb.Empty, error)
	EnumPath(ctx context.Context, request *PathRequest) (*emptypb.Empty, error)
	MixPath(ctx context.Context, request *MixPathRequest) (*emptypb.Empty, error)
} {
	router := mux.NewRouter()
	router.NewRoute().
		Name("/leo.example.path.v1.Path/NamedPathString").
		Methods("GET").
		Path("/v1/string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}")
	router.NewRoute().
		Name("/leo.example.path.v1.Path/NamedPathOptString").
		Methods("GET").
		Path("/v1/opt_string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}")
	router.NewRoute().
		Name("/leo.example.path.v1.Path/NamedPathWrapString").
		Methods("GET").
		Path("/v1/wrap_string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}")
	router.NewRoute().
		Name("/leo.example.path.v1.Path/EmbedNamedPathString").
		Methods("GET").
		Path("/v1/embed/string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}")
	router.NewRoute().
		Name("/leo.example.path.v1.Path/EmbedNamedPathOptString").
		Methods("GET").
		Path("/v1/embed/opt_string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}")
	router.NewRoute().
		Name("/leo.example.path.v1.Path/EmbedNamedPathWrapString").
		Methods("GET").
		Path("/v1/embed/wrap_string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}")
	router.NewRoute().
		Name("/leo.example.path.v1.Path/BoolPath").
		Methods("GET").
		Path("/v1/{bool}/{opt_bool}/{wrap_bool}")
	router.NewRoute().
		Name("/leo.example.path.v1.Path/Int32Path").
		Methods("GET").
		Path("/v1/{int32}/{sint32}/{sfixed32}/{opt_int32}/{opt_sint32}/{opt_sfixed32}/{wrap_int32}")
	router.NewRoute().
		Name("/leo.example.path.v1.Path/Int64Path").
		Methods("GET").
		Path("/v1/{int64}/{sint64}/{sfixed64}/{opt_int64}/{opt_sint64}/{opt_sfixed64}/{wrap_int64}")
	router.NewRoute().
		Name("/leo.example.path.v1.Path/Uint32Path").
		Methods("GET").
		Path("/v1/{uint32}/{fixed32}/{opt_uint32}/{opt_fixed32}/{wrap_uint32}")
	router.NewRoute().
		Name("/leo.example.path.v1.Path/Uint64Path").
		Methods("GET").
		Path("/v1/{uint64}/{fixed64}/{opt_uint64}/{opt_fixed64}/{wrap_uint64}")
	router.NewRoute().
		Name("/leo.example.path.v1.Path/FloatPath").
		Methods("GET").
		Path("/v1/{float}/{opt_float}/{wrap_float}")
	router.NewRoute().
		Name("/leo.example.path.v1.Path/DoublePath").
		Methods("GET").
		Path("/v1/{double}/{opt_double}/{wrap_double}")
	router.NewRoute().
		Name("/leo.example.path.v1.Path/StringPath").
		Methods("GET").
		Path("/v1/{string}/{opt_string}/{wrap_string}")
	router.NewRoute().
		Name("/leo.example.path.v1.Path/EnumPath").
		Methods("GET").
		Path("/v1/{status}/{opt_status}")
	router.NewRoute().
		Name("/leo.example.path.v1.Path/MixPath").
		Methods("GET").
		Path("/v1/{string}/{opt_string}/{wrap_string}/classes/{class}/shelves/{shelf}/books/{book}/families/{family}")
	return &pathHTTPClient{
		namedPathString: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					if obj == nil {
						return nil, errors.New("request object is nil")
					}
					req, ok := obj.(*NamedPathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					_ = req
					var body io.Reader
					var pairs []string
					namedPathParameter := req.String_
					namedPathValues := strings.Split(namedPathParameter, "/")
					if len(namedPathValues) != 8 {
						return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
					}
					pairs = append(pairs, "class", namedPathValues[1], "shelf", namedPathValues[3], "book", namedPathValues[5], "family", namedPathValues[7])
					path, err := router.Get("/leo.example.path.v1.Path/NamedPathString").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := url.Values{}
					if req.OptString == nil {
						queries.Add("opt_string", *req.OptString)
					}
					if req.WrapString == nil {
						queries.Add("wrap_string", req.WrapString.Value)
					}
					target := &url.URL{
						Scheme:   scheme,
						Host:     instance,
						Path:     path.Path,
						RawQuery: queries.Encode(),
					}
					r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		namedPathOptString: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					if obj == nil {
						return nil, errors.New("request object is nil")
					}
					req, ok := obj.(*NamedPathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					_ = req
					var body io.Reader
					var pairs []string
					namedPathParameter := *req.OptString
					namedPathValues := strings.Split(namedPathParameter, "/")
					if len(namedPathValues) != 8 {
						return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
					}
					pairs = append(pairs, "class", namedPathValues[1], "shelf", namedPathValues[3], "book", namedPathValues[5], "family", namedPathValues[7])
					path, err := router.Get("/leo.example.path.v1.Path/NamedPathOptString").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := url.Values{}
					queries.Add("string", req.String_)
					if req.WrapString == nil {
						queries.Add("wrap_string", req.WrapString.Value)
					}
					target := &url.URL{
						Scheme:   scheme,
						Host:     instance,
						Path:     path.Path,
						RawQuery: queries.Encode(),
					}
					r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		namedPathWrapString: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					if obj == nil {
						return nil, errors.New("request object is nil")
					}
					req, ok := obj.(*NamedPathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					_ = req
					var body io.Reader
					var pairs []string
					namedPathParameter := req.WrapString.Value
					namedPathValues := strings.Split(namedPathParameter, "/")
					if len(namedPathValues) != 8 {
						return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
					}
					pairs = append(pairs, "class", namedPathValues[1], "shelf", namedPathValues[3], "book", namedPathValues[5], "family", namedPathValues[7])
					path, err := router.Get("/leo.example.path.v1.Path/NamedPathWrapString").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := url.Values{}
					queries.Add("string", req.String_)
					if req.OptString == nil {
						queries.Add("opt_string", *req.OptString)
					}
					target := &url.URL{
						Scheme:   scheme,
						Host:     instance,
						Path:     path.Path,
						RawQuery: queries.Encode(),
					}
					r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		embedNamedPathString: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					if obj == nil {
						return nil, errors.New("request object is nil")
					}
					req, ok := obj.(*EmbedNamedPathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					_ = req
					var body io.Reader
					var pairs []string
					if req.Embed == nil {
						return nil, fmt.Errorf("%s is nil", "req.Embed")
					}
					namedPathParameter := req.Embed.String_
					namedPathValues := strings.Split(namedPathParameter, "/")
					if len(namedPathValues) != 8 {
						return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
					}
					pairs = append(pairs, "class", namedPathValues[1], "shelf", namedPathValues[3], "book", namedPathValues[5], "family", namedPathValues[7])
					path, err := router.Get("/leo.example.path.v1.Path/EmbedNamedPathString").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := url.Values{}
					target := &url.URL{
						Scheme:   scheme,
						Host:     instance,
						Path:     path.Path,
						RawQuery: queries.Encode(),
					}
					r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		embedNamedPathOptString: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					if obj == nil {
						return nil, errors.New("request object is nil")
					}
					req, ok := obj.(*EmbedNamedPathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					_ = req
					var body io.Reader
					var pairs []string
					if req.Embed == nil {
						return nil, fmt.Errorf("%s is nil", "req.Embed")
					}
					namedPathParameter := *req.Embed.OptString
					namedPathValues := strings.Split(namedPathParameter, "/")
					if len(namedPathValues) != 8 {
						return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
					}
					pairs = append(pairs, "class", namedPathValues[1], "shelf", namedPathValues[3], "book", namedPathValues[5], "family", namedPathValues[7])
					path, err := router.Get("/leo.example.path.v1.Path/EmbedNamedPathOptString").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := url.Values{}
					target := &url.URL{
						Scheme:   scheme,
						Host:     instance,
						Path:     path.Path,
						RawQuery: queries.Encode(),
					}
					r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		embedNamedPathWrapString: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					if obj == nil {
						return nil, errors.New("request object is nil")
					}
					req, ok := obj.(*EmbedNamedPathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					_ = req
					var body io.Reader
					var pairs []string
					if req.Embed == nil {
						return nil, fmt.Errorf("%s is nil", "req.Embed")
					}
					namedPathParameter := req.Embed.WrapString.Value
					namedPathValues := strings.Split(namedPathParameter, "/")
					if len(namedPathValues) != 8 {
						return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
					}
					pairs = append(pairs, "class", namedPathValues[1], "shelf", namedPathValues[3], "book", namedPathValues[5], "family", namedPathValues[7])
					path, err := router.Get("/leo.example.path.v1.Path/EmbedNamedPathWrapString").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := url.Values{}
					target := &url.URL{
						Scheme:   scheme,
						Host:     instance,
						Path:     path.Path,
						RawQuery: queries.Encode(),
					}
					r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		boolPath: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					if obj == nil {
						return nil, errors.New("request object is nil")
					}
					req, ok := obj.(*PathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					_ = req
					var body io.Reader
					var pairs []string
					if req.OptBool == nil {
						return nil, fmt.Errorf("%s is nil", "req.OptBool")
					}
					if req.WrapBool == nil {
						return nil, fmt.Errorf("%s is nil", "req.WrapBool")
					}
					pairs = append(pairs, "bool", strconv.FormatBool(req.Bool), "opt_bool", strconv.FormatBool(*req.OptBool), "wrap_bool", strconv.FormatBool(req.WrapBool.Value))
					path, err := router.Get("/leo.example.path.v1.Path/BoolPath").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := url.Values{}
					queries.Add("int32", strconv.FormatInt(int64(req.Int32), 10))
					queries.Add("sint32", strconv.FormatInt(int64(req.Sint32), 10))
					queries.Add("sfixed32", strconv.FormatInt(int64(req.Sfixed32), 10))
					if req.OptInt32 == nil {
						queries.Add("opt_int32", strconv.FormatInt(int64(*req.OptInt32), 10))
					}
					if req.OptSint32 == nil {
						queries.Add("opt_sint32", strconv.FormatInt(int64(*req.OptSint32), 10))
					}
					if req.OptSfixed32 == nil {
						queries.Add("opt_sfixed32", strconv.FormatInt(int64(*req.OptSfixed32), 10))
					}
					if req.WrapInt32 == nil {
						queries.Add("wrap_int32", strconv.FormatInt(int64(req.WrapInt32.Value), 10))
					}
					queries.Add("int64", strconv.FormatInt(req.Int64, 10))
					queries.Add("sint64", strconv.FormatInt(req.Sint64, 10))
					queries.Add("sfixed64", strconv.FormatInt(req.Sfixed64, 10))
					if req.OptInt64 == nil {
						queries.Add("opt_int64", strconv.FormatInt(*req.OptInt64, 10))
					}
					if req.OptSint64 == nil {
						queries.Add("opt_sint64", strconv.FormatInt(*req.OptSint64, 10))
					}
					if req.OptSfixed64 == nil {
						queries.Add("opt_sfixed64", strconv.FormatInt(*req.OptSfixed64, 10))
					}
					if req.WrapInt64 == nil {
						queries.Add("wrap_int64", strconv.FormatInt(req.WrapInt64.Value, 10))
					}
					queries.Add("uint32", strconv.FormatUint(uint64(req.Uint32), 10))
					queries.Add("fixed32", strconv.FormatUint(uint64(req.Fixed32), 10))
					if req.OptUint32 == nil {
						queries.Add("opt_uint32", strconv.FormatUint(uint64(*req.OptUint32), 10))
					}
					if req.OptFixed32 == nil {
						queries.Add("opt_fixed32", strconv.FormatUint(uint64(*req.OptFixed32), 10))
					}
					if req.WrapUint32 == nil {
						queries.Add("wrap_uint32", strconv.FormatUint(uint64(req.WrapUint32.Value), 10))
					}
					queries.Add("uint64", strconv.FormatUint(req.Uint64, 10))
					queries.Add("fixed64", strconv.FormatUint(req.Fixed64, 10))
					if req.OptUint64 == nil {
						queries.Add("opt_uint64", strconv.FormatUint(*req.OptUint64, 10))
					}
					if req.OptFixed64 == nil {
						queries.Add("opt_fixed64", strconv.FormatUint(*req.OptFixed64, 10))
					}
					if req.WrapUint64 == nil {
						queries.Add("wrap_uint64", strconv.FormatUint(req.WrapUint64.Value, 10))
					}
					queries.Add("float", strconv.FormatFloat(float64(req.Float), 'f', -1, 32))
					if req.OptFloat == nil {
						queries.Add("opt_float", strconv.FormatFloat(float64(*req.OptFloat), 'f', -1, 32))
					}
					if req.WrapFloat == nil {
						queries.Add("wrap_float", strconv.FormatFloat(float64(req.WrapFloat.Value), 'f', -1, 32))
					}
					queries.Add("double", strconv.FormatFloat(req.Double, 'f', -1, 64))
					if req.OptDouble == nil {
						queries.Add("opt_double", strconv.FormatFloat(*req.OptDouble, 'f', -1, 64))
					}
					if req.WrapDouble == nil {
						queries.Add("wrap_double", strconv.FormatFloat(req.WrapDouble.Value, 'f', -1, 64))
					}
					queries.Add("string", req.String_)
					if req.OptString == nil {
						queries.Add("opt_string", *req.OptString)
					}
					if req.WrapString == nil {
						queries.Add("wrap_string", req.WrapString.Value)
					}
					queries.Add("status", strconv.FormatInt(int64(req.Status), 10))
					if req.OptStatus == nil {
						queries.Add("opt_status", strconv.FormatInt(int64(*req.OptStatus), 10))
					}
					target := &url.URL{
						Scheme:   scheme,
						Host:     instance,
						Path:     path.Path,
						RawQuery: queries.Encode(),
					}
					r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		int32Path: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					if obj == nil {
						return nil, errors.New("request object is nil")
					}
					req, ok := obj.(*PathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					_ = req
					var body io.Reader
					var pairs []string
					if req.OptInt32 == nil {
						return nil, fmt.Errorf("%s is nil", "req.OptInt32")
					}
					if req.OptSint32 == nil {
						return nil, fmt.Errorf("%s is nil", "req.OptSint32")
					}
					if req.OptSfixed32 == nil {
						return nil, fmt.Errorf("%s is nil", "req.OptSfixed32")
					}
					if req.WrapInt32 == nil {
						return nil, fmt.Errorf("%s is nil", "req.WrapInt32")
					}
					pairs = append(pairs, "int32", strconv.FormatInt(int64(req.Int32), 10), "sint32", strconv.FormatInt(int64(req.Sint32), 10), "sfixed32", strconv.FormatInt(int64(req.Sfixed32), 10), "opt_int32", strconv.FormatInt(int64(*req.OptInt32), 10), "opt_sint32", strconv.FormatInt(int64(*req.OptSint32), 10), "opt_sfixed32", strconv.FormatInt(int64(*req.OptSfixed32), 10), "wrap_int32", strconv.FormatInt(int64(req.WrapInt32.Value), 10))
					path, err := router.Get("/leo.example.path.v1.Path/Int32Path").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := url.Values{}
					queries.Add("bool", strconv.FormatBool(req.Bool))
					if req.OptBool == nil {
						queries.Add("opt_bool", strconv.FormatBool(*req.OptBool))
					}
					if req.WrapBool == nil {
						queries.Add("wrap_bool", strconv.FormatBool(req.WrapBool.Value))
					}
					queries.Add("int64", strconv.FormatInt(req.Int64, 10))
					queries.Add("sint64", strconv.FormatInt(req.Sint64, 10))
					queries.Add("sfixed64", strconv.FormatInt(req.Sfixed64, 10))
					if req.OptInt64 == nil {
						queries.Add("opt_int64", strconv.FormatInt(*req.OptInt64, 10))
					}
					if req.OptSint64 == nil {
						queries.Add("opt_sint64", strconv.FormatInt(*req.OptSint64, 10))
					}
					if req.OptSfixed64 == nil {
						queries.Add("opt_sfixed64", strconv.FormatInt(*req.OptSfixed64, 10))
					}
					if req.WrapInt64 == nil {
						queries.Add("wrap_int64", strconv.FormatInt(req.WrapInt64.Value, 10))
					}
					queries.Add("uint32", strconv.FormatUint(uint64(req.Uint32), 10))
					queries.Add("fixed32", strconv.FormatUint(uint64(req.Fixed32), 10))
					if req.OptUint32 == nil {
						queries.Add("opt_uint32", strconv.FormatUint(uint64(*req.OptUint32), 10))
					}
					if req.OptFixed32 == nil {
						queries.Add("opt_fixed32", strconv.FormatUint(uint64(*req.OptFixed32), 10))
					}
					if req.WrapUint32 == nil {
						queries.Add("wrap_uint32", strconv.FormatUint(uint64(req.WrapUint32.Value), 10))
					}
					queries.Add("uint64", strconv.FormatUint(req.Uint64, 10))
					queries.Add("fixed64", strconv.FormatUint(req.Fixed64, 10))
					if req.OptUint64 == nil {
						queries.Add("opt_uint64", strconv.FormatUint(*req.OptUint64, 10))
					}
					if req.OptFixed64 == nil {
						queries.Add("opt_fixed64", strconv.FormatUint(*req.OptFixed64, 10))
					}
					if req.WrapUint64 == nil {
						queries.Add("wrap_uint64", strconv.FormatUint(req.WrapUint64.Value, 10))
					}
					queries.Add("float", strconv.FormatFloat(float64(req.Float), 'f', -1, 32))
					if req.OptFloat == nil {
						queries.Add("opt_float", strconv.FormatFloat(float64(*req.OptFloat), 'f', -1, 32))
					}
					if req.WrapFloat == nil {
						queries.Add("wrap_float", strconv.FormatFloat(float64(req.WrapFloat.Value), 'f', -1, 32))
					}
					queries.Add("double", strconv.FormatFloat(req.Double, 'f', -1, 64))
					if req.OptDouble == nil {
						queries.Add("opt_double", strconv.FormatFloat(*req.OptDouble, 'f', -1, 64))
					}
					if req.WrapDouble == nil {
						queries.Add("wrap_double", strconv.FormatFloat(req.WrapDouble.Value, 'f', -1, 64))
					}
					queries.Add("string", req.String_)
					if req.OptString == nil {
						queries.Add("opt_string", *req.OptString)
					}
					if req.WrapString == nil {
						queries.Add("wrap_string", req.WrapString.Value)
					}
					queries.Add("status", strconv.FormatInt(int64(req.Status), 10))
					if req.OptStatus == nil {
						queries.Add("opt_status", strconv.FormatInt(int64(*req.OptStatus), 10))
					}
					target := &url.URL{
						Scheme:   scheme,
						Host:     instance,
						Path:     path.Path,
						RawQuery: queries.Encode(),
					}
					r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		int64Path: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					if obj == nil {
						return nil, errors.New("request object is nil")
					}
					req, ok := obj.(*PathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					_ = req
					var body io.Reader
					var pairs []string
					if req.OptInt64 == nil {
						return nil, fmt.Errorf("%s is nil", "req.OptInt64")
					}
					if req.OptSint64 == nil {
						return nil, fmt.Errorf("%s is nil", "req.OptSint64")
					}
					if req.OptSfixed64 == nil {
						return nil, fmt.Errorf("%s is nil", "req.OptSfixed64")
					}
					if req.WrapInt64 == nil {
						return nil, fmt.Errorf("%s is nil", "req.WrapInt64")
					}
					pairs = append(pairs, "int64", strconv.FormatInt(req.Int64, 10), "sint64", strconv.FormatInt(req.Sint64, 10), "sfixed64", strconv.FormatInt(req.Sfixed64, 10), "opt_int64", strconv.FormatInt(*req.OptInt64, 10), "opt_sint64", strconv.FormatInt(*req.OptSint64, 10), "opt_sfixed64", strconv.FormatInt(*req.OptSfixed64, 10), "wrap_int64", strconv.FormatInt(req.WrapInt64.Value, 10))
					path, err := router.Get("/leo.example.path.v1.Path/Int64Path").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := url.Values{}
					queries.Add("bool", strconv.FormatBool(req.Bool))
					if req.OptBool == nil {
						queries.Add("opt_bool", strconv.FormatBool(*req.OptBool))
					}
					if req.WrapBool == nil {
						queries.Add("wrap_bool", strconv.FormatBool(req.WrapBool.Value))
					}
					queries.Add("int32", strconv.FormatInt(int64(req.Int32), 10))
					queries.Add("sint32", strconv.FormatInt(int64(req.Sint32), 10))
					queries.Add("sfixed32", strconv.FormatInt(int64(req.Sfixed32), 10))
					if req.OptInt32 == nil {
						queries.Add("opt_int32", strconv.FormatInt(int64(*req.OptInt32), 10))
					}
					if req.OptSint32 == nil {
						queries.Add("opt_sint32", strconv.FormatInt(int64(*req.OptSint32), 10))
					}
					if req.OptSfixed32 == nil {
						queries.Add("opt_sfixed32", strconv.FormatInt(int64(*req.OptSfixed32), 10))
					}
					if req.WrapInt32 == nil {
						queries.Add("wrap_int32", strconv.FormatInt(int64(req.WrapInt32.Value), 10))
					}
					queries.Add("uint32", strconv.FormatUint(uint64(req.Uint32), 10))
					queries.Add("fixed32", strconv.FormatUint(uint64(req.Fixed32), 10))
					if req.OptUint32 == nil {
						queries.Add("opt_uint32", strconv.FormatUint(uint64(*req.OptUint32), 10))
					}
					if req.OptFixed32 == nil {
						queries.Add("opt_fixed32", strconv.FormatUint(uint64(*req.OptFixed32), 10))
					}
					if req.WrapUint32 == nil {
						queries.Add("wrap_uint32", strconv.FormatUint(uint64(req.WrapUint32.Value), 10))
					}
					queries.Add("uint64", strconv.FormatUint(req.Uint64, 10))
					queries.Add("fixed64", strconv.FormatUint(req.Fixed64, 10))
					if req.OptUint64 == nil {
						queries.Add("opt_uint64", strconv.FormatUint(*req.OptUint64, 10))
					}
					if req.OptFixed64 == nil {
						queries.Add("opt_fixed64", strconv.FormatUint(*req.OptFixed64, 10))
					}
					if req.WrapUint64 == nil {
						queries.Add("wrap_uint64", strconv.FormatUint(req.WrapUint64.Value, 10))
					}
					queries.Add("float", strconv.FormatFloat(float64(req.Float), 'f', -1, 32))
					if req.OptFloat == nil {
						queries.Add("opt_float", strconv.FormatFloat(float64(*req.OptFloat), 'f', -1, 32))
					}
					if req.WrapFloat == nil {
						queries.Add("wrap_float", strconv.FormatFloat(float64(req.WrapFloat.Value), 'f', -1, 32))
					}
					queries.Add("double", strconv.FormatFloat(req.Double, 'f', -1, 64))
					if req.OptDouble == nil {
						queries.Add("opt_double", strconv.FormatFloat(*req.OptDouble, 'f', -1, 64))
					}
					if req.WrapDouble == nil {
						queries.Add("wrap_double", strconv.FormatFloat(req.WrapDouble.Value, 'f', -1, 64))
					}
					queries.Add("string", req.String_)
					if req.OptString == nil {
						queries.Add("opt_string", *req.OptString)
					}
					if req.WrapString == nil {
						queries.Add("wrap_string", req.WrapString.Value)
					}
					queries.Add("status", strconv.FormatInt(int64(req.Status), 10))
					if req.OptStatus == nil {
						queries.Add("opt_status", strconv.FormatInt(int64(*req.OptStatus), 10))
					}
					target := &url.URL{
						Scheme:   scheme,
						Host:     instance,
						Path:     path.Path,
						RawQuery: queries.Encode(),
					}
					r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		uint32Path: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					if obj == nil {
						return nil, errors.New("request object is nil")
					}
					req, ok := obj.(*PathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					_ = req
					var body io.Reader
					var pairs []string
					if req.OptUint32 == nil {
						return nil, fmt.Errorf("%s is nil", "req.OptUint32")
					}
					if req.OptFixed32 == nil {
						return nil, fmt.Errorf("%s is nil", "req.OptFixed32")
					}
					if req.WrapUint32 == nil {
						return nil, fmt.Errorf("%s is nil", "req.WrapUint32")
					}
					pairs = append(pairs, "uint32", strconv.FormatUint(uint64(req.Uint32), 10), "fixed32", strconv.FormatUint(uint64(req.Fixed32), 10), "opt_uint32", strconv.FormatUint(uint64(*req.OptUint32), 10), "opt_fixed32", strconv.FormatUint(uint64(*req.OptFixed32), 10), "wrap_uint32", strconv.FormatUint(uint64(req.WrapUint32.Value), 10))
					path, err := router.Get("/leo.example.path.v1.Path/Uint32Path").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := url.Values{}
					queries.Add("bool", strconv.FormatBool(req.Bool))
					if req.OptBool == nil {
						queries.Add("opt_bool", strconv.FormatBool(*req.OptBool))
					}
					if req.WrapBool == nil {
						queries.Add("wrap_bool", strconv.FormatBool(req.WrapBool.Value))
					}
					queries.Add("int32", strconv.FormatInt(int64(req.Int32), 10))
					queries.Add("sint32", strconv.FormatInt(int64(req.Sint32), 10))
					queries.Add("sfixed32", strconv.FormatInt(int64(req.Sfixed32), 10))
					if req.OptInt32 == nil {
						queries.Add("opt_int32", strconv.FormatInt(int64(*req.OptInt32), 10))
					}
					if req.OptSint32 == nil {
						queries.Add("opt_sint32", strconv.FormatInt(int64(*req.OptSint32), 10))
					}
					if req.OptSfixed32 == nil {
						queries.Add("opt_sfixed32", strconv.FormatInt(int64(*req.OptSfixed32), 10))
					}
					if req.WrapInt32 == nil {
						queries.Add("wrap_int32", strconv.FormatInt(int64(req.WrapInt32.Value), 10))
					}
					queries.Add("int64", strconv.FormatInt(req.Int64, 10))
					queries.Add("sint64", strconv.FormatInt(req.Sint64, 10))
					queries.Add("sfixed64", strconv.FormatInt(req.Sfixed64, 10))
					if req.OptInt64 == nil {
						queries.Add("opt_int64", strconv.FormatInt(*req.OptInt64, 10))
					}
					if req.OptSint64 == nil {
						queries.Add("opt_sint64", strconv.FormatInt(*req.OptSint64, 10))
					}
					if req.OptSfixed64 == nil {
						queries.Add("opt_sfixed64", strconv.FormatInt(*req.OptSfixed64, 10))
					}
					if req.WrapInt64 == nil {
						queries.Add("wrap_int64", strconv.FormatInt(req.WrapInt64.Value, 10))
					}
					queries.Add("uint64", strconv.FormatUint(req.Uint64, 10))
					queries.Add("fixed64", strconv.FormatUint(req.Fixed64, 10))
					if req.OptUint64 == nil {
						queries.Add("opt_uint64", strconv.FormatUint(*req.OptUint64, 10))
					}
					if req.OptFixed64 == nil {
						queries.Add("opt_fixed64", strconv.FormatUint(*req.OptFixed64, 10))
					}
					if req.WrapUint64 == nil {
						queries.Add("wrap_uint64", strconv.FormatUint(req.WrapUint64.Value, 10))
					}
					queries.Add("float", strconv.FormatFloat(float64(req.Float), 'f', -1, 32))
					if req.OptFloat == nil {
						queries.Add("opt_float", strconv.FormatFloat(float64(*req.OptFloat), 'f', -1, 32))
					}
					if req.WrapFloat == nil {
						queries.Add("wrap_float", strconv.FormatFloat(float64(req.WrapFloat.Value), 'f', -1, 32))
					}
					queries.Add("double", strconv.FormatFloat(req.Double, 'f', -1, 64))
					if req.OptDouble == nil {
						queries.Add("opt_double", strconv.FormatFloat(*req.OptDouble, 'f', -1, 64))
					}
					if req.WrapDouble == nil {
						queries.Add("wrap_double", strconv.FormatFloat(req.WrapDouble.Value, 'f', -1, 64))
					}
					queries.Add("string", req.String_)
					if req.OptString == nil {
						queries.Add("opt_string", *req.OptString)
					}
					if req.WrapString == nil {
						queries.Add("wrap_string", req.WrapString.Value)
					}
					queries.Add("status", strconv.FormatInt(int64(req.Status), 10))
					if req.OptStatus == nil {
						queries.Add("opt_status", strconv.FormatInt(int64(*req.OptStatus), 10))
					}
					target := &url.URL{
						Scheme:   scheme,
						Host:     instance,
						Path:     path.Path,
						RawQuery: queries.Encode(),
					}
					r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		uint64Path: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					if obj == nil {
						return nil, errors.New("request object is nil")
					}
					req, ok := obj.(*PathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					_ = req
					var body io.Reader
					var pairs []string
					if req.OptUint64 == nil {
						return nil, fmt.Errorf("%s is nil", "req.OptUint64")
					}
					if req.OptFixed64 == nil {
						return nil, fmt.Errorf("%s is nil", "req.OptFixed64")
					}
					if req.WrapUint64 == nil {
						return nil, fmt.Errorf("%s is nil", "req.WrapUint64")
					}
					pairs = append(pairs, "uint64", strconv.FormatUint(req.Uint64, 10), "fixed64", strconv.FormatUint(req.Fixed64, 10), "opt_uint64", strconv.FormatUint(*req.OptUint64, 10), "opt_fixed64", strconv.FormatUint(*req.OptFixed64, 10), "wrap_uint64", strconv.FormatUint(req.WrapUint64.Value, 10))
					path, err := router.Get("/leo.example.path.v1.Path/Uint64Path").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := url.Values{}
					queries.Add("bool", strconv.FormatBool(req.Bool))
					if req.OptBool == nil {
						queries.Add("opt_bool", strconv.FormatBool(*req.OptBool))
					}
					if req.WrapBool == nil {
						queries.Add("wrap_bool", strconv.FormatBool(req.WrapBool.Value))
					}
					queries.Add("int32", strconv.FormatInt(int64(req.Int32), 10))
					queries.Add("sint32", strconv.FormatInt(int64(req.Sint32), 10))
					queries.Add("sfixed32", strconv.FormatInt(int64(req.Sfixed32), 10))
					if req.OptInt32 == nil {
						queries.Add("opt_int32", strconv.FormatInt(int64(*req.OptInt32), 10))
					}
					if req.OptSint32 == nil {
						queries.Add("opt_sint32", strconv.FormatInt(int64(*req.OptSint32), 10))
					}
					if req.OptSfixed32 == nil {
						queries.Add("opt_sfixed32", strconv.FormatInt(int64(*req.OptSfixed32), 10))
					}
					if req.WrapInt32 == nil {
						queries.Add("wrap_int32", strconv.FormatInt(int64(req.WrapInt32.Value), 10))
					}
					queries.Add("int64", strconv.FormatInt(req.Int64, 10))
					queries.Add("sint64", strconv.FormatInt(req.Sint64, 10))
					queries.Add("sfixed64", strconv.FormatInt(req.Sfixed64, 10))
					if req.OptInt64 == nil {
						queries.Add("opt_int64", strconv.FormatInt(*req.OptInt64, 10))
					}
					if req.OptSint64 == nil {
						queries.Add("opt_sint64", strconv.FormatInt(*req.OptSint64, 10))
					}
					if req.OptSfixed64 == nil {
						queries.Add("opt_sfixed64", strconv.FormatInt(*req.OptSfixed64, 10))
					}
					if req.WrapInt64 == nil {
						queries.Add("wrap_int64", strconv.FormatInt(req.WrapInt64.Value, 10))
					}
					queries.Add("uint32", strconv.FormatUint(uint64(req.Uint32), 10))
					queries.Add("fixed32", strconv.FormatUint(uint64(req.Fixed32), 10))
					if req.OptUint32 == nil {
						queries.Add("opt_uint32", strconv.FormatUint(uint64(*req.OptUint32), 10))
					}
					if req.OptFixed32 == nil {
						queries.Add("opt_fixed32", strconv.FormatUint(uint64(*req.OptFixed32), 10))
					}
					if req.WrapUint32 == nil {
						queries.Add("wrap_uint32", strconv.FormatUint(uint64(req.WrapUint32.Value), 10))
					}
					queries.Add("float", strconv.FormatFloat(float64(req.Float), 'f', -1, 32))
					if req.OptFloat == nil {
						queries.Add("opt_float", strconv.FormatFloat(float64(*req.OptFloat), 'f', -1, 32))
					}
					if req.WrapFloat == nil {
						queries.Add("wrap_float", strconv.FormatFloat(float64(req.WrapFloat.Value), 'f', -1, 32))
					}
					queries.Add("double", strconv.FormatFloat(req.Double, 'f', -1, 64))
					if req.OptDouble == nil {
						queries.Add("opt_double", strconv.FormatFloat(*req.OptDouble, 'f', -1, 64))
					}
					if req.WrapDouble == nil {
						queries.Add("wrap_double", strconv.FormatFloat(req.WrapDouble.Value, 'f', -1, 64))
					}
					queries.Add("string", req.String_)
					if req.OptString == nil {
						queries.Add("opt_string", *req.OptString)
					}
					if req.WrapString == nil {
						queries.Add("wrap_string", req.WrapString.Value)
					}
					queries.Add("status", strconv.FormatInt(int64(req.Status), 10))
					if req.OptStatus == nil {
						queries.Add("opt_status", strconv.FormatInt(int64(*req.OptStatus), 10))
					}
					target := &url.URL{
						Scheme:   scheme,
						Host:     instance,
						Path:     path.Path,
						RawQuery: queries.Encode(),
					}
					r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		floatPath: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					if obj == nil {
						return nil, errors.New("request object is nil")
					}
					req, ok := obj.(*PathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					_ = req
					var body io.Reader
					var pairs []string
					if req.OptFloat == nil {
						return nil, fmt.Errorf("%s is nil", "req.OptFloat")
					}
					if req.WrapFloat == nil {
						return nil, fmt.Errorf("%s is nil", "req.WrapFloat")
					}
					pairs = append(pairs, "float", strconv.FormatFloat(float64(req.Float), 'f', -1, 32), "opt_float", strconv.FormatFloat(float64(*req.OptFloat), 'f', -1, 32), "wrap_float", strconv.FormatFloat(float64(req.WrapFloat.Value), 'f', -1, 32))
					path, err := router.Get("/leo.example.path.v1.Path/FloatPath").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := url.Values{}
					queries.Add("bool", strconv.FormatBool(req.Bool))
					if req.OptBool == nil {
						queries.Add("opt_bool", strconv.FormatBool(*req.OptBool))
					}
					if req.WrapBool == nil {
						queries.Add("wrap_bool", strconv.FormatBool(req.WrapBool.Value))
					}
					queries.Add("int32", strconv.FormatInt(int64(req.Int32), 10))
					queries.Add("sint32", strconv.FormatInt(int64(req.Sint32), 10))
					queries.Add("sfixed32", strconv.FormatInt(int64(req.Sfixed32), 10))
					if req.OptInt32 == nil {
						queries.Add("opt_int32", strconv.FormatInt(int64(*req.OptInt32), 10))
					}
					if req.OptSint32 == nil {
						queries.Add("opt_sint32", strconv.FormatInt(int64(*req.OptSint32), 10))
					}
					if req.OptSfixed32 == nil {
						queries.Add("opt_sfixed32", strconv.FormatInt(int64(*req.OptSfixed32), 10))
					}
					if req.WrapInt32 == nil {
						queries.Add("wrap_int32", strconv.FormatInt(int64(req.WrapInt32.Value), 10))
					}
					queries.Add("int64", strconv.FormatInt(req.Int64, 10))
					queries.Add("sint64", strconv.FormatInt(req.Sint64, 10))
					queries.Add("sfixed64", strconv.FormatInt(req.Sfixed64, 10))
					if req.OptInt64 == nil {
						queries.Add("opt_int64", strconv.FormatInt(*req.OptInt64, 10))
					}
					if req.OptSint64 == nil {
						queries.Add("opt_sint64", strconv.FormatInt(*req.OptSint64, 10))
					}
					if req.OptSfixed64 == nil {
						queries.Add("opt_sfixed64", strconv.FormatInt(*req.OptSfixed64, 10))
					}
					if req.WrapInt64 == nil {
						queries.Add("wrap_int64", strconv.FormatInt(req.WrapInt64.Value, 10))
					}
					queries.Add("uint32", strconv.FormatUint(uint64(req.Uint32), 10))
					queries.Add("fixed32", strconv.FormatUint(uint64(req.Fixed32), 10))
					if req.OptUint32 == nil {
						queries.Add("opt_uint32", strconv.FormatUint(uint64(*req.OptUint32), 10))
					}
					if req.OptFixed32 == nil {
						queries.Add("opt_fixed32", strconv.FormatUint(uint64(*req.OptFixed32), 10))
					}
					if req.WrapUint32 == nil {
						queries.Add("wrap_uint32", strconv.FormatUint(uint64(req.WrapUint32.Value), 10))
					}
					queries.Add("uint64", strconv.FormatUint(req.Uint64, 10))
					queries.Add("fixed64", strconv.FormatUint(req.Fixed64, 10))
					if req.OptUint64 == nil {
						queries.Add("opt_uint64", strconv.FormatUint(*req.OptUint64, 10))
					}
					if req.OptFixed64 == nil {
						queries.Add("opt_fixed64", strconv.FormatUint(*req.OptFixed64, 10))
					}
					if req.WrapUint64 == nil {
						queries.Add("wrap_uint64", strconv.FormatUint(req.WrapUint64.Value, 10))
					}
					queries.Add("double", strconv.FormatFloat(req.Double, 'f', -1, 64))
					if req.OptDouble == nil {
						queries.Add("opt_double", strconv.FormatFloat(*req.OptDouble, 'f', -1, 64))
					}
					if req.WrapDouble == nil {
						queries.Add("wrap_double", strconv.FormatFloat(req.WrapDouble.Value, 'f', -1, 64))
					}
					queries.Add("string", req.String_)
					if req.OptString == nil {
						queries.Add("opt_string", *req.OptString)
					}
					if req.WrapString == nil {
						queries.Add("wrap_string", req.WrapString.Value)
					}
					queries.Add("status", strconv.FormatInt(int64(req.Status), 10))
					if req.OptStatus == nil {
						queries.Add("opt_status", strconv.FormatInt(int64(*req.OptStatus), 10))
					}
					target := &url.URL{
						Scheme:   scheme,
						Host:     instance,
						Path:     path.Path,
						RawQuery: queries.Encode(),
					}
					r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		doublePath: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					if obj == nil {
						return nil, errors.New("request object is nil")
					}
					req, ok := obj.(*PathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					_ = req
					var body io.Reader
					var pairs []string
					if req.OptDouble == nil {
						return nil, fmt.Errorf("%s is nil", "req.OptDouble")
					}
					if req.WrapDouble == nil {
						return nil, fmt.Errorf("%s is nil", "req.WrapDouble")
					}
					pairs = append(pairs, "double", strconv.FormatFloat(req.Double, 'f', -1, 64), "opt_double", strconv.FormatFloat(*req.OptDouble, 'f', -1, 64), "wrap_double", strconv.FormatFloat(req.WrapDouble.Value, 'f', -1, 64))
					path, err := router.Get("/leo.example.path.v1.Path/DoublePath").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := url.Values{}
					queries.Add("bool", strconv.FormatBool(req.Bool))
					if req.OptBool == nil {
						queries.Add("opt_bool", strconv.FormatBool(*req.OptBool))
					}
					if req.WrapBool == nil {
						queries.Add("wrap_bool", strconv.FormatBool(req.WrapBool.Value))
					}
					queries.Add("int32", strconv.FormatInt(int64(req.Int32), 10))
					queries.Add("sint32", strconv.FormatInt(int64(req.Sint32), 10))
					queries.Add("sfixed32", strconv.FormatInt(int64(req.Sfixed32), 10))
					if req.OptInt32 == nil {
						queries.Add("opt_int32", strconv.FormatInt(int64(*req.OptInt32), 10))
					}
					if req.OptSint32 == nil {
						queries.Add("opt_sint32", strconv.FormatInt(int64(*req.OptSint32), 10))
					}
					if req.OptSfixed32 == nil {
						queries.Add("opt_sfixed32", strconv.FormatInt(int64(*req.OptSfixed32), 10))
					}
					if req.WrapInt32 == nil {
						queries.Add("wrap_int32", strconv.FormatInt(int64(req.WrapInt32.Value), 10))
					}
					queries.Add("int64", strconv.FormatInt(req.Int64, 10))
					queries.Add("sint64", strconv.FormatInt(req.Sint64, 10))
					queries.Add("sfixed64", strconv.FormatInt(req.Sfixed64, 10))
					if req.OptInt64 == nil {
						queries.Add("opt_int64", strconv.FormatInt(*req.OptInt64, 10))
					}
					if req.OptSint64 == nil {
						queries.Add("opt_sint64", strconv.FormatInt(*req.OptSint64, 10))
					}
					if req.OptSfixed64 == nil {
						queries.Add("opt_sfixed64", strconv.FormatInt(*req.OptSfixed64, 10))
					}
					if req.WrapInt64 == nil {
						queries.Add("wrap_int64", strconv.FormatInt(req.WrapInt64.Value, 10))
					}
					queries.Add("uint32", strconv.FormatUint(uint64(req.Uint32), 10))
					queries.Add("fixed32", strconv.FormatUint(uint64(req.Fixed32), 10))
					if req.OptUint32 == nil {
						queries.Add("opt_uint32", strconv.FormatUint(uint64(*req.OptUint32), 10))
					}
					if req.OptFixed32 == nil {
						queries.Add("opt_fixed32", strconv.FormatUint(uint64(*req.OptFixed32), 10))
					}
					if req.WrapUint32 == nil {
						queries.Add("wrap_uint32", strconv.FormatUint(uint64(req.WrapUint32.Value), 10))
					}
					queries.Add("uint64", strconv.FormatUint(req.Uint64, 10))
					queries.Add("fixed64", strconv.FormatUint(req.Fixed64, 10))
					if req.OptUint64 == nil {
						queries.Add("opt_uint64", strconv.FormatUint(*req.OptUint64, 10))
					}
					if req.OptFixed64 == nil {
						queries.Add("opt_fixed64", strconv.FormatUint(*req.OptFixed64, 10))
					}
					if req.WrapUint64 == nil {
						queries.Add("wrap_uint64", strconv.FormatUint(req.WrapUint64.Value, 10))
					}
					queries.Add("float", strconv.FormatFloat(float64(req.Float), 'f', -1, 32))
					if req.OptFloat == nil {
						queries.Add("opt_float", strconv.FormatFloat(float64(*req.OptFloat), 'f', -1, 32))
					}
					if req.WrapFloat == nil {
						queries.Add("wrap_float", strconv.FormatFloat(float64(req.WrapFloat.Value), 'f', -1, 32))
					}
					queries.Add("string", req.String_)
					if req.OptString == nil {
						queries.Add("opt_string", *req.OptString)
					}
					if req.WrapString == nil {
						queries.Add("wrap_string", req.WrapString.Value)
					}
					queries.Add("status", strconv.FormatInt(int64(req.Status), 10))
					if req.OptStatus == nil {
						queries.Add("opt_status", strconv.FormatInt(int64(*req.OptStatus), 10))
					}
					target := &url.URL{
						Scheme:   scheme,
						Host:     instance,
						Path:     path.Path,
						RawQuery: queries.Encode(),
					}
					r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		stringPath: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					if obj == nil {
						return nil, errors.New("request object is nil")
					}
					req, ok := obj.(*PathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					_ = req
					var body io.Reader
					var pairs []string
					if req.OptString == nil {
						return nil, fmt.Errorf("%s is nil", "req.OptString")
					}
					if req.WrapString == nil {
						return nil, fmt.Errorf("%s is nil", "req.WrapString")
					}
					pairs = append(pairs, "string", req.String_, "opt_string", *req.OptString, "wrap_string", req.WrapString.Value)
					path, err := router.Get("/leo.example.path.v1.Path/StringPath").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := url.Values{}
					queries.Add("bool", strconv.FormatBool(req.Bool))
					if req.OptBool == nil {
						queries.Add("opt_bool", strconv.FormatBool(*req.OptBool))
					}
					if req.WrapBool == nil {
						queries.Add("wrap_bool", strconv.FormatBool(req.WrapBool.Value))
					}
					queries.Add("int32", strconv.FormatInt(int64(req.Int32), 10))
					queries.Add("sint32", strconv.FormatInt(int64(req.Sint32), 10))
					queries.Add("sfixed32", strconv.FormatInt(int64(req.Sfixed32), 10))
					if req.OptInt32 == nil {
						queries.Add("opt_int32", strconv.FormatInt(int64(*req.OptInt32), 10))
					}
					if req.OptSint32 == nil {
						queries.Add("opt_sint32", strconv.FormatInt(int64(*req.OptSint32), 10))
					}
					if req.OptSfixed32 == nil {
						queries.Add("opt_sfixed32", strconv.FormatInt(int64(*req.OptSfixed32), 10))
					}
					if req.WrapInt32 == nil {
						queries.Add("wrap_int32", strconv.FormatInt(int64(req.WrapInt32.Value), 10))
					}
					queries.Add("int64", strconv.FormatInt(req.Int64, 10))
					queries.Add("sint64", strconv.FormatInt(req.Sint64, 10))
					queries.Add("sfixed64", strconv.FormatInt(req.Sfixed64, 10))
					if req.OptInt64 == nil {
						queries.Add("opt_int64", strconv.FormatInt(*req.OptInt64, 10))
					}
					if req.OptSint64 == nil {
						queries.Add("opt_sint64", strconv.FormatInt(*req.OptSint64, 10))
					}
					if req.OptSfixed64 == nil {
						queries.Add("opt_sfixed64", strconv.FormatInt(*req.OptSfixed64, 10))
					}
					if req.WrapInt64 == nil {
						queries.Add("wrap_int64", strconv.FormatInt(req.WrapInt64.Value, 10))
					}
					queries.Add("uint32", strconv.FormatUint(uint64(req.Uint32), 10))
					queries.Add("fixed32", strconv.FormatUint(uint64(req.Fixed32), 10))
					if req.OptUint32 == nil {
						queries.Add("opt_uint32", strconv.FormatUint(uint64(*req.OptUint32), 10))
					}
					if req.OptFixed32 == nil {
						queries.Add("opt_fixed32", strconv.FormatUint(uint64(*req.OptFixed32), 10))
					}
					if req.WrapUint32 == nil {
						queries.Add("wrap_uint32", strconv.FormatUint(uint64(req.WrapUint32.Value), 10))
					}
					queries.Add("uint64", strconv.FormatUint(req.Uint64, 10))
					queries.Add("fixed64", strconv.FormatUint(req.Fixed64, 10))
					if req.OptUint64 == nil {
						queries.Add("opt_uint64", strconv.FormatUint(*req.OptUint64, 10))
					}
					if req.OptFixed64 == nil {
						queries.Add("opt_fixed64", strconv.FormatUint(*req.OptFixed64, 10))
					}
					if req.WrapUint64 == nil {
						queries.Add("wrap_uint64", strconv.FormatUint(req.WrapUint64.Value, 10))
					}
					queries.Add("float", strconv.FormatFloat(float64(req.Float), 'f', -1, 32))
					if req.OptFloat == nil {
						queries.Add("opt_float", strconv.FormatFloat(float64(*req.OptFloat), 'f', -1, 32))
					}
					if req.WrapFloat == nil {
						queries.Add("wrap_float", strconv.FormatFloat(float64(req.WrapFloat.Value), 'f', -1, 32))
					}
					queries.Add("double", strconv.FormatFloat(req.Double, 'f', -1, 64))
					if req.OptDouble == nil {
						queries.Add("opt_double", strconv.FormatFloat(*req.OptDouble, 'f', -1, 64))
					}
					if req.WrapDouble == nil {
						queries.Add("wrap_double", strconv.FormatFloat(req.WrapDouble.Value, 'f', -1, 64))
					}
					queries.Add("status", strconv.FormatInt(int64(req.Status), 10))
					if req.OptStatus == nil {
						queries.Add("opt_status", strconv.FormatInt(int64(*req.OptStatus), 10))
					}
					target := &url.URL{
						Scheme:   scheme,
						Host:     instance,
						Path:     path.Path,
						RawQuery: queries.Encode(),
					}
					r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		enumPath: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					if obj == nil {
						return nil, errors.New("request object is nil")
					}
					req, ok := obj.(*PathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					_ = req
					var body io.Reader
					var pairs []string
					if req.OptStatus == nil {
						return nil, fmt.Errorf("%s is nil", "req.OptStatus")
					}
					pairs = append(pairs, "status", strconv.FormatInt(int64(req.Status), 10), "opt_status", strconv.FormatInt(int64(*req.OptStatus), 10))
					path, err := router.Get("/leo.example.path.v1.Path/EnumPath").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := url.Values{}
					queries.Add("bool", strconv.FormatBool(req.Bool))
					if req.OptBool == nil {
						queries.Add("opt_bool", strconv.FormatBool(*req.OptBool))
					}
					if req.WrapBool == nil {
						queries.Add("wrap_bool", strconv.FormatBool(req.WrapBool.Value))
					}
					queries.Add("int32", strconv.FormatInt(int64(req.Int32), 10))
					queries.Add("sint32", strconv.FormatInt(int64(req.Sint32), 10))
					queries.Add("sfixed32", strconv.FormatInt(int64(req.Sfixed32), 10))
					if req.OptInt32 == nil {
						queries.Add("opt_int32", strconv.FormatInt(int64(*req.OptInt32), 10))
					}
					if req.OptSint32 == nil {
						queries.Add("opt_sint32", strconv.FormatInt(int64(*req.OptSint32), 10))
					}
					if req.OptSfixed32 == nil {
						queries.Add("opt_sfixed32", strconv.FormatInt(int64(*req.OptSfixed32), 10))
					}
					if req.WrapInt32 == nil {
						queries.Add("wrap_int32", strconv.FormatInt(int64(req.WrapInt32.Value), 10))
					}
					queries.Add("int64", strconv.FormatInt(req.Int64, 10))
					queries.Add("sint64", strconv.FormatInt(req.Sint64, 10))
					queries.Add("sfixed64", strconv.FormatInt(req.Sfixed64, 10))
					if req.OptInt64 == nil {
						queries.Add("opt_int64", strconv.FormatInt(*req.OptInt64, 10))
					}
					if req.OptSint64 == nil {
						queries.Add("opt_sint64", strconv.FormatInt(*req.OptSint64, 10))
					}
					if req.OptSfixed64 == nil {
						queries.Add("opt_sfixed64", strconv.FormatInt(*req.OptSfixed64, 10))
					}
					if req.WrapInt64 == nil {
						queries.Add("wrap_int64", strconv.FormatInt(req.WrapInt64.Value, 10))
					}
					queries.Add("uint32", strconv.FormatUint(uint64(req.Uint32), 10))
					queries.Add("fixed32", strconv.FormatUint(uint64(req.Fixed32), 10))
					if req.OptUint32 == nil {
						queries.Add("opt_uint32", strconv.FormatUint(uint64(*req.OptUint32), 10))
					}
					if req.OptFixed32 == nil {
						queries.Add("opt_fixed32", strconv.FormatUint(uint64(*req.OptFixed32), 10))
					}
					if req.WrapUint32 == nil {
						queries.Add("wrap_uint32", strconv.FormatUint(uint64(req.WrapUint32.Value), 10))
					}
					queries.Add("uint64", strconv.FormatUint(req.Uint64, 10))
					queries.Add("fixed64", strconv.FormatUint(req.Fixed64, 10))
					if req.OptUint64 == nil {
						queries.Add("opt_uint64", strconv.FormatUint(*req.OptUint64, 10))
					}
					if req.OptFixed64 == nil {
						queries.Add("opt_fixed64", strconv.FormatUint(*req.OptFixed64, 10))
					}
					if req.WrapUint64 == nil {
						queries.Add("wrap_uint64", strconv.FormatUint(req.WrapUint64.Value, 10))
					}
					queries.Add("float", strconv.FormatFloat(float64(req.Float), 'f', -1, 32))
					if req.OptFloat == nil {
						queries.Add("opt_float", strconv.FormatFloat(float64(*req.OptFloat), 'f', -1, 32))
					}
					if req.WrapFloat == nil {
						queries.Add("wrap_float", strconv.FormatFloat(float64(req.WrapFloat.Value), 'f', -1, 32))
					}
					queries.Add("double", strconv.FormatFloat(req.Double, 'f', -1, 64))
					if req.OptDouble == nil {
						queries.Add("opt_double", strconv.FormatFloat(*req.OptDouble, 'f', -1, 64))
					}
					if req.WrapDouble == nil {
						queries.Add("wrap_double", strconv.FormatFloat(req.WrapDouble.Value, 'f', -1, 64))
					}
					queries.Add("string", req.String_)
					if req.OptString == nil {
						queries.Add("opt_string", *req.OptString)
					}
					if req.WrapString == nil {
						queries.Add("wrap_string", req.WrapString.Value)
					}
					target := &url.URL{
						Scheme:   scheme,
						Host:     instance,
						Path:     path.Path,
						RawQuery: queries.Encode(),
					}
					r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		mixPath: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					if obj == nil {
						return nil, errors.New("request object is nil")
					}
					req, ok := obj.(*MixPathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					_ = req
					var body io.Reader
					var pairs []string
					if req.Embed == nil {
						return nil, fmt.Errorf("%s is nil", "req.Embed")
					}
					namedPathParameter := req.Embed.WrapString.Value
					namedPathValues := strings.Split(namedPathParameter, "/")
					if len(namedPathValues) != 8 {
						return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
					}
					pairs = append(pairs, "class", namedPathValues[1], "shelf", namedPathValues[3], "book", namedPathValues[5], "family", namedPathValues[7])
					if req.OptString == nil {
						return nil, fmt.Errorf("%s is nil", "req.OptString")
					}
					if req.WrapString == nil {
						return nil, fmt.Errorf("%s is nil", "req.WrapString")
					}
					pairs = append(pairs, "string", req.String_, "opt_string", *req.OptString, "wrap_string", req.WrapString.Value)
					path, err := router.Get("/leo.example.path.v1.Path/MixPath").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					queries := url.Values{}
					target := &url.URL{
						Scheme:   scheme,
						Host:     instance,
						Path:     path.Path,
						RawQuery: queries.Encode(),
					}
					r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
	}
}
