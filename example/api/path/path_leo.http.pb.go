// Code generated by protoc-gen-leo-http. DO NOT EDIT.

package path

import (
	context "context"
	endpoint "github.com/go-kit/kit/endpoint"
	http "github.com/go-kit/kit/transport/http"
	jsonx "github.com/go-leo/gox/encodingx/jsonx"
	errorx "github.com/go-leo/gox/errorx"
	urlx "github.com/go-leo/gox/netx/urlx"
	strconvx "github.com/go-leo/gox/strconvx"
	endpointx "github.com/go-leo/leo/v3/endpointx"
	statusx "github.com/go-leo/leo/v3/statusx"
	transportx "github.com/go-leo/leo/v3/transportx"
	httpx "github.com/go-leo/leo/v3/transportx/httpx"
	mux "github.com/gorilla/mux"
	proto "google.golang.org/protobuf/proto"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	io "io"
	http1 "net/http"
	url "net/url"
)

// =========================== http router ===========================

func appendPathHttpRoutes(router *mux.Router) *mux.Router {
	router.NewRoute().Name("/leo.example.path.v1.Path/BoolPath").Methods("GET").Path("/v1/{bool}/{opt_bool}/{wrap_bool}")
	router.NewRoute().Name("/leo.example.path.v1.Path/Int32Path").Methods("GET").Path("/v1/{int32}/{sint32}/{sfixed32}/{opt_int32}/{opt_sint32}/{opt_sfixed32}/{wrap_int32}")
	router.NewRoute().Name("/leo.example.path.v1.Path/Int64Path").Methods("GET").Path("/v1/{int64}/{sint64}/{sfixed64}/{opt_int64}/{opt_sint64}/{opt_sfixed64}/{wrap_int64}")
	router.NewRoute().Name("/leo.example.path.v1.Path/Uint32Path").Methods("GET").Path("/v1/{uint32}/{fixed32}/{opt_uint32}/{opt_fixed32}/{wrap_uint32}")
	router.NewRoute().Name("/leo.example.path.v1.Path/Uint64Path").Methods("GET").Path("/v1/{uint64}/{fixed64}/{opt_uint64}/{opt_fixed64}/{wrap_uint64}")
	router.NewRoute().Name("/leo.example.path.v1.Path/FloatPath").Methods("GET").Path("/v1/{float}/{opt_float}/{wrap_float}")
	router.NewRoute().Name("/leo.example.path.v1.Path/DoublePath").Methods("GET").Path("/v1/{double}/{opt_double}/{wrap_double}")
	router.NewRoute().Name("/leo.example.path.v1.Path/StringPath").Methods("GET").Path("/v1/{string}/{opt_string}/{wrap_string}")
	router.NewRoute().Name("/leo.example.path.v1.Path/EnumPath").Methods("GET").Path("/v1/{status}/{opt_status}")
	return router
}

// =========================== http server ===========================

func AppendPathHttpRoutes(router *mux.Router, svc PathService, middlewares ...endpoint.Middleware) *mux.Router {
	endpoints := newPathServerEndpoints(svc, middlewares...)
	router = appendPathHttpRoutes(router)
	router.Get("/leo.example.path.v1.Path/BoolPath").Handler(_Path_BoolPath_HttpServer_Transport(endpoints))
	router.Get("/leo.example.path.v1.Path/Int32Path").Handler(_Path_Int32Path_HttpServer_Transport(endpoints))
	router.Get("/leo.example.path.v1.Path/Int64Path").Handler(_Path_Int64Path_HttpServer_Transport(endpoints))
	router.Get("/leo.example.path.v1.Path/Uint32Path").Handler(_Path_Uint32Path_HttpServer_Transport(endpoints))
	router.Get("/leo.example.path.v1.Path/Uint64Path").Handler(_Path_Uint64Path_HttpServer_Transport(endpoints))
	router.Get("/leo.example.path.v1.Path/FloatPath").Handler(_Path_FloatPath_HttpServer_Transport(endpoints))
	router.Get("/leo.example.path.v1.Path/DoublePath").Handler(_Path_DoublePath_HttpServer_Transport(endpoints))
	router.Get("/leo.example.path.v1.Path/StringPath").Handler(_Path_StringPath_HttpServer_Transport(endpoints))
	router.Get("/leo.example.path.v1.Path/EnumPath").Handler(_Path_EnumPath_HttpServer_Transport(endpoints))
	return router
}

// =========================== http client ===========================

type pathHttpClientTransports struct {
	scheme        string
	router        *mux.Router
	clientOptions []http.ClientOption
	middlewares   []endpoint.Middleware
}

func (t *pathHttpClientTransports) BoolPath(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http.ClientOption{
		http.ClientBefore(httpx.OutgoingMetadataInjector),
		http.ClientBefore(httpx.OutgoingTimeLimiter),
		http.ClientBefore(httpx.OutgoingStain),
	}
	opts = append(opts, t.clientOptions...)
	client := http.NewExplicitClient(
		_Path_BoolPath_HttpClient_RequestEncoder(t.router)(t.scheme, instance),
		_Path_BoolPath_HttpClient_ResponseDecoder,
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func (t *pathHttpClientTransports) Int32Path(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http.ClientOption{
		http.ClientBefore(httpx.OutgoingMetadataInjector),
		http.ClientBefore(httpx.OutgoingTimeLimiter),
		http.ClientBefore(httpx.OutgoingStain),
	}
	opts = append(opts, t.clientOptions...)
	client := http.NewExplicitClient(
		_Path_Int32Path_HttpClient_RequestEncoder(t.router)(t.scheme, instance),
		_Path_Int32Path_HttpClient_ResponseDecoder,
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func (t *pathHttpClientTransports) Int64Path(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http.ClientOption{
		http.ClientBefore(httpx.OutgoingMetadataInjector),
		http.ClientBefore(httpx.OutgoingTimeLimiter),
		http.ClientBefore(httpx.OutgoingStain),
	}
	opts = append(opts, t.clientOptions...)
	client := http.NewExplicitClient(
		_Path_Int64Path_HttpClient_RequestEncoder(t.router)(t.scheme, instance),
		_Path_Int64Path_HttpClient_ResponseDecoder,
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func (t *pathHttpClientTransports) Uint32Path(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http.ClientOption{
		http.ClientBefore(httpx.OutgoingMetadataInjector),
		http.ClientBefore(httpx.OutgoingTimeLimiter),
		http.ClientBefore(httpx.OutgoingStain),
	}
	opts = append(opts, t.clientOptions...)
	client := http.NewExplicitClient(
		_Path_Uint32Path_HttpClient_RequestEncoder(t.router)(t.scheme, instance),
		_Path_Uint32Path_HttpClient_ResponseDecoder,
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func (t *pathHttpClientTransports) Uint64Path(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http.ClientOption{
		http.ClientBefore(httpx.OutgoingMetadataInjector),
		http.ClientBefore(httpx.OutgoingTimeLimiter),
		http.ClientBefore(httpx.OutgoingStain),
	}
	opts = append(opts, t.clientOptions...)
	client := http.NewExplicitClient(
		_Path_Uint64Path_HttpClient_RequestEncoder(t.router)(t.scheme, instance),
		_Path_Uint64Path_HttpClient_ResponseDecoder,
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func (t *pathHttpClientTransports) FloatPath(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http.ClientOption{
		http.ClientBefore(httpx.OutgoingMetadataInjector),
		http.ClientBefore(httpx.OutgoingTimeLimiter),
		http.ClientBefore(httpx.OutgoingStain),
	}
	opts = append(opts, t.clientOptions...)
	client := http.NewExplicitClient(
		_Path_FloatPath_HttpClient_RequestEncoder(t.router)(t.scheme, instance),
		_Path_FloatPath_HttpClient_ResponseDecoder,
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func (t *pathHttpClientTransports) DoublePath(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http.ClientOption{
		http.ClientBefore(httpx.OutgoingMetadataInjector),
		http.ClientBefore(httpx.OutgoingTimeLimiter),
		http.ClientBefore(httpx.OutgoingStain),
	}
	opts = append(opts, t.clientOptions...)
	client := http.NewExplicitClient(
		_Path_DoublePath_HttpClient_RequestEncoder(t.router)(t.scheme, instance),
		_Path_DoublePath_HttpClient_ResponseDecoder,
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func (t *pathHttpClientTransports) StringPath(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http.ClientOption{
		http.ClientBefore(httpx.OutgoingMetadataInjector),
		http.ClientBefore(httpx.OutgoingTimeLimiter),
		http.ClientBefore(httpx.OutgoingStain),
	}
	opts = append(opts, t.clientOptions...)
	client := http.NewExplicitClient(
		_Path_StringPath_HttpClient_RequestEncoder(t.router)(t.scheme, instance),
		_Path_StringPath_HttpClient_ResponseDecoder,
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func (t *pathHttpClientTransports) EnumPath(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http.ClientOption{
		http.ClientBefore(httpx.OutgoingMetadataInjector),
		http.ClientBefore(httpx.OutgoingTimeLimiter),
		http.ClientBefore(httpx.OutgoingStain),
	}
	opts = append(opts, t.clientOptions...)
	client := http.NewExplicitClient(
		_Path_EnumPath_HttpClient_RequestEncoder(t.router)(t.scheme, instance),
		_Path_EnumPath_HttpClient_ResponseDecoder,
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func newPathHttpClientTransports(scheme string, clientOptions []http.ClientOption, middlewares []endpoint.Middleware) PathClientTransportsV2 {
	return &pathHttpClientTransports{
		scheme:        scheme,
		router:        appendPathHttpRoutes(mux.NewRouter()),
		clientOptions: clientOptions,
		middlewares:   middlewares,
	}
}

type pathHttpClient struct {
	endpoints PathEndpoints
}

func (c *pathHttpClient) BoolPath(ctx context.Context, request *PathRequest) (*emptypb.Empty, error) {
	ctx = endpointx.InjectName(ctx, "/leo.example.path.v1.Path/BoolPath")
	ctx = transportx.InjectName(ctx, httpx.HttpClient)
	rep, err := c.endpoints.BoolPath(ctx)(ctx, request)
	if err != nil {
		return nil, statusx.From(err)
	}
	return rep.(*emptypb.Empty), nil
}

func (c *pathHttpClient) Int32Path(ctx context.Context, request *PathRequest) (*emptypb.Empty, error) {
	ctx = endpointx.InjectName(ctx, "/leo.example.path.v1.Path/Int32Path")
	ctx = transportx.InjectName(ctx, httpx.HttpClient)
	rep, err := c.endpoints.Int32Path(ctx)(ctx, request)
	if err != nil {
		return nil, statusx.From(err)
	}
	return rep.(*emptypb.Empty), nil
}

func (c *pathHttpClient) Int64Path(ctx context.Context, request *PathRequest) (*emptypb.Empty, error) {
	ctx = endpointx.InjectName(ctx, "/leo.example.path.v1.Path/Int64Path")
	ctx = transportx.InjectName(ctx, httpx.HttpClient)
	rep, err := c.endpoints.Int64Path(ctx)(ctx, request)
	if err != nil {
		return nil, statusx.From(err)
	}
	return rep.(*emptypb.Empty), nil
}

func (c *pathHttpClient) Uint32Path(ctx context.Context, request *PathRequest) (*emptypb.Empty, error) {
	ctx = endpointx.InjectName(ctx, "/leo.example.path.v1.Path/Uint32Path")
	ctx = transportx.InjectName(ctx, httpx.HttpClient)
	rep, err := c.endpoints.Uint32Path(ctx)(ctx, request)
	if err != nil {
		return nil, statusx.From(err)
	}
	return rep.(*emptypb.Empty), nil
}

func (c *pathHttpClient) Uint64Path(ctx context.Context, request *PathRequest) (*emptypb.Empty, error) {
	ctx = endpointx.InjectName(ctx, "/leo.example.path.v1.Path/Uint64Path")
	ctx = transportx.InjectName(ctx, httpx.HttpClient)
	rep, err := c.endpoints.Uint64Path(ctx)(ctx, request)
	if err != nil {
		return nil, statusx.From(err)
	}
	return rep.(*emptypb.Empty), nil
}

func (c *pathHttpClient) FloatPath(ctx context.Context, request *PathRequest) (*emptypb.Empty, error) {
	ctx = endpointx.InjectName(ctx, "/leo.example.path.v1.Path/FloatPath")
	ctx = transportx.InjectName(ctx, httpx.HttpClient)
	rep, err := c.endpoints.FloatPath(ctx)(ctx, request)
	if err != nil {
		return nil, statusx.From(err)
	}
	return rep.(*emptypb.Empty), nil
}

func (c *pathHttpClient) DoublePath(ctx context.Context, request *PathRequest) (*emptypb.Empty, error) {
	ctx = endpointx.InjectName(ctx, "/leo.example.path.v1.Path/DoublePath")
	ctx = transportx.InjectName(ctx, httpx.HttpClient)
	rep, err := c.endpoints.DoublePath(ctx)(ctx, request)
	if err != nil {
		return nil, statusx.From(err)
	}
	return rep.(*emptypb.Empty), nil
}

func (c *pathHttpClient) StringPath(ctx context.Context, request *PathRequest) (*emptypb.Empty, error) {
	ctx = endpointx.InjectName(ctx, "/leo.example.path.v1.Path/StringPath")
	ctx = transportx.InjectName(ctx, httpx.HttpClient)
	rep, err := c.endpoints.StringPath(ctx)(ctx, request)
	if err != nil {
		return nil, statusx.From(err)
	}
	return rep.(*emptypb.Empty), nil
}

func (c *pathHttpClient) EnumPath(ctx context.Context, request *PathRequest) (*emptypb.Empty, error) {
	ctx = endpointx.InjectName(ctx, "/leo.example.path.v1.Path/EnumPath")
	ctx = transportx.InjectName(ctx, httpx.HttpClient)
	rep, err := c.endpoints.EnumPath(ctx)(ctx, request)
	if err != nil {
		return nil, statusx.From(err)
	}
	return rep.(*emptypb.Empty), nil
}

func NewPathHttpClient(transports PathClientTransports, middlewares ...endpoint.Middleware) PathService {
	endpoints := newPathClientEndpoints(transports, middlewares...)
	return &pathHttpClient{endpoints: endpoints}
}

// =========================== http transport ===========================

func _Path_BoolPath_HttpServer_Transport(endpoints PathEndpoints) *http.Server {
	return http.NewServer(
		endpoints.BoolPath(context.TODO()),
		_Path_BoolPath_HttpServer_RequestDecoder,
		_Path_BoolPath_HttpServer_ResponseEncoder,
		http.ServerBefore(httpx.EndpointInjector("/leo.example.path.v1.Path/BoolPath")),
		http.ServerBefore(httpx.TransportInjector(httpx.HttpServer)),
		http.ServerBefore(httpx.IncomingMetadataInjector),
		http.ServerBefore(httpx.IncomingTimeLimiter),
		http.ServerFinalizer(httpx.CancelInvoker),
		http.ServerErrorEncoder(httpx.ErrorEncoder),
	)
}

func _Path_BoolPath_HttpClient_Transport(target string, router *mux.Router, options ...httpx.ClientTransportOption) func() (transportx.ClientTransport, error) {
	return func() (transportx.ClientTransport, error) {
		return httpx.NewClientTransport(
			target,
			httpx.ClientFactory(
				_Path_BoolPath_HttpClient_RequestEncoder(router),
				_Path_BoolPath_HttpClient_ResponseDecoder,
				http.ClientBefore(httpx.OutgoingMetadataInjector),
				http.ClientBefore(httpx.OutgoingTimeLimiter),
				http.ClientBefore(httpx.OutgoingStain),
			),
			options...,
		)
	}
}

func _Path_Int32Path_HttpServer_Transport(endpoints PathEndpoints) *http.Server {
	return http.NewServer(
		endpoints.Int32Path(context.TODO()),
		_Path_Int32Path_HttpServer_RequestDecoder,
		_Path_Int32Path_HttpServer_ResponseEncoder,
		http.ServerBefore(httpx.EndpointInjector("/leo.example.path.v1.Path/Int32Path")),
		http.ServerBefore(httpx.TransportInjector(httpx.HttpServer)),
		http.ServerBefore(httpx.IncomingMetadataInjector),
		http.ServerBefore(httpx.IncomingTimeLimiter),
		http.ServerFinalizer(httpx.CancelInvoker),
		http.ServerErrorEncoder(httpx.ErrorEncoder),
	)
}

func _Path_Int32Path_HttpClient_Transport(target string, router *mux.Router, options ...httpx.ClientTransportOption) func() (transportx.ClientTransport, error) {
	return func() (transportx.ClientTransport, error) {
		return httpx.NewClientTransport(
			target,
			httpx.ClientFactory(
				_Path_Int32Path_HttpClient_RequestEncoder(router),
				_Path_Int32Path_HttpClient_ResponseDecoder,
				http.ClientBefore(httpx.OutgoingMetadataInjector),
				http.ClientBefore(httpx.OutgoingTimeLimiter),
				http.ClientBefore(httpx.OutgoingStain),
			),
			options...,
		)
	}
}

func _Path_Int64Path_HttpServer_Transport(endpoints PathEndpoints) *http.Server {
	return http.NewServer(
		endpoints.Int64Path(context.TODO()),
		_Path_Int64Path_HttpServer_RequestDecoder,
		_Path_Int64Path_HttpServer_ResponseEncoder,
		http.ServerBefore(httpx.EndpointInjector("/leo.example.path.v1.Path/Int64Path")),
		http.ServerBefore(httpx.TransportInjector(httpx.HttpServer)),
		http.ServerBefore(httpx.IncomingMetadataInjector),
		http.ServerBefore(httpx.IncomingTimeLimiter),
		http.ServerFinalizer(httpx.CancelInvoker),
		http.ServerErrorEncoder(httpx.ErrorEncoder),
	)
}

func _Path_Int64Path_HttpClient_Transport(target string, router *mux.Router, options ...httpx.ClientTransportOption) func() (transportx.ClientTransport, error) {
	return func() (transportx.ClientTransport, error) {
		return httpx.NewClientTransport(
			target,
			httpx.ClientFactory(
				_Path_Int64Path_HttpClient_RequestEncoder(router),
				_Path_Int64Path_HttpClient_ResponseDecoder,
				http.ClientBefore(httpx.OutgoingMetadataInjector),
				http.ClientBefore(httpx.OutgoingTimeLimiter),
				http.ClientBefore(httpx.OutgoingStain),
			),
			options...,
		)
	}
}

func _Path_Uint32Path_HttpServer_Transport(endpoints PathEndpoints) *http.Server {
	return http.NewServer(
		endpoints.Uint32Path(context.TODO()),
		_Path_Uint32Path_HttpServer_RequestDecoder,
		_Path_Uint32Path_HttpServer_ResponseEncoder,
		http.ServerBefore(httpx.EndpointInjector("/leo.example.path.v1.Path/Uint32Path")),
		http.ServerBefore(httpx.TransportInjector(httpx.HttpServer)),
		http.ServerBefore(httpx.IncomingMetadataInjector),
		http.ServerBefore(httpx.IncomingTimeLimiter),
		http.ServerFinalizer(httpx.CancelInvoker),
		http.ServerErrorEncoder(httpx.ErrorEncoder),
	)
}

func _Path_Uint32Path_HttpClient_Transport(target string, router *mux.Router, options ...httpx.ClientTransportOption) func() (transportx.ClientTransport, error) {
	return func() (transportx.ClientTransport, error) {
		return httpx.NewClientTransport(
			target,
			httpx.ClientFactory(
				_Path_Uint32Path_HttpClient_RequestEncoder(router),
				_Path_Uint32Path_HttpClient_ResponseDecoder,
				http.ClientBefore(httpx.OutgoingMetadataInjector),
				http.ClientBefore(httpx.OutgoingTimeLimiter),
				http.ClientBefore(httpx.OutgoingStain),
			),
			options...,
		)
	}
}

func _Path_Uint64Path_HttpServer_Transport(endpoints PathEndpoints) *http.Server {
	return http.NewServer(
		endpoints.Uint64Path(context.TODO()),
		_Path_Uint64Path_HttpServer_RequestDecoder,
		_Path_Uint64Path_HttpServer_ResponseEncoder,
		http.ServerBefore(httpx.EndpointInjector("/leo.example.path.v1.Path/Uint64Path")),
		http.ServerBefore(httpx.TransportInjector(httpx.HttpServer)),
		http.ServerBefore(httpx.IncomingMetadataInjector),
		http.ServerBefore(httpx.IncomingTimeLimiter),
		http.ServerFinalizer(httpx.CancelInvoker),
		http.ServerErrorEncoder(httpx.ErrorEncoder),
	)
}

func _Path_Uint64Path_HttpClient_Transport(target string, router *mux.Router, options ...httpx.ClientTransportOption) func() (transportx.ClientTransport, error) {
	return func() (transportx.ClientTransport, error) {
		return httpx.NewClientTransport(
			target,
			httpx.ClientFactory(
				_Path_Uint64Path_HttpClient_RequestEncoder(router),
				_Path_Uint64Path_HttpClient_ResponseDecoder,
				http.ClientBefore(httpx.OutgoingMetadataInjector),
				http.ClientBefore(httpx.OutgoingTimeLimiter),
				http.ClientBefore(httpx.OutgoingStain),
			),
			options...,
		)
	}
}

func _Path_FloatPath_HttpServer_Transport(endpoints PathEndpoints) *http.Server {
	return http.NewServer(
		endpoints.FloatPath(context.TODO()),
		_Path_FloatPath_HttpServer_RequestDecoder,
		_Path_FloatPath_HttpServer_ResponseEncoder,
		http.ServerBefore(httpx.EndpointInjector("/leo.example.path.v1.Path/FloatPath")),
		http.ServerBefore(httpx.TransportInjector(httpx.HttpServer)),
		http.ServerBefore(httpx.IncomingMetadataInjector),
		http.ServerBefore(httpx.IncomingTimeLimiter),
		http.ServerFinalizer(httpx.CancelInvoker),
		http.ServerErrorEncoder(httpx.ErrorEncoder),
	)
}

func _Path_FloatPath_HttpClient_Transport(target string, router *mux.Router, options ...httpx.ClientTransportOption) func() (transportx.ClientTransport, error) {
	return func() (transportx.ClientTransport, error) {
		return httpx.NewClientTransport(
			target,
			httpx.ClientFactory(
				_Path_FloatPath_HttpClient_RequestEncoder(router),
				_Path_FloatPath_HttpClient_ResponseDecoder,
				http.ClientBefore(httpx.OutgoingMetadataInjector),
				http.ClientBefore(httpx.OutgoingTimeLimiter),
				http.ClientBefore(httpx.OutgoingStain),
			),
			options...,
		)
	}
}

func _Path_DoublePath_HttpServer_Transport(endpoints PathEndpoints) *http.Server {
	return http.NewServer(
		endpoints.DoublePath(context.TODO()),
		_Path_DoublePath_HttpServer_RequestDecoder,
		_Path_DoublePath_HttpServer_ResponseEncoder,
		http.ServerBefore(httpx.EndpointInjector("/leo.example.path.v1.Path/DoublePath")),
		http.ServerBefore(httpx.TransportInjector(httpx.HttpServer)),
		http.ServerBefore(httpx.IncomingMetadataInjector),
		http.ServerBefore(httpx.IncomingTimeLimiter),
		http.ServerFinalizer(httpx.CancelInvoker),
		http.ServerErrorEncoder(httpx.ErrorEncoder),
	)
}

func _Path_DoublePath_HttpClient_Transport(target string, router *mux.Router, options ...httpx.ClientTransportOption) func() (transportx.ClientTransport, error) {
	return func() (transportx.ClientTransport, error) {
		return httpx.NewClientTransport(
			target,
			httpx.ClientFactory(
				_Path_DoublePath_HttpClient_RequestEncoder(router),
				_Path_DoublePath_HttpClient_ResponseDecoder,
				http.ClientBefore(httpx.OutgoingMetadataInjector),
				http.ClientBefore(httpx.OutgoingTimeLimiter),
				http.ClientBefore(httpx.OutgoingStain),
			),
			options...,
		)
	}
}

func _Path_StringPath_HttpServer_Transport(endpoints PathEndpoints) *http.Server {
	return http.NewServer(
		endpoints.StringPath(context.TODO()),
		_Path_StringPath_HttpServer_RequestDecoder,
		_Path_StringPath_HttpServer_ResponseEncoder,
		http.ServerBefore(httpx.EndpointInjector("/leo.example.path.v1.Path/StringPath")),
		http.ServerBefore(httpx.TransportInjector(httpx.HttpServer)),
		http.ServerBefore(httpx.IncomingMetadataInjector),
		http.ServerBefore(httpx.IncomingTimeLimiter),
		http.ServerFinalizer(httpx.CancelInvoker),
		http.ServerErrorEncoder(httpx.ErrorEncoder),
	)
}

func _Path_StringPath_HttpClient_Transport(target string, router *mux.Router, options ...httpx.ClientTransportOption) func() (transportx.ClientTransport, error) {
	return func() (transportx.ClientTransport, error) {
		return httpx.NewClientTransport(
			target,
			httpx.ClientFactory(
				_Path_StringPath_HttpClient_RequestEncoder(router),
				_Path_StringPath_HttpClient_ResponseDecoder,
				http.ClientBefore(httpx.OutgoingMetadataInjector),
				http.ClientBefore(httpx.OutgoingTimeLimiter),
				http.ClientBefore(httpx.OutgoingStain),
			),
			options...,
		)
	}
}

func _Path_EnumPath_HttpServer_Transport(endpoints PathEndpoints) *http.Server {
	return http.NewServer(
		endpoints.EnumPath(context.TODO()),
		_Path_EnumPath_HttpServer_RequestDecoder,
		_Path_EnumPath_HttpServer_ResponseEncoder,
		http.ServerBefore(httpx.EndpointInjector("/leo.example.path.v1.Path/EnumPath")),
		http.ServerBefore(httpx.TransportInjector(httpx.HttpServer)),
		http.ServerBefore(httpx.IncomingMetadataInjector),
		http.ServerBefore(httpx.IncomingTimeLimiter),
		http.ServerFinalizer(httpx.CancelInvoker),
		http.ServerErrorEncoder(httpx.ErrorEncoder),
	)
}

func _Path_EnumPath_HttpClient_Transport(target string, router *mux.Router, options ...httpx.ClientTransportOption) func() (transportx.ClientTransport, error) {
	return func() (transportx.ClientTransport, error) {
		return httpx.NewClientTransport(
			target,
			httpx.ClientFactory(
				_Path_EnumPath_HttpClient_RequestEncoder(router),
				_Path_EnumPath_HttpClient_ResponseDecoder,
				http.ClientBefore(httpx.OutgoingMetadataInjector),
				http.ClientBefore(httpx.OutgoingTimeLimiter),
				http.ClientBefore(httpx.OutgoingStain),
			),
			options...,
		)
	}
}

// =========================== http coder ===========================

func _Path_BoolPath_HttpServer_RequestDecoder(ctx context.Context, r *http1.Request) (any, error) {
	req := &PathRequest{}
	vars := urlx.FormFromMap(mux.Vars(r))
	var varErr error
	req.Bool, varErr = errorx.Break[bool](varErr)(urlx.GetBool(vars, "bool"))
	req.OptBool, varErr = errorx.Break[*bool](varErr)(urlx.GetBoolPtr(vars, "opt_bool"))
	req.WrapBool, varErr = errorx.Break[*wrapperspb.BoolValue](varErr)(urlx.GetBoolValue(vars, "wrap_bool"))
	if varErr != nil {
		return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(varErr))
	}
	queries := r.URL.Query()
	var queryErr error
	req.Int32, queryErr = errorx.Break[int32](queryErr)(urlx.GetInt[int32](queries, "int32"))
	req.Sint32, queryErr = errorx.Break[int32](queryErr)(urlx.GetInt[int32](queries, "sint32"))
	req.Sfixed32, queryErr = errorx.Break[int32](queryErr)(urlx.GetInt[int32](queries, "sfixed32"))
	req.OptInt32, queryErr = errorx.Break[*int32](queryErr)(urlx.GetIntPtr[int32](queries, "opt_int32"))
	req.OptSint32, queryErr = errorx.Break[*int32](queryErr)(urlx.GetIntPtr[int32](queries, "opt_sint32"))
	req.OptSfixed32, queryErr = errorx.Break[*int32](queryErr)(urlx.GetIntPtr[int32](queries, "opt_sfixed32"))
	req.WrapInt32, queryErr = errorx.Break[*wrapperspb.Int32Value](queryErr)(urlx.GetInt32Value(queries, "wrap_int32"))
	req.Int64, queryErr = errorx.Break[int64](queryErr)(urlx.GetInt[int64](queries, "int64"))
	req.Sint64, queryErr = errorx.Break[int64](queryErr)(urlx.GetInt[int64](queries, "sint64"))
	req.Sfixed64, queryErr = errorx.Break[int64](queryErr)(urlx.GetInt[int64](queries, "sfixed64"))
	req.OptInt64, queryErr = errorx.Break[*int64](queryErr)(urlx.GetIntPtr[int64](queries, "opt_int64"))
	req.OptSint64, queryErr = errorx.Break[*int64](queryErr)(urlx.GetIntPtr[int64](queries, "opt_sint64"))
	req.OptSfixed64, queryErr = errorx.Break[*int64](queryErr)(urlx.GetIntPtr[int64](queries, "opt_sfixed64"))
	req.WrapInt64, queryErr = errorx.Break[*wrapperspb.Int64Value](queryErr)(urlx.GetInt64Value(queries, "wrap_int64"))
	req.Uint32, queryErr = errorx.Break[uint32](queryErr)(urlx.GetUint[uint32](queries, "uint32"))
	req.Fixed32, queryErr = errorx.Break[uint32](queryErr)(urlx.GetUint[uint32](queries, "fixed32"))
	req.OptUint32, queryErr = errorx.Break[*uint32](queryErr)(urlx.GetUintPtr[uint32](queries, "opt_uint32"))
	req.OptFixed32, queryErr = errorx.Break[*uint32](queryErr)(urlx.GetUintPtr[uint32](queries, "opt_fixed32"))
	req.WrapUint32, queryErr = errorx.Break[*wrapperspb.UInt32Value](queryErr)(urlx.GetUint32Value(queries, "wrap_uint32"))
	req.Uint64, queryErr = errorx.Break[uint64](queryErr)(urlx.GetUint[uint64](queries, "uint64"))
	req.Fixed64, queryErr = errorx.Break[uint64](queryErr)(urlx.GetUint[uint64](queries, "fixed64"))
	req.OptUint64, queryErr = errorx.Break[*uint64](queryErr)(urlx.GetUintPtr[uint64](queries, "opt_uint64"))
	req.OptFixed64, queryErr = errorx.Break[*uint64](queryErr)(urlx.GetUintPtr[uint64](queries, "opt_fixed64"))
	req.WrapUint64, queryErr = errorx.Break[*wrapperspb.UInt64Value](queryErr)(urlx.GetUint64Value(queries, "wrap_uint64"))
	req.Float, queryErr = errorx.Break[float32](queryErr)(urlx.GetFloat[float32](queries, "float"))
	req.OptFloat, queryErr = errorx.Break[*float32](queryErr)(urlx.GetFloatPtr[float32](queries, "opt_float"))
	req.WrapFloat, queryErr = errorx.Break[*wrapperspb.FloatValue](queryErr)(urlx.GetFloat32Value(queries, "wrap_float"))
	req.Double, queryErr = errorx.Break[float64](queryErr)(urlx.GetFloat[float64](queries, "double"))
	req.OptDouble, queryErr = errorx.Break[*float64](queryErr)(urlx.GetFloatPtr[float64](queries, "opt_double"))
	req.WrapDouble, queryErr = errorx.Break[*wrapperspb.DoubleValue](queryErr)(urlx.GetFloat64Value(queries, "wrap_double"))
	req.String_ = queries.Get("string")
	req.OptString = proto.String(queries.Get("opt_string"))
	req.WrapString = wrapperspb.String(queries.Get("wrap_string"))
	req.Status, queryErr = errorx.Break[PathRequest_Status](queryErr)(urlx.GetInt[PathRequest_Status](queries, "status"))
	req.OptStatus, queryErr = errorx.Break[*PathRequest_Status](queryErr)(urlx.GetIntPtr[PathRequest_Status](queries, "opt_status"))
	if queryErr != nil {
		return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(queryErr))
	}
	return req, nil
}

func _Path_BoolPath_HttpClient_RequestEncoder(router *mux.Router) func(scheme string, instance string) http.CreateRequestFunc {
	return func(scheme string, instance string) http.CreateRequestFunc {
		return func(ctx context.Context, obj any) (*http1.Request, error) {
			if obj == nil {
				return nil, statusx.ErrInvalidArgument.With(statusx.Message("request is nil"))
			}
			req, ok := obj.(*PathRequest)
			if !ok {
				return nil, statusx.ErrInvalidArgument.With(statusx.Message("invalid request type, %T", obj))
			}
			_ = req
			var body io.Reader
			var pairs []string
			pairs = append(pairs, "bool", strconvx.FormatBool(req.GetBool()), "opt_bool", strconvx.FormatBool(req.GetOptBool()), "wrap_bool", strconvx.FormatBool(req.GetWrapBool().GetValue()))
			path, err := router.Get("/leo.example.path.v1.Path/BoolPath").URLPath(pairs...)
			if err != nil {
				return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
			}
			queries := url.Values{}
			queries["int32"] = append(queries["int32"], strconvx.FormatInt(req.GetInt32(), 10))
			queries["sint32"] = append(queries["sint32"], strconvx.FormatInt(req.GetSint32(), 10))
			queries["sfixed32"] = append(queries["sfixed32"], strconvx.FormatInt(req.GetSfixed32(), 10))
			queries["opt_int32"] = append(queries["opt_int32"], strconvx.FormatInt(req.GetOptInt32(), 10))
			queries["opt_sint32"] = append(queries["opt_sint32"], strconvx.FormatInt(req.GetOptSint32(), 10))
			queries["opt_sfixed32"] = append(queries["opt_sfixed32"], strconvx.FormatInt(req.GetOptSfixed32(), 10))
			queries["wrap_int32"] = append(queries["wrap_int32"], strconvx.FormatInt(req.GetWrapInt32().GetValue(), 10))
			queries["int64"] = append(queries["int64"], strconvx.FormatInt(req.GetInt64(), 10))
			queries["sint64"] = append(queries["sint64"], strconvx.FormatInt(req.GetSint64(), 10))
			queries["sfixed64"] = append(queries["sfixed64"], strconvx.FormatInt(req.GetSfixed64(), 10))
			queries["opt_int64"] = append(queries["opt_int64"], strconvx.FormatInt(req.GetOptInt64(), 10))
			queries["opt_sint64"] = append(queries["opt_sint64"], strconvx.FormatInt(req.GetOptSint64(), 10))
			queries["opt_sfixed64"] = append(queries["opt_sfixed64"], strconvx.FormatInt(req.GetOptSfixed64(), 10))
			queries["wrap_int64"] = append(queries["wrap_int64"], strconvx.FormatInt(req.GetWrapInt64().GetValue(), 10))
			queries["uint32"] = append(queries["uint32"], strconvx.FormatUint(req.GetUint32(), 10))
			queries["fixed32"] = append(queries["fixed32"], strconvx.FormatUint(req.GetFixed32(), 10))
			queries["opt_uint32"] = append(queries["opt_uint32"], strconvx.FormatUint(req.GetOptUint32(), 10))
			queries["opt_fixed32"] = append(queries["opt_fixed32"], strconvx.FormatUint(req.GetOptFixed32(), 10))
			queries["wrap_uint32"] = append(queries["wrap_uint32"], strconvx.FormatUint(req.GetWrapUint32().GetValue(), 10))
			queries["uint64"] = append(queries["uint64"], strconvx.FormatUint(req.GetUint64(), 10))
			queries["fixed64"] = append(queries["fixed64"], strconvx.FormatUint(req.GetFixed64(), 10))
			queries["opt_uint64"] = append(queries["opt_uint64"], strconvx.FormatUint(req.GetOptUint64(), 10))
			queries["opt_fixed64"] = append(queries["opt_fixed64"], strconvx.FormatUint(req.GetOptFixed64(), 10))
			queries["wrap_uint64"] = append(queries["wrap_uint64"], strconvx.FormatUint(req.GetWrapUint64().GetValue(), 10))
			queries["float"] = append(queries["float"], strconvx.FormatFloat(req.GetFloat(), 'f', -1, 32))
			queries["opt_float"] = append(queries["opt_float"], strconvx.FormatFloat(req.GetOptFloat(), 'f', -1, 32))
			queries["wrap_float"] = append(queries["wrap_float"], strconvx.FormatFloat(req.GetWrapFloat().GetValue(), 'f', -1, 32))
			queries["double"] = append(queries["double"], strconvx.FormatFloat(req.GetDouble(), 'f', -1, 64))
			queries["opt_double"] = append(queries["opt_double"], strconvx.FormatFloat(req.GetOptDouble(), 'f', -1, 64))
			queries["wrap_double"] = append(queries["wrap_double"], strconvx.FormatFloat(req.GetWrapDouble().GetValue(), 'f', -1, 64))
			queries["string"] = append(queries["string"], req.GetString_())
			queries["opt_string"] = append(queries["opt_string"], req.GetOptString())
			queries["wrap_string"] = append(queries["wrap_string"], req.GetWrapString().GetValue())
			queries["status"] = append(queries["status"], strconvx.FormatInt(req.GetStatus(), 10))
			queries["opt_status"] = append(queries["opt_status"], strconvx.FormatInt(req.GetOptStatus(), 10))
			target := &url.URL{
				Scheme:   scheme,
				Host:     instance,
				Path:     path.Path,
				RawQuery: queries.Encode(),
			}
			r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
			if err != nil {
				return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
			}
			return r, nil
		}
	}
}

func _Path_BoolPath_HttpServer_ResponseEncoder(ctx context.Context, w http1.ResponseWriter, obj any) error {
	resp := obj.(*emptypb.Empty)
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(http1.StatusOK)
	if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
		return statusx.ErrInternal.With(statusx.Wrap(err))
	}
	return nil
}

func _Path_BoolPath_HttpClient_ResponseDecoder(ctx context.Context, r *http1.Response) (any, error) {
	if httpx.IsErrorResponse(r) {
		return nil, httpx.ErrorDecoder(ctx, r)
	}
	resp := &emptypb.Empty{}
	if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
		return nil, err
	}
	return resp, nil
}

func _Path_Int32Path_HttpServer_RequestDecoder(ctx context.Context, r *http1.Request) (any, error) {
	req := &PathRequest{}
	vars := urlx.FormFromMap(mux.Vars(r))
	var varErr error
	req.Int32, varErr = errorx.Break[int32](varErr)(urlx.GetInt[int32](vars, "int32"))
	req.Sint32, varErr = errorx.Break[int32](varErr)(urlx.GetInt[int32](vars, "sint32"))
	req.Sfixed32, varErr = errorx.Break[int32](varErr)(urlx.GetInt[int32](vars, "sfixed32"))
	req.OptInt32, varErr = errorx.Break[*int32](varErr)(urlx.GetIntPtr[int32](vars, "opt_int32"))
	req.OptSint32, varErr = errorx.Break[*int32](varErr)(urlx.GetIntPtr[int32](vars, "opt_sint32"))
	req.OptSfixed32, varErr = errorx.Break[*int32](varErr)(urlx.GetIntPtr[int32](vars, "opt_sfixed32"))
	req.WrapInt32, varErr = errorx.Break[*wrapperspb.Int32Value](varErr)(urlx.GetInt32Value(vars, "wrap_int32"))
	if varErr != nil {
		return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(varErr))
	}
	queries := r.URL.Query()
	var queryErr error
	req.Bool, queryErr = errorx.Break[bool](queryErr)(urlx.GetBool(queries, "bool"))
	req.OptBool, queryErr = errorx.Break[*bool](queryErr)(urlx.GetBoolPtr(queries, "opt_bool"))
	req.WrapBool, queryErr = errorx.Break[*wrapperspb.BoolValue](queryErr)(urlx.GetBoolValue(queries, "wrap_bool"))
	req.Int64, queryErr = errorx.Break[int64](queryErr)(urlx.GetInt[int64](queries, "int64"))
	req.Sint64, queryErr = errorx.Break[int64](queryErr)(urlx.GetInt[int64](queries, "sint64"))
	req.Sfixed64, queryErr = errorx.Break[int64](queryErr)(urlx.GetInt[int64](queries, "sfixed64"))
	req.OptInt64, queryErr = errorx.Break[*int64](queryErr)(urlx.GetIntPtr[int64](queries, "opt_int64"))
	req.OptSint64, queryErr = errorx.Break[*int64](queryErr)(urlx.GetIntPtr[int64](queries, "opt_sint64"))
	req.OptSfixed64, queryErr = errorx.Break[*int64](queryErr)(urlx.GetIntPtr[int64](queries, "opt_sfixed64"))
	req.WrapInt64, queryErr = errorx.Break[*wrapperspb.Int64Value](queryErr)(urlx.GetInt64Value(queries, "wrap_int64"))
	req.Uint32, queryErr = errorx.Break[uint32](queryErr)(urlx.GetUint[uint32](queries, "uint32"))
	req.Fixed32, queryErr = errorx.Break[uint32](queryErr)(urlx.GetUint[uint32](queries, "fixed32"))
	req.OptUint32, queryErr = errorx.Break[*uint32](queryErr)(urlx.GetUintPtr[uint32](queries, "opt_uint32"))
	req.OptFixed32, queryErr = errorx.Break[*uint32](queryErr)(urlx.GetUintPtr[uint32](queries, "opt_fixed32"))
	req.WrapUint32, queryErr = errorx.Break[*wrapperspb.UInt32Value](queryErr)(urlx.GetUint32Value(queries, "wrap_uint32"))
	req.Uint64, queryErr = errorx.Break[uint64](queryErr)(urlx.GetUint[uint64](queries, "uint64"))
	req.Fixed64, queryErr = errorx.Break[uint64](queryErr)(urlx.GetUint[uint64](queries, "fixed64"))
	req.OptUint64, queryErr = errorx.Break[*uint64](queryErr)(urlx.GetUintPtr[uint64](queries, "opt_uint64"))
	req.OptFixed64, queryErr = errorx.Break[*uint64](queryErr)(urlx.GetUintPtr[uint64](queries, "opt_fixed64"))
	req.WrapUint64, queryErr = errorx.Break[*wrapperspb.UInt64Value](queryErr)(urlx.GetUint64Value(queries, "wrap_uint64"))
	req.Float, queryErr = errorx.Break[float32](queryErr)(urlx.GetFloat[float32](queries, "float"))
	req.OptFloat, queryErr = errorx.Break[*float32](queryErr)(urlx.GetFloatPtr[float32](queries, "opt_float"))
	req.WrapFloat, queryErr = errorx.Break[*wrapperspb.FloatValue](queryErr)(urlx.GetFloat32Value(queries, "wrap_float"))
	req.Double, queryErr = errorx.Break[float64](queryErr)(urlx.GetFloat[float64](queries, "double"))
	req.OptDouble, queryErr = errorx.Break[*float64](queryErr)(urlx.GetFloatPtr[float64](queries, "opt_double"))
	req.WrapDouble, queryErr = errorx.Break[*wrapperspb.DoubleValue](queryErr)(urlx.GetFloat64Value(queries, "wrap_double"))
	req.String_ = queries.Get("string")
	req.OptString = proto.String(queries.Get("opt_string"))
	req.WrapString = wrapperspb.String(queries.Get("wrap_string"))
	req.Status, queryErr = errorx.Break[PathRequest_Status](queryErr)(urlx.GetInt[PathRequest_Status](queries, "status"))
	req.OptStatus, queryErr = errorx.Break[*PathRequest_Status](queryErr)(urlx.GetIntPtr[PathRequest_Status](queries, "opt_status"))
	if queryErr != nil {
		return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(queryErr))
	}
	return req, nil
}

func _Path_Int32Path_HttpClient_RequestEncoder(router *mux.Router) func(scheme string, instance string) http.CreateRequestFunc {
	return func(scheme string, instance string) http.CreateRequestFunc {
		return func(ctx context.Context, obj any) (*http1.Request, error) {
			if obj == nil {
				return nil, statusx.ErrInvalidArgument.With(statusx.Message("request is nil"))
			}
			req, ok := obj.(*PathRequest)
			if !ok {
				return nil, statusx.ErrInvalidArgument.With(statusx.Message("invalid request type, %T", obj))
			}
			_ = req
			var body io.Reader
			var pairs []string
			pairs = append(pairs, "int32", strconvx.FormatInt(req.GetInt32(), 10), "sint32", strconvx.FormatInt(req.GetSint32(), 10), "sfixed32", strconvx.FormatInt(req.GetSfixed32(), 10), "opt_int32", strconvx.FormatInt(req.GetOptInt32(), 10), "opt_sint32", strconvx.FormatInt(req.GetOptSint32(), 10), "opt_sfixed32", strconvx.FormatInt(req.GetOptSfixed32(), 10), "wrap_int32", strconvx.FormatInt(req.GetWrapInt32().GetValue(), 10))
			path, err := router.Get("/leo.example.path.v1.Path/Int32Path").URLPath(pairs...)
			if err != nil {
				return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
			}
			queries := url.Values{}
			queries["bool"] = append(queries["bool"], strconvx.FormatBool(req.GetBool()))
			queries["opt_bool"] = append(queries["opt_bool"], strconvx.FormatBool(req.GetOptBool()))
			queries["wrap_bool"] = append(queries["wrap_bool"], strconvx.FormatBool(req.GetWrapBool().GetValue()))
			queries["int64"] = append(queries["int64"], strconvx.FormatInt(req.GetInt64(), 10))
			queries["sint64"] = append(queries["sint64"], strconvx.FormatInt(req.GetSint64(), 10))
			queries["sfixed64"] = append(queries["sfixed64"], strconvx.FormatInt(req.GetSfixed64(), 10))
			queries["opt_int64"] = append(queries["opt_int64"], strconvx.FormatInt(req.GetOptInt64(), 10))
			queries["opt_sint64"] = append(queries["opt_sint64"], strconvx.FormatInt(req.GetOptSint64(), 10))
			queries["opt_sfixed64"] = append(queries["opt_sfixed64"], strconvx.FormatInt(req.GetOptSfixed64(), 10))
			queries["wrap_int64"] = append(queries["wrap_int64"], strconvx.FormatInt(req.GetWrapInt64().GetValue(), 10))
			queries["uint32"] = append(queries["uint32"], strconvx.FormatUint(req.GetUint32(), 10))
			queries["fixed32"] = append(queries["fixed32"], strconvx.FormatUint(req.GetFixed32(), 10))
			queries["opt_uint32"] = append(queries["opt_uint32"], strconvx.FormatUint(req.GetOptUint32(), 10))
			queries["opt_fixed32"] = append(queries["opt_fixed32"], strconvx.FormatUint(req.GetOptFixed32(), 10))
			queries["wrap_uint32"] = append(queries["wrap_uint32"], strconvx.FormatUint(req.GetWrapUint32().GetValue(), 10))
			queries["uint64"] = append(queries["uint64"], strconvx.FormatUint(req.GetUint64(), 10))
			queries["fixed64"] = append(queries["fixed64"], strconvx.FormatUint(req.GetFixed64(), 10))
			queries["opt_uint64"] = append(queries["opt_uint64"], strconvx.FormatUint(req.GetOptUint64(), 10))
			queries["opt_fixed64"] = append(queries["opt_fixed64"], strconvx.FormatUint(req.GetOptFixed64(), 10))
			queries["wrap_uint64"] = append(queries["wrap_uint64"], strconvx.FormatUint(req.GetWrapUint64().GetValue(), 10))
			queries["float"] = append(queries["float"], strconvx.FormatFloat(req.GetFloat(), 'f', -1, 32))
			queries["opt_float"] = append(queries["opt_float"], strconvx.FormatFloat(req.GetOptFloat(), 'f', -1, 32))
			queries["wrap_float"] = append(queries["wrap_float"], strconvx.FormatFloat(req.GetWrapFloat().GetValue(), 'f', -1, 32))
			queries["double"] = append(queries["double"], strconvx.FormatFloat(req.GetDouble(), 'f', -1, 64))
			queries["opt_double"] = append(queries["opt_double"], strconvx.FormatFloat(req.GetOptDouble(), 'f', -1, 64))
			queries["wrap_double"] = append(queries["wrap_double"], strconvx.FormatFloat(req.GetWrapDouble().GetValue(), 'f', -1, 64))
			queries["string"] = append(queries["string"], req.GetString_())
			queries["opt_string"] = append(queries["opt_string"], req.GetOptString())
			queries["wrap_string"] = append(queries["wrap_string"], req.GetWrapString().GetValue())
			queries["status"] = append(queries["status"], strconvx.FormatInt(req.GetStatus(), 10))
			queries["opt_status"] = append(queries["opt_status"], strconvx.FormatInt(req.GetOptStatus(), 10))
			target := &url.URL{
				Scheme:   scheme,
				Host:     instance,
				Path:     path.Path,
				RawQuery: queries.Encode(),
			}
			r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
			if err != nil {
				return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
			}
			return r, nil
		}
	}
}

func _Path_Int32Path_HttpServer_ResponseEncoder(ctx context.Context, w http1.ResponseWriter, obj any) error {
	resp := obj.(*emptypb.Empty)
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(http1.StatusOK)
	if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
		return statusx.ErrInternal.With(statusx.Wrap(err))
	}
	return nil
}

func _Path_Int32Path_HttpClient_ResponseDecoder(ctx context.Context, r *http1.Response) (any, error) {
	if httpx.IsErrorResponse(r) {
		return nil, httpx.ErrorDecoder(ctx, r)
	}
	resp := &emptypb.Empty{}
	if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
		return nil, err
	}
	return resp, nil
}

func _Path_Int64Path_HttpServer_RequestDecoder(ctx context.Context, r *http1.Request) (any, error) {
	req := &PathRequest{}
	vars := urlx.FormFromMap(mux.Vars(r))
	var varErr error
	req.Int64, varErr = errorx.Break[int64](varErr)(urlx.GetInt[int64](vars, "int64"))
	req.Sint64, varErr = errorx.Break[int64](varErr)(urlx.GetInt[int64](vars, "sint64"))
	req.Sfixed64, varErr = errorx.Break[int64](varErr)(urlx.GetInt[int64](vars, "sfixed64"))
	req.OptInt64, varErr = errorx.Break[*int64](varErr)(urlx.GetIntPtr[int64](vars, "opt_int64"))
	req.OptSint64, varErr = errorx.Break[*int64](varErr)(urlx.GetIntPtr[int64](vars, "opt_sint64"))
	req.OptSfixed64, varErr = errorx.Break[*int64](varErr)(urlx.GetIntPtr[int64](vars, "opt_sfixed64"))
	req.WrapInt64, varErr = errorx.Break[*wrapperspb.Int64Value](varErr)(urlx.GetInt64Value(vars, "wrap_int64"))
	if varErr != nil {
		return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(varErr))
	}
	queries := r.URL.Query()
	var queryErr error
	req.Bool, queryErr = errorx.Break[bool](queryErr)(urlx.GetBool(queries, "bool"))
	req.OptBool, queryErr = errorx.Break[*bool](queryErr)(urlx.GetBoolPtr(queries, "opt_bool"))
	req.WrapBool, queryErr = errorx.Break[*wrapperspb.BoolValue](queryErr)(urlx.GetBoolValue(queries, "wrap_bool"))
	req.Int32, queryErr = errorx.Break[int32](queryErr)(urlx.GetInt[int32](queries, "int32"))
	req.Sint32, queryErr = errorx.Break[int32](queryErr)(urlx.GetInt[int32](queries, "sint32"))
	req.Sfixed32, queryErr = errorx.Break[int32](queryErr)(urlx.GetInt[int32](queries, "sfixed32"))
	req.OptInt32, queryErr = errorx.Break[*int32](queryErr)(urlx.GetIntPtr[int32](queries, "opt_int32"))
	req.OptSint32, queryErr = errorx.Break[*int32](queryErr)(urlx.GetIntPtr[int32](queries, "opt_sint32"))
	req.OptSfixed32, queryErr = errorx.Break[*int32](queryErr)(urlx.GetIntPtr[int32](queries, "opt_sfixed32"))
	req.WrapInt32, queryErr = errorx.Break[*wrapperspb.Int32Value](queryErr)(urlx.GetInt32Value(queries, "wrap_int32"))
	req.Uint32, queryErr = errorx.Break[uint32](queryErr)(urlx.GetUint[uint32](queries, "uint32"))
	req.Fixed32, queryErr = errorx.Break[uint32](queryErr)(urlx.GetUint[uint32](queries, "fixed32"))
	req.OptUint32, queryErr = errorx.Break[*uint32](queryErr)(urlx.GetUintPtr[uint32](queries, "opt_uint32"))
	req.OptFixed32, queryErr = errorx.Break[*uint32](queryErr)(urlx.GetUintPtr[uint32](queries, "opt_fixed32"))
	req.WrapUint32, queryErr = errorx.Break[*wrapperspb.UInt32Value](queryErr)(urlx.GetUint32Value(queries, "wrap_uint32"))
	req.Uint64, queryErr = errorx.Break[uint64](queryErr)(urlx.GetUint[uint64](queries, "uint64"))
	req.Fixed64, queryErr = errorx.Break[uint64](queryErr)(urlx.GetUint[uint64](queries, "fixed64"))
	req.OptUint64, queryErr = errorx.Break[*uint64](queryErr)(urlx.GetUintPtr[uint64](queries, "opt_uint64"))
	req.OptFixed64, queryErr = errorx.Break[*uint64](queryErr)(urlx.GetUintPtr[uint64](queries, "opt_fixed64"))
	req.WrapUint64, queryErr = errorx.Break[*wrapperspb.UInt64Value](queryErr)(urlx.GetUint64Value(queries, "wrap_uint64"))
	req.Float, queryErr = errorx.Break[float32](queryErr)(urlx.GetFloat[float32](queries, "float"))
	req.OptFloat, queryErr = errorx.Break[*float32](queryErr)(urlx.GetFloatPtr[float32](queries, "opt_float"))
	req.WrapFloat, queryErr = errorx.Break[*wrapperspb.FloatValue](queryErr)(urlx.GetFloat32Value(queries, "wrap_float"))
	req.Double, queryErr = errorx.Break[float64](queryErr)(urlx.GetFloat[float64](queries, "double"))
	req.OptDouble, queryErr = errorx.Break[*float64](queryErr)(urlx.GetFloatPtr[float64](queries, "opt_double"))
	req.WrapDouble, queryErr = errorx.Break[*wrapperspb.DoubleValue](queryErr)(urlx.GetFloat64Value(queries, "wrap_double"))
	req.String_ = queries.Get("string")
	req.OptString = proto.String(queries.Get("opt_string"))
	req.WrapString = wrapperspb.String(queries.Get("wrap_string"))
	req.Status, queryErr = errorx.Break[PathRequest_Status](queryErr)(urlx.GetInt[PathRequest_Status](queries, "status"))
	req.OptStatus, queryErr = errorx.Break[*PathRequest_Status](queryErr)(urlx.GetIntPtr[PathRequest_Status](queries, "opt_status"))
	if queryErr != nil {
		return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(queryErr))
	}
	return req, nil
}

func _Path_Int64Path_HttpClient_RequestEncoder(router *mux.Router) func(scheme string, instance string) http.CreateRequestFunc {
	return func(scheme string, instance string) http.CreateRequestFunc {
		return func(ctx context.Context, obj any) (*http1.Request, error) {
			if obj == nil {
				return nil, statusx.ErrInvalidArgument.With(statusx.Message("request is nil"))
			}
			req, ok := obj.(*PathRequest)
			if !ok {
				return nil, statusx.ErrInvalidArgument.With(statusx.Message("invalid request type, %T", obj))
			}
			_ = req
			var body io.Reader
			var pairs []string
			pairs = append(pairs, "int64", strconvx.FormatInt(req.GetInt64(), 10), "sint64", strconvx.FormatInt(req.GetSint64(), 10), "sfixed64", strconvx.FormatInt(req.GetSfixed64(), 10), "opt_int64", strconvx.FormatInt(req.GetOptInt64(), 10), "opt_sint64", strconvx.FormatInt(req.GetOptSint64(), 10), "opt_sfixed64", strconvx.FormatInt(req.GetOptSfixed64(), 10), "wrap_int64", strconvx.FormatInt(req.GetWrapInt64().GetValue(), 10))
			path, err := router.Get("/leo.example.path.v1.Path/Int64Path").URLPath(pairs...)
			if err != nil {
				return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
			}
			queries := url.Values{}
			queries["bool"] = append(queries["bool"], strconvx.FormatBool(req.GetBool()))
			queries["opt_bool"] = append(queries["opt_bool"], strconvx.FormatBool(req.GetOptBool()))
			queries["wrap_bool"] = append(queries["wrap_bool"], strconvx.FormatBool(req.GetWrapBool().GetValue()))
			queries["int32"] = append(queries["int32"], strconvx.FormatInt(req.GetInt32(), 10))
			queries["sint32"] = append(queries["sint32"], strconvx.FormatInt(req.GetSint32(), 10))
			queries["sfixed32"] = append(queries["sfixed32"], strconvx.FormatInt(req.GetSfixed32(), 10))
			queries["opt_int32"] = append(queries["opt_int32"], strconvx.FormatInt(req.GetOptInt32(), 10))
			queries["opt_sint32"] = append(queries["opt_sint32"], strconvx.FormatInt(req.GetOptSint32(), 10))
			queries["opt_sfixed32"] = append(queries["opt_sfixed32"], strconvx.FormatInt(req.GetOptSfixed32(), 10))
			queries["wrap_int32"] = append(queries["wrap_int32"], strconvx.FormatInt(req.GetWrapInt32().GetValue(), 10))
			queries["uint32"] = append(queries["uint32"], strconvx.FormatUint(req.GetUint32(), 10))
			queries["fixed32"] = append(queries["fixed32"], strconvx.FormatUint(req.GetFixed32(), 10))
			queries["opt_uint32"] = append(queries["opt_uint32"], strconvx.FormatUint(req.GetOptUint32(), 10))
			queries["opt_fixed32"] = append(queries["opt_fixed32"], strconvx.FormatUint(req.GetOptFixed32(), 10))
			queries["wrap_uint32"] = append(queries["wrap_uint32"], strconvx.FormatUint(req.GetWrapUint32().GetValue(), 10))
			queries["uint64"] = append(queries["uint64"], strconvx.FormatUint(req.GetUint64(), 10))
			queries["fixed64"] = append(queries["fixed64"], strconvx.FormatUint(req.GetFixed64(), 10))
			queries["opt_uint64"] = append(queries["opt_uint64"], strconvx.FormatUint(req.GetOptUint64(), 10))
			queries["opt_fixed64"] = append(queries["opt_fixed64"], strconvx.FormatUint(req.GetOptFixed64(), 10))
			queries["wrap_uint64"] = append(queries["wrap_uint64"], strconvx.FormatUint(req.GetWrapUint64().GetValue(), 10))
			queries["float"] = append(queries["float"], strconvx.FormatFloat(req.GetFloat(), 'f', -1, 32))
			queries["opt_float"] = append(queries["opt_float"], strconvx.FormatFloat(req.GetOptFloat(), 'f', -1, 32))
			queries["wrap_float"] = append(queries["wrap_float"], strconvx.FormatFloat(req.GetWrapFloat().GetValue(), 'f', -1, 32))
			queries["double"] = append(queries["double"], strconvx.FormatFloat(req.GetDouble(), 'f', -1, 64))
			queries["opt_double"] = append(queries["opt_double"], strconvx.FormatFloat(req.GetOptDouble(), 'f', -1, 64))
			queries["wrap_double"] = append(queries["wrap_double"], strconvx.FormatFloat(req.GetWrapDouble().GetValue(), 'f', -1, 64))
			queries["string"] = append(queries["string"], req.GetString_())
			queries["opt_string"] = append(queries["opt_string"], req.GetOptString())
			queries["wrap_string"] = append(queries["wrap_string"], req.GetWrapString().GetValue())
			queries["status"] = append(queries["status"], strconvx.FormatInt(req.GetStatus(), 10))
			queries["opt_status"] = append(queries["opt_status"], strconvx.FormatInt(req.GetOptStatus(), 10))
			target := &url.URL{
				Scheme:   scheme,
				Host:     instance,
				Path:     path.Path,
				RawQuery: queries.Encode(),
			}
			r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
			if err != nil {
				return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
			}
			return r, nil
		}
	}
}

func _Path_Int64Path_HttpServer_ResponseEncoder(ctx context.Context, w http1.ResponseWriter, obj any) error {
	resp := obj.(*emptypb.Empty)
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(http1.StatusOK)
	if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
		return statusx.ErrInternal.With(statusx.Wrap(err))
	}
	return nil
}

func _Path_Int64Path_HttpClient_ResponseDecoder(ctx context.Context, r *http1.Response) (any, error) {
	if httpx.IsErrorResponse(r) {
		return nil, httpx.ErrorDecoder(ctx, r)
	}
	resp := &emptypb.Empty{}
	if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
		return nil, err
	}
	return resp, nil
}

func _Path_Uint32Path_HttpServer_RequestDecoder(ctx context.Context, r *http1.Request) (any, error) {
	req := &PathRequest{}
	vars := urlx.FormFromMap(mux.Vars(r))
	var varErr error
	req.Uint32, varErr = errorx.Break[uint32](varErr)(urlx.GetUint[uint32](vars, "uint32"))
	req.Fixed32, varErr = errorx.Break[uint32](varErr)(urlx.GetUint[uint32](vars, "fixed32"))
	req.OptUint32, varErr = errorx.Break[*uint32](varErr)(urlx.GetUintPtr[uint32](vars, "opt_uint32"))
	req.OptFixed32, varErr = errorx.Break[*uint32](varErr)(urlx.GetUintPtr[uint32](vars, "opt_fixed32"))
	req.WrapUint32, varErr = errorx.Break[*wrapperspb.UInt32Value](varErr)(urlx.GetUint32Value(vars, "wrap_uint32"))
	if varErr != nil {
		return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(varErr))
	}
	queries := r.URL.Query()
	var queryErr error
	req.Bool, queryErr = errorx.Break[bool](queryErr)(urlx.GetBool(queries, "bool"))
	req.OptBool, queryErr = errorx.Break[*bool](queryErr)(urlx.GetBoolPtr(queries, "opt_bool"))
	req.WrapBool, queryErr = errorx.Break[*wrapperspb.BoolValue](queryErr)(urlx.GetBoolValue(queries, "wrap_bool"))
	req.Int32, queryErr = errorx.Break[int32](queryErr)(urlx.GetInt[int32](queries, "int32"))
	req.Sint32, queryErr = errorx.Break[int32](queryErr)(urlx.GetInt[int32](queries, "sint32"))
	req.Sfixed32, queryErr = errorx.Break[int32](queryErr)(urlx.GetInt[int32](queries, "sfixed32"))
	req.OptInt32, queryErr = errorx.Break[*int32](queryErr)(urlx.GetIntPtr[int32](queries, "opt_int32"))
	req.OptSint32, queryErr = errorx.Break[*int32](queryErr)(urlx.GetIntPtr[int32](queries, "opt_sint32"))
	req.OptSfixed32, queryErr = errorx.Break[*int32](queryErr)(urlx.GetIntPtr[int32](queries, "opt_sfixed32"))
	req.WrapInt32, queryErr = errorx.Break[*wrapperspb.Int32Value](queryErr)(urlx.GetInt32Value(queries, "wrap_int32"))
	req.Int64, queryErr = errorx.Break[int64](queryErr)(urlx.GetInt[int64](queries, "int64"))
	req.Sint64, queryErr = errorx.Break[int64](queryErr)(urlx.GetInt[int64](queries, "sint64"))
	req.Sfixed64, queryErr = errorx.Break[int64](queryErr)(urlx.GetInt[int64](queries, "sfixed64"))
	req.OptInt64, queryErr = errorx.Break[*int64](queryErr)(urlx.GetIntPtr[int64](queries, "opt_int64"))
	req.OptSint64, queryErr = errorx.Break[*int64](queryErr)(urlx.GetIntPtr[int64](queries, "opt_sint64"))
	req.OptSfixed64, queryErr = errorx.Break[*int64](queryErr)(urlx.GetIntPtr[int64](queries, "opt_sfixed64"))
	req.WrapInt64, queryErr = errorx.Break[*wrapperspb.Int64Value](queryErr)(urlx.GetInt64Value(queries, "wrap_int64"))
	req.Uint64, queryErr = errorx.Break[uint64](queryErr)(urlx.GetUint[uint64](queries, "uint64"))
	req.Fixed64, queryErr = errorx.Break[uint64](queryErr)(urlx.GetUint[uint64](queries, "fixed64"))
	req.OptUint64, queryErr = errorx.Break[*uint64](queryErr)(urlx.GetUintPtr[uint64](queries, "opt_uint64"))
	req.OptFixed64, queryErr = errorx.Break[*uint64](queryErr)(urlx.GetUintPtr[uint64](queries, "opt_fixed64"))
	req.WrapUint64, queryErr = errorx.Break[*wrapperspb.UInt64Value](queryErr)(urlx.GetUint64Value(queries, "wrap_uint64"))
	req.Float, queryErr = errorx.Break[float32](queryErr)(urlx.GetFloat[float32](queries, "float"))
	req.OptFloat, queryErr = errorx.Break[*float32](queryErr)(urlx.GetFloatPtr[float32](queries, "opt_float"))
	req.WrapFloat, queryErr = errorx.Break[*wrapperspb.FloatValue](queryErr)(urlx.GetFloat32Value(queries, "wrap_float"))
	req.Double, queryErr = errorx.Break[float64](queryErr)(urlx.GetFloat[float64](queries, "double"))
	req.OptDouble, queryErr = errorx.Break[*float64](queryErr)(urlx.GetFloatPtr[float64](queries, "opt_double"))
	req.WrapDouble, queryErr = errorx.Break[*wrapperspb.DoubleValue](queryErr)(urlx.GetFloat64Value(queries, "wrap_double"))
	req.String_ = queries.Get("string")
	req.OptString = proto.String(queries.Get("opt_string"))
	req.WrapString = wrapperspb.String(queries.Get("wrap_string"))
	req.Status, queryErr = errorx.Break[PathRequest_Status](queryErr)(urlx.GetInt[PathRequest_Status](queries, "status"))
	req.OptStatus, queryErr = errorx.Break[*PathRequest_Status](queryErr)(urlx.GetIntPtr[PathRequest_Status](queries, "opt_status"))
	if queryErr != nil {
		return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(queryErr))
	}
	return req, nil
}

func _Path_Uint32Path_HttpClient_RequestEncoder(router *mux.Router) func(scheme string, instance string) http.CreateRequestFunc {
	return func(scheme string, instance string) http.CreateRequestFunc {
		return func(ctx context.Context, obj any) (*http1.Request, error) {
			if obj == nil {
				return nil, statusx.ErrInvalidArgument.With(statusx.Message("request is nil"))
			}
			req, ok := obj.(*PathRequest)
			if !ok {
				return nil, statusx.ErrInvalidArgument.With(statusx.Message("invalid request type, %T", obj))
			}
			_ = req
			var body io.Reader
			var pairs []string
			pairs = append(pairs, "uint32", strconvx.FormatUint(req.GetUint32(), 10), "fixed32", strconvx.FormatUint(req.GetFixed32(), 10), "opt_uint32", strconvx.FormatUint(req.GetOptUint32(), 10), "opt_fixed32", strconvx.FormatUint(req.GetOptFixed32(), 10), "wrap_uint32", strconvx.FormatUint(req.GetWrapUint32().GetValue(), 10))
			path, err := router.Get("/leo.example.path.v1.Path/Uint32Path").URLPath(pairs...)
			if err != nil {
				return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
			}
			queries := url.Values{}
			queries["bool"] = append(queries["bool"], strconvx.FormatBool(req.GetBool()))
			queries["opt_bool"] = append(queries["opt_bool"], strconvx.FormatBool(req.GetOptBool()))
			queries["wrap_bool"] = append(queries["wrap_bool"], strconvx.FormatBool(req.GetWrapBool().GetValue()))
			queries["int32"] = append(queries["int32"], strconvx.FormatInt(req.GetInt32(), 10))
			queries["sint32"] = append(queries["sint32"], strconvx.FormatInt(req.GetSint32(), 10))
			queries["sfixed32"] = append(queries["sfixed32"], strconvx.FormatInt(req.GetSfixed32(), 10))
			queries["opt_int32"] = append(queries["opt_int32"], strconvx.FormatInt(req.GetOptInt32(), 10))
			queries["opt_sint32"] = append(queries["opt_sint32"], strconvx.FormatInt(req.GetOptSint32(), 10))
			queries["opt_sfixed32"] = append(queries["opt_sfixed32"], strconvx.FormatInt(req.GetOptSfixed32(), 10))
			queries["wrap_int32"] = append(queries["wrap_int32"], strconvx.FormatInt(req.GetWrapInt32().GetValue(), 10))
			queries["int64"] = append(queries["int64"], strconvx.FormatInt(req.GetInt64(), 10))
			queries["sint64"] = append(queries["sint64"], strconvx.FormatInt(req.GetSint64(), 10))
			queries["sfixed64"] = append(queries["sfixed64"], strconvx.FormatInt(req.GetSfixed64(), 10))
			queries["opt_int64"] = append(queries["opt_int64"], strconvx.FormatInt(req.GetOptInt64(), 10))
			queries["opt_sint64"] = append(queries["opt_sint64"], strconvx.FormatInt(req.GetOptSint64(), 10))
			queries["opt_sfixed64"] = append(queries["opt_sfixed64"], strconvx.FormatInt(req.GetOptSfixed64(), 10))
			queries["wrap_int64"] = append(queries["wrap_int64"], strconvx.FormatInt(req.GetWrapInt64().GetValue(), 10))
			queries["uint64"] = append(queries["uint64"], strconvx.FormatUint(req.GetUint64(), 10))
			queries["fixed64"] = append(queries["fixed64"], strconvx.FormatUint(req.GetFixed64(), 10))
			queries["opt_uint64"] = append(queries["opt_uint64"], strconvx.FormatUint(req.GetOptUint64(), 10))
			queries["opt_fixed64"] = append(queries["opt_fixed64"], strconvx.FormatUint(req.GetOptFixed64(), 10))
			queries["wrap_uint64"] = append(queries["wrap_uint64"], strconvx.FormatUint(req.GetWrapUint64().GetValue(), 10))
			queries["float"] = append(queries["float"], strconvx.FormatFloat(req.GetFloat(), 'f', -1, 32))
			queries["opt_float"] = append(queries["opt_float"], strconvx.FormatFloat(req.GetOptFloat(), 'f', -1, 32))
			queries["wrap_float"] = append(queries["wrap_float"], strconvx.FormatFloat(req.GetWrapFloat().GetValue(), 'f', -1, 32))
			queries["double"] = append(queries["double"], strconvx.FormatFloat(req.GetDouble(), 'f', -1, 64))
			queries["opt_double"] = append(queries["opt_double"], strconvx.FormatFloat(req.GetOptDouble(), 'f', -1, 64))
			queries["wrap_double"] = append(queries["wrap_double"], strconvx.FormatFloat(req.GetWrapDouble().GetValue(), 'f', -1, 64))
			queries["string"] = append(queries["string"], req.GetString_())
			queries["opt_string"] = append(queries["opt_string"], req.GetOptString())
			queries["wrap_string"] = append(queries["wrap_string"], req.GetWrapString().GetValue())
			queries["status"] = append(queries["status"], strconvx.FormatInt(req.GetStatus(), 10))
			queries["opt_status"] = append(queries["opt_status"], strconvx.FormatInt(req.GetOptStatus(), 10))
			target := &url.URL{
				Scheme:   scheme,
				Host:     instance,
				Path:     path.Path,
				RawQuery: queries.Encode(),
			}
			r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
			if err != nil {
				return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
			}
			return r, nil
		}
	}
}

func _Path_Uint32Path_HttpServer_ResponseEncoder(ctx context.Context, w http1.ResponseWriter, obj any) error {
	resp := obj.(*emptypb.Empty)
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(http1.StatusOK)
	if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
		return statusx.ErrInternal.With(statusx.Wrap(err))
	}
	return nil
}

func _Path_Uint32Path_HttpClient_ResponseDecoder(ctx context.Context, r *http1.Response) (any, error) {
	if httpx.IsErrorResponse(r) {
		return nil, httpx.ErrorDecoder(ctx, r)
	}
	resp := &emptypb.Empty{}
	if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
		return nil, err
	}
	return resp, nil
}

func _Path_Uint64Path_HttpServer_RequestDecoder(ctx context.Context, r *http1.Request) (any, error) {
	req := &PathRequest{}
	vars := urlx.FormFromMap(mux.Vars(r))
	var varErr error
	req.Uint64, varErr = errorx.Break[uint64](varErr)(urlx.GetUint[uint64](vars, "uint64"))
	req.Fixed64, varErr = errorx.Break[uint64](varErr)(urlx.GetUint[uint64](vars, "fixed64"))
	req.OptUint64, varErr = errorx.Break[*uint64](varErr)(urlx.GetUintPtr[uint64](vars, "opt_uint64"))
	req.OptFixed64, varErr = errorx.Break[*uint64](varErr)(urlx.GetUintPtr[uint64](vars, "opt_fixed64"))
	req.WrapUint64, varErr = errorx.Break[*wrapperspb.UInt64Value](varErr)(urlx.GetUint64Value(vars, "wrap_uint64"))
	if varErr != nil {
		return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(varErr))
	}
	queries := r.URL.Query()
	var queryErr error
	req.Bool, queryErr = errorx.Break[bool](queryErr)(urlx.GetBool(queries, "bool"))
	req.OptBool, queryErr = errorx.Break[*bool](queryErr)(urlx.GetBoolPtr(queries, "opt_bool"))
	req.WrapBool, queryErr = errorx.Break[*wrapperspb.BoolValue](queryErr)(urlx.GetBoolValue(queries, "wrap_bool"))
	req.Int32, queryErr = errorx.Break[int32](queryErr)(urlx.GetInt[int32](queries, "int32"))
	req.Sint32, queryErr = errorx.Break[int32](queryErr)(urlx.GetInt[int32](queries, "sint32"))
	req.Sfixed32, queryErr = errorx.Break[int32](queryErr)(urlx.GetInt[int32](queries, "sfixed32"))
	req.OptInt32, queryErr = errorx.Break[*int32](queryErr)(urlx.GetIntPtr[int32](queries, "opt_int32"))
	req.OptSint32, queryErr = errorx.Break[*int32](queryErr)(urlx.GetIntPtr[int32](queries, "opt_sint32"))
	req.OptSfixed32, queryErr = errorx.Break[*int32](queryErr)(urlx.GetIntPtr[int32](queries, "opt_sfixed32"))
	req.WrapInt32, queryErr = errorx.Break[*wrapperspb.Int32Value](queryErr)(urlx.GetInt32Value(queries, "wrap_int32"))
	req.Int64, queryErr = errorx.Break[int64](queryErr)(urlx.GetInt[int64](queries, "int64"))
	req.Sint64, queryErr = errorx.Break[int64](queryErr)(urlx.GetInt[int64](queries, "sint64"))
	req.Sfixed64, queryErr = errorx.Break[int64](queryErr)(urlx.GetInt[int64](queries, "sfixed64"))
	req.OptInt64, queryErr = errorx.Break[*int64](queryErr)(urlx.GetIntPtr[int64](queries, "opt_int64"))
	req.OptSint64, queryErr = errorx.Break[*int64](queryErr)(urlx.GetIntPtr[int64](queries, "opt_sint64"))
	req.OptSfixed64, queryErr = errorx.Break[*int64](queryErr)(urlx.GetIntPtr[int64](queries, "opt_sfixed64"))
	req.WrapInt64, queryErr = errorx.Break[*wrapperspb.Int64Value](queryErr)(urlx.GetInt64Value(queries, "wrap_int64"))
	req.Uint32, queryErr = errorx.Break[uint32](queryErr)(urlx.GetUint[uint32](queries, "uint32"))
	req.Fixed32, queryErr = errorx.Break[uint32](queryErr)(urlx.GetUint[uint32](queries, "fixed32"))
	req.OptUint32, queryErr = errorx.Break[*uint32](queryErr)(urlx.GetUintPtr[uint32](queries, "opt_uint32"))
	req.OptFixed32, queryErr = errorx.Break[*uint32](queryErr)(urlx.GetUintPtr[uint32](queries, "opt_fixed32"))
	req.WrapUint32, queryErr = errorx.Break[*wrapperspb.UInt32Value](queryErr)(urlx.GetUint32Value(queries, "wrap_uint32"))
	req.Float, queryErr = errorx.Break[float32](queryErr)(urlx.GetFloat[float32](queries, "float"))
	req.OptFloat, queryErr = errorx.Break[*float32](queryErr)(urlx.GetFloatPtr[float32](queries, "opt_float"))
	req.WrapFloat, queryErr = errorx.Break[*wrapperspb.FloatValue](queryErr)(urlx.GetFloat32Value(queries, "wrap_float"))
	req.Double, queryErr = errorx.Break[float64](queryErr)(urlx.GetFloat[float64](queries, "double"))
	req.OptDouble, queryErr = errorx.Break[*float64](queryErr)(urlx.GetFloatPtr[float64](queries, "opt_double"))
	req.WrapDouble, queryErr = errorx.Break[*wrapperspb.DoubleValue](queryErr)(urlx.GetFloat64Value(queries, "wrap_double"))
	req.String_ = queries.Get("string")
	req.OptString = proto.String(queries.Get("opt_string"))
	req.WrapString = wrapperspb.String(queries.Get("wrap_string"))
	req.Status, queryErr = errorx.Break[PathRequest_Status](queryErr)(urlx.GetInt[PathRequest_Status](queries, "status"))
	req.OptStatus, queryErr = errorx.Break[*PathRequest_Status](queryErr)(urlx.GetIntPtr[PathRequest_Status](queries, "opt_status"))
	if queryErr != nil {
		return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(queryErr))
	}
	return req, nil
}

func _Path_Uint64Path_HttpClient_RequestEncoder(router *mux.Router) func(scheme string, instance string) http.CreateRequestFunc {
	return func(scheme string, instance string) http.CreateRequestFunc {
		return func(ctx context.Context, obj any) (*http1.Request, error) {
			if obj == nil {
				return nil, statusx.ErrInvalidArgument.With(statusx.Message("request is nil"))
			}
			req, ok := obj.(*PathRequest)
			if !ok {
				return nil, statusx.ErrInvalidArgument.With(statusx.Message("invalid request type, %T", obj))
			}
			_ = req
			var body io.Reader
			var pairs []string
			pairs = append(pairs, "uint64", strconvx.FormatUint(req.GetUint64(), 10), "fixed64", strconvx.FormatUint(req.GetFixed64(), 10), "opt_uint64", strconvx.FormatUint(req.GetOptUint64(), 10), "opt_fixed64", strconvx.FormatUint(req.GetOptFixed64(), 10), "wrap_uint64", strconvx.FormatUint(req.GetWrapUint64().GetValue(), 10))
			path, err := router.Get("/leo.example.path.v1.Path/Uint64Path").URLPath(pairs...)
			if err != nil {
				return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
			}
			queries := url.Values{}
			queries["bool"] = append(queries["bool"], strconvx.FormatBool(req.GetBool()))
			queries["opt_bool"] = append(queries["opt_bool"], strconvx.FormatBool(req.GetOptBool()))
			queries["wrap_bool"] = append(queries["wrap_bool"], strconvx.FormatBool(req.GetWrapBool().GetValue()))
			queries["int32"] = append(queries["int32"], strconvx.FormatInt(req.GetInt32(), 10))
			queries["sint32"] = append(queries["sint32"], strconvx.FormatInt(req.GetSint32(), 10))
			queries["sfixed32"] = append(queries["sfixed32"], strconvx.FormatInt(req.GetSfixed32(), 10))
			queries["opt_int32"] = append(queries["opt_int32"], strconvx.FormatInt(req.GetOptInt32(), 10))
			queries["opt_sint32"] = append(queries["opt_sint32"], strconvx.FormatInt(req.GetOptSint32(), 10))
			queries["opt_sfixed32"] = append(queries["opt_sfixed32"], strconvx.FormatInt(req.GetOptSfixed32(), 10))
			queries["wrap_int32"] = append(queries["wrap_int32"], strconvx.FormatInt(req.GetWrapInt32().GetValue(), 10))
			queries["int64"] = append(queries["int64"], strconvx.FormatInt(req.GetInt64(), 10))
			queries["sint64"] = append(queries["sint64"], strconvx.FormatInt(req.GetSint64(), 10))
			queries["sfixed64"] = append(queries["sfixed64"], strconvx.FormatInt(req.GetSfixed64(), 10))
			queries["opt_int64"] = append(queries["opt_int64"], strconvx.FormatInt(req.GetOptInt64(), 10))
			queries["opt_sint64"] = append(queries["opt_sint64"], strconvx.FormatInt(req.GetOptSint64(), 10))
			queries["opt_sfixed64"] = append(queries["opt_sfixed64"], strconvx.FormatInt(req.GetOptSfixed64(), 10))
			queries["wrap_int64"] = append(queries["wrap_int64"], strconvx.FormatInt(req.GetWrapInt64().GetValue(), 10))
			queries["uint32"] = append(queries["uint32"], strconvx.FormatUint(req.GetUint32(), 10))
			queries["fixed32"] = append(queries["fixed32"], strconvx.FormatUint(req.GetFixed32(), 10))
			queries["opt_uint32"] = append(queries["opt_uint32"], strconvx.FormatUint(req.GetOptUint32(), 10))
			queries["opt_fixed32"] = append(queries["opt_fixed32"], strconvx.FormatUint(req.GetOptFixed32(), 10))
			queries["wrap_uint32"] = append(queries["wrap_uint32"], strconvx.FormatUint(req.GetWrapUint32().GetValue(), 10))
			queries["float"] = append(queries["float"], strconvx.FormatFloat(req.GetFloat(), 'f', -1, 32))
			queries["opt_float"] = append(queries["opt_float"], strconvx.FormatFloat(req.GetOptFloat(), 'f', -1, 32))
			queries["wrap_float"] = append(queries["wrap_float"], strconvx.FormatFloat(req.GetWrapFloat().GetValue(), 'f', -1, 32))
			queries["double"] = append(queries["double"], strconvx.FormatFloat(req.GetDouble(), 'f', -1, 64))
			queries["opt_double"] = append(queries["opt_double"], strconvx.FormatFloat(req.GetOptDouble(), 'f', -1, 64))
			queries["wrap_double"] = append(queries["wrap_double"], strconvx.FormatFloat(req.GetWrapDouble().GetValue(), 'f', -1, 64))
			queries["string"] = append(queries["string"], req.GetString_())
			queries["opt_string"] = append(queries["opt_string"], req.GetOptString())
			queries["wrap_string"] = append(queries["wrap_string"], req.GetWrapString().GetValue())
			queries["status"] = append(queries["status"], strconvx.FormatInt(req.GetStatus(), 10))
			queries["opt_status"] = append(queries["opt_status"], strconvx.FormatInt(req.GetOptStatus(), 10))
			target := &url.URL{
				Scheme:   scheme,
				Host:     instance,
				Path:     path.Path,
				RawQuery: queries.Encode(),
			}
			r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
			if err != nil {
				return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
			}
			return r, nil
		}
	}
}

func _Path_Uint64Path_HttpServer_ResponseEncoder(ctx context.Context, w http1.ResponseWriter, obj any) error {
	resp := obj.(*emptypb.Empty)
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(http1.StatusOK)
	if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
		return statusx.ErrInternal.With(statusx.Wrap(err))
	}
	return nil
}

func _Path_Uint64Path_HttpClient_ResponseDecoder(ctx context.Context, r *http1.Response) (any, error) {
	if httpx.IsErrorResponse(r) {
		return nil, httpx.ErrorDecoder(ctx, r)
	}
	resp := &emptypb.Empty{}
	if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
		return nil, err
	}
	return resp, nil
}

func _Path_FloatPath_HttpServer_RequestDecoder(ctx context.Context, r *http1.Request) (any, error) {
	req := &PathRequest{}
	vars := urlx.FormFromMap(mux.Vars(r))
	var varErr error
	req.Float, varErr = errorx.Break[float32](varErr)(urlx.GetFloat[float32](vars, "float"))
	req.OptFloat, varErr = errorx.Break[*float32](varErr)(urlx.GetFloatPtr[float32](vars, "opt_float"))
	req.WrapFloat, varErr = errorx.Break[*wrapperspb.FloatValue](varErr)(urlx.GetFloat32Value(vars, "wrap_float"))
	if varErr != nil {
		return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(varErr))
	}
	queries := r.URL.Query()
	var queryErr error
	req.Bool, queryErr = errorx.Break[bool](queryErr)(urlx.GetBool(queries, "bool"))
	req.OptBool, queryErr = errorx.Break[*bool](queryErr)(urlx.GetBoolPtr(queries, "opt_bool"))
	req.WrapBool, queryErr = errorx.Break[*wrapperspb.BoolValue](queryErr)(urlx.GetBoolValue(queries, "wrap_bool"))
	req.Int32, queryErr = errorx.Break[int32](queryErr)(urlx.GetInt[int32](queries, "int32"))
	req.Sint32, queryErr = errorx.Break[int32](queryErr)(urlx.GetInt[int32](queries, "sint32"))
	req.Sfixed32, queryErr = errorx.Break[int32](queryErr)(urlx.GetInt[int32](queries, "sfixed32"))
	req.OptInt32, queryErr = errorx.Break[*int32](queryErr)(urlx.GetIntPtr[int32](queries, "opt_int32"))
	req.OptSint32, queryErr = errorx.Break[*int32](queryErr)(urlx.GetIntPtr[int32](queries, "opt_sint32"))
	req.OptSfixed32, queryErr = errorx.Break[*int32](queryErr)(urlx.GetIntPtr[int32](queries, "opt_sfixed32"))
	req.WrapInt32, queryErr = errorx.Break[*wrapperspb.Int32Value](queryErr)(urlx.GetInt32Value(queries, "wrap_int32"))
	req.Int64, queryErr = errorx.Break[int64](queryErr)(urlx.GetInt[int64](queries, "int64"))
	req.Sint64, queryErr = errorx.Break[int64](queryErr)(urlx.GetInt[int64](queries, "sint64"))
	req.Sfixed64, queryErr = errorx.Break[int64](queryErr)(urlx.GetInt[int64](queries, "sfixed64"))
	req.OptInt64, queryErr = errorx.Break[*int64](queryErr)(urlx.GetIntPtr[int64](queries, "opt_int64"))
	req.OptSint64, queryErr = errorx.Break[*int64](queryErr)(urlx.GetIntPtr[int64](queries, "opt_sint64"))
	req.OptSfixed64, queryErr = errorx.Break[*int64](queryErr)(urlx.GetIntPtr[int64](queries, "opt_sfixed64"))
	req.WrapInt64, queryErr = errorx.Break[*wrapperspb.Int64Value](queryErr)(urlx.GetInt64Value(queries, "wrap_int64"))
	req.Uint32, queryErr = errorx.Break[uint32](queryErr)(urlx.GetUint[uint32](queries, "uint32"))
	req.Fixed32, queryErr = errorx.Break[uint32](queryErr)(urlx.GetUint[uint32](queries, "fixed32"))
	req.OptUint32, queryErr = errorx.Break[*uint32](queryErr)(urlx.GetUintPtr[uint32](queries, "opt_uint32"))
	req.OptFixed32, queryErr = errorx.Break[*uint32](queryErr)(urlx.GetUintPtr[uint32](queries, "opt_fixed32"))
	req.WrapUint32, queryErr = errorx.Break[*wrapperspb.UInt32Value](queryErr)(urlx.GetUint32Value(queries, "wrap_uint32"))
	req.Uint64, queryErr = errorx.Break[uint64](queryErr)(urlx.GetUint[uint64](queries, "uint64"))
	req.Fixed64, queryErr = errorx.Break[uint64](queryErr)(urlx.GetUint[uint64](queries, "fixed64"))
	req.OptUint64, queryErr = errorx.Break[*uint64](queryErr)(urlx.GetUintPtr[uint64](queries, "opt_uint64"))
	req.OptFixed64, queryErr = errorx.Break[*uint64](queryErr)(urlx.GetUintPtr[uint64](queries, "opt_fixed64"))
	req.WrapUint64, queryErr = errorx.Break[*wrapperspb.UInt64Value](queryErr)(urlx.GetUint64Value(queries, "wrap_uint64"))
	req.Double, queryErr = errorx.Break[float64](queryErr)(urlx.GetFloat[float64](queries, "double"))
	req.OptDouble, queryErr = errorx.Break[*float64](queryErr)(urlx.GetFloatPtr[float64](queries, "opt_double"))
	req.WrapDouble, queryErr = errorx.Break[*wrapperspb.DoubleValue](queryErr)(urlx.GetFloat64Value(queries, "wrap_double"))
	req.String_ = queries.Get("string")
	req.OptString = proto.String(queries.Get("opt_string"))
	req.WrapString = wrapperspb.String(queries.Get("wrap_string"))
	req.Status, queryErr = errorx.Break[PathRequest_Status](queryErr)(urlx.GetInt[PathRequest_Status](queries, "status"))
	req.OptStatus, queryErr = errorx.Break[*PathRequest_Status](queryErr)(urlx.GetIntPtr[PathRequest_Status](queries, "opt_status"))
	if queryErr != nil {
		return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(queryErr))
	}
	return req, nil
}

func _Path_FloatPath_HttpClient_RequestEncoder(router *mux.Router) func(scheme string, instance string) http.CreateRequestFunc {
	return func(scheme string, instance string) http.CreateRequestFunc {
		return func(ctx context.Context, obj any) (*http1.Request, error) {
			if obj == nil {
				return nil, statusx.ErrInvalidArgument.With(statusx.Message("request is nil"))
			}
			req, ok := obj.(*PathRequest)
			if !ok {
				return nil, statusx.ErrInvalidArgument.With(statusx.Message("invalid request type, %T", obj))
			}
			_ = req
			var body io.Reader
			var pairs []string
			pairs = append(pairs, "float", strconvx.FormatFloat(req.GetFloat(), 'f', -1, 32), "opt_float", strconvx.FormatFloat(req.GetOptFloat(), 'f', -1, 32), "wrap_float", strconvx.FormatFloat(req.GetWrapFloat().GetValue(), 'f', -1, 32))
			path, err := router.Get("/leo.example.path.v1.Path/FloatPath").URLPath(pairs...)
			if err != nil {
				return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
			}
			queries := url.Values{}
			queries["bool"] = append(queries["bool"], strconvx.FormatBool(req.GetBool()))
			queries["opt_bool"] = append(queries["opt_bool"], strconvx.FormatBool(req.GetOptBool()))
			queries["wrap_bool"] = append(queries["wrap_bool"], strconvx.FormatBool(req.GetWrapBool().GetValue()))
			queries["int32"] = append(queries["int32"], strconvx.FormatInt(req.GetInt32(), 10))
			queries["sint32"] = append(queries["sint32"], strconvx.FormatInt(req.GetSint32(), 10))
			queries["sfixed32"] = append(queries["sfixed32"], strconvx.FormatInt(req.GetSfixed32(), 10))
			queries["opt_int32"] = append(queries["opt_int32"], strconvx.FormatInt(req.GetOptInt32(), 10))
			queries["opt_sint32"] = append(queries["opt_sint32"], strconvx.FormatInt(req.GetOptSint32(), 10))
			queries["opt_sfixed32"] = append(queries["opt_sfixed32"], strconvx.FormatInt(req.GetOptSfixed32(), 10))
			queries["wrap_int32"] = append(queries["wrap_int32"], strconvx.FormatInt(req.GetWrapInt32().GetValue(), 10))
			queries["int64"] = append(queries["int64"], strconvx.FormatInt(req.GetInt64(), 10))
			queries["sint64"] = append(queries["sint64"], strconvx.FormatInt(req.GetSint64(), 10))
			queries["sfixed64"] = append(queries["sfixed64"], strconvx.FormatInt(req.GetSfixed64(), 10))
			queries["opt_int64"] = append(queries["opt_int64"], strconvx.FormatInt(req.GetOptInt64(), 10))
			queries["opt_sint64"] = append(queries["opt_sint64"], strconvx.FormatInt(req.GetOptSint64(), 10))
			queries["opt_sfixed64"] = append(queries["opt_sfixed64"], strconvx.FormatInt(req.GetOptSfixed64(), 10))
			queries["wrap_int64"] = append(queries["wrap_int64"], strconvx.FormatInt(req.GetWrapInt64().GetValue(), 10))
			queries["uint32"] = append(queries["uint32"], strconvx.FormatUint(req.GetUint32(), 10))
			queries["fixed32"] = append(queries["fixed32"], strconvx.FormatUint(req.GetFixed32(), 10))
			queries["opt_uint32"] = append(queries["opt_uint32"], strconvx.FormatUint(req.GetOptUint32(), 10))
			queries["opt_fixed32"] = append(queries["opt_fixed32"], strconvx.FormatUint(req.GetOptFixed32(), 10))
			queries["wrap_uint32"] = append(queries["wrap_uint32"], strconvx.FormatUint(req.GetWrapUint32().GetValue(), 10))
			queries["uint64"] = append(queries["uint64"], strconvx.FormatUint(req.GetUint64(), 10))
			queries["fixed64"] = append(queries["fixed64"], strconvx.FormatUint(req.GetFixed64(), 10))
			queries["opt_uint64"] = append(queries["opt_uint64"], strconvx.FormatUint(req.GetOptUint64(), 10))
			queries["opt_fixed64"] = append(queries["opt_fixed64"], strconvx.FormatUint(req.GetOptFixed64(), 10))
			queries["wrap_uint64"] = append(queries["wrap_uint64"], strconvx.FormatUint(req.GetWrapUint64().GetValue(), 10))
			queries["double"] = append(queries["double"], strconvx.FormatFloat(req.GetDouble(), 'f', -1, 64))
			queries["opt_double"] = append(queries["opt_double"], strconvx.FormatFloat(req.GetOptDouble(), 'f', -1, 64))
			queries["wrap_double"] = append(queries["wrap_double"], strconvx.FormatFloat(req.GetWrapDouble().GetValue(), 'f', -1, 64))
			queries["string"] = append(queries["string"], req.GetString_())
			queries["opt_string"] = append(queries["opt_string"], req.GetOptString())
			queries["wrap_string"] = append(queries["wrap_string"], req.GetWrapString().GetValue())
			queries["status"] = append(queries["status"], strconvx.FormatInt(req.GetStatus(), 10))
			queries["opt_status"] = append(queries["opt_status"], strconvx.FormatInt(req.GetOptStatus(), 10))
			target := &url.URL{
				Scheme:   scheme,
				Host:     instance,
				Path:     path.Path,
				RawQuery: queries.Encode(),
			}
			r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
			if err != nil {
				return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
			}
			return r, nil
		}
	}
}

func _Path_FloatPath_HttpServer_ResponseEncoder(ctx context.Context, w http1.ResponseWriter, obj any) error {
	resp := obj.(*emptypb.Empty)
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(http1.StatusOK)
	if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
		return statusx.ErrInternal.With(statusx.Wrap(err))
	}
	return nil
}

func _Path_FloatPath_HttpClient_ResponseDecoder(ctx context.Context, r *http1.Response) (any, error) {
	if httpx.IsErrorResponse(r) {
		return nil, httpx.ErrorDecoder(ctx, r)
	}
	resp := &emptypb.Empty{}
	if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
		return nil, err
	}
	return resp, nil
}

func _Path_DoublePath_HttpServer_RequestDecoder(ctx context.Context, r *http1.Request) (any, error) {
	req := &PathRequest{}
	vars := urlx.FormFromMap(mux.Vars(r))
	var varErr error
	req.Double, varErr = errorx.Break[float64](varErr)(urlx.GetFloat[float64](vars, "double"))
	req.OptDouble, varErr = errorx.Break[*float64](varErr)(urlx.GetFloatPtr[float64](vars, "opt_double"))
	req.WrapDouble, varErr = errorx.Break[*wrapperspb.DoubleValue](varErr)(urlx.GetFloat64Value(vars, "wrap_double"))
	if varErr != nil {
		return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(varErr))
	}
	queries := r.URL.Query()
	var queryErr error
	req.Bool, queryErr = errorx.Break[bool](queryErr)(urlx.GetBool(queries, "bool"))
	req.OptBool, queryErr = errorx.Break[*bool](queryErr)(urlx.GetBoolPtr(queries, "opt_bool"))
	req.WrapBool, queryErr = errorx.Break[*wrapperspb.BoolValue](queryErr)(urlx.GetBoolValue(queries, "wrap_bool"))
	req.Int32, queryErr = errorx.Break[int32](queryErr)(urlx.GetInt[int32](queries, "int32"))
	req.Sint32, queryErr = errorx.Break[int32](queryErr)(urlx.GetInt[int32](queries, "sint32"))
	req.Sfixed32, queryErr = errorx.Break[int32](queryErr)(urlx.GetInt[int32](queries, "sfixed32"))
	req.OptInt32, queryErr = errorx.Break[*int32](queryErr)(urlx.GetIntPtr[int32](queries, "opt_int32"))
	req.OptSint32, queryErr = errorx.Break[*int32](queryErr)(urlx.GetIntPtr[int32](queries, "opt_sint32"))
	req.OptSfixed32, queryErr = errorx.Break[*int32](queryErr)(urlx.GetIntPtr[int32](queries, "opt_sfixed32"))
	req.WrapInt32, queryErr = errorx.Break[*wrapperspb.Int32Value](queryErr)(urlx.GetInt32Value(queries, "wrap_int32"))
	req.Int64, queryErr = errorx.Break[int64](queryErr)(urlx.GetInt[int64](queries, "int64"))
	req.Sint64, queryErr = errorx.Break[int64](queryErr)(urlx.GetInt[int64](queries, "sint64"))
	req.Sfixed64, queryErr = errorx.Break[int64](queryErr)(urlx.GetInt[int64](queries, "sfixed64"))
	req.OptInt64, queryErr = errorx.Break[*int64](queryErr)(urlx.GetIntPtr[int64](queries, "opt_int64"))
	req.OptSint64, queryErr = errorx.Break[*int64](queryErr)(urlx.GetIntPtr[int64](queries, "opt_sint64"))
	req.OptSfixed64, queryErr = errorx.Break[*int64](queryErr)(urlx.GetIntPtr[int64](queries, "opt_sfixed64"))
	req.WrapInt64, queryErr = errorx.Break[*wrapperspb.Int64Value](queryErr)(urlx.GetInt64Value(queries, "wrap_int64"))
	req.Uint32, queryErr = errorx.Break[uint32](queryErr)(urlx.GetUint[uint32](queries, "uint32"))
	req.Fixed32, queryErr = errorx.Break[uint32](queryErr)(urlx.GetUint[uint32](queries, "fixed32"))
	req.OptUint32, queryErr = errorx.Break[*uint32](queryErr)(urlx.GetUintPtr[uint32](queries, "opt_uint32"))
	req.OptFixed32, queryErr = errorx.Break[*uint32](queryErr)(urlx.GetUintPtr[uint32](queries, "opt_fixed32"))
	req.WrapUint32, queryErr = errorx.Break[*wrapperspb.UInt32Value](queryErr)(urlx.GetUint32Value(queries, "wrap_uint32"))
	req.Uint64, queryErr = errorx.Break[uint64](queryErr)(urlx.GetUint[uint64](queries, "uint64"))
	req.Fixed64, queryErr = errorx.Break[uint64](queryErr)(urlx.GetUint[uint64](queries, "fixed64"))
	req.OptUint64, queryErr = errorx.Break[*uint64](queryErr)(urlx.GetUintPtr[uint64](queries, "opt_uint64"))
	req.OptFixed64, queryErr = errorx.Break[*uint64](queryErr)(urlx.GetUintPtr[uint64](queries, "opt_fixed64"))
	req.WrapUint64, queryErr = errorx.Break[*wrapperspb.UInt64Value](queryErr)(urlx.GetUint64Value(queries, "wrap_uint64"))
	req.Float, queryErr = errorx.Break[float32](queryErr)(urlx.GetFloat[float32](queries, "float"))
	req.OptFloat, queryErr = errorx.Break[*float32](queryErr)(urlx.GetFloatPtr[float32](queries, "opt_float"))
	req.WrapFloat, queryErr = errorx.Break[*wrapperspb.FloatValue](queryErr)(urlx.GetFloat32Value(queries, "wrap_float"))
	req.String_ = queries.Get("string")
	req.OptString = proto.String(queries.Get("opt_string"))
	req.WrapString = wrapperspb.String(queries.Get("wrap_string"))
	req.Status, queryErr = errorx.Break[PathRequest_Status](queryErr)(urlx.GetInt[PathRequest_Status](queries, "status"))
	req.OptStatus, queryErr = errorx.Break[*PathRequest_Status](queryErr)(urlx.GetIntPtr[PathRequest_Status](queries, "opt_status"))
	if queryErr != nil {
		return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(queryErr))
	}
	return req, nil
}

func _Path_DoublePath_HttpClient_RequestEncoder(router *mux.Router) func(scheme string, instance string) http.CreateRequestFunc {
	return func(scheme string, instance string) http.CreateRequestFunc {
		return func(ctx context.Context, obj any) (*http1.Request, error) {
			if obj == nil {
				return nil, statusx.ErrInvalidArgument.With(statusx.Message("request is nil"))
			}
			req, ok := obj.(*PathRequest)
			if !ok {
				return nil, statusx.ErrInvalidArgument.With(statusx.Message("invalid request type, %T", obj))
			}
			_ = req
			var body io.Reader
			var pairs []string
			pairs = append(pairs, "double", strconvx.FormatFloat(req.GetDouble(), 'f', -1, 64), "opt_double", strconvx.FormatFloat(req.GetOptDouble(), 'f', -1, 64), "wrap_double", strconvx.FormatFloat(req.GetWrapDouble().GetValue(), 'f', -1, 64))
			path, err := router.Get("/leo.example.path.v1.Path/DoublePath").URLPath(pairs...)
			if err != nil {
				return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
			}
			queries := url.Values{}
			queries["bool"] = append(queries["bool"], strconvx.FormatBool(req.GetBool()))
			queries["opt_bool"] = append(queries["opt_bool"], strconvx.FormatBool(req.GetOptBool()))
			queries["wrap_bool"] = append(queries["wrap_bool"], strconvx.FormatBool(req.GetWrapBool().GetValue()))
			queries["int32"] = append(queries["int32"], strconvx.FormatInt(req.GetInt32(), 10))
			queries["sint32"] = append(queries["sint32"], strconvx.FormatInt(req.GetSint32(), 10))
			queries["sfixed32"] = append(queries["sfixed32"], strconvx.FormatInt(req.GetSfixed32(), 10))
			queries["opt_int32"] = append(queries["opt_int32"], strconvx.FormatInt(req.GetOptInt32(), 10))
			queries["opt_sint32"] = append(queries["opt_sint32"], strconvx.FormatInt(req.GetOptSint32(), 10))
			queries["opt_sfixed32"] = append(queries["opt_sfixed32"], strconvx.FormatInt(req.GetOptSfixed32(), 10))
			queries["wrap_int32"] = append(queries["wrap_int32"], strconvx.FormatInt(req.GetWrapInt32().GetValue(), 10))
			queries["int64"] = append(queries["int64"], strconvx.FormatInt(req.GetInt64(), 10))
			queries["sint64"] = append(queries["sint64"], strconvx.FormatInt(req.GetSint64(), 10))
			queries["sfixed64"] = append(queries["sfixed64"], strconvx.FormatInt(req.GetSfixed64(), 10))
			queries["opt_int64"] = append(queries["opt_int64"], strconvx.FormatInt(req.GetOptInt64(), 10))
			queries["opt_sint64"] = append(queries["opt_sint64"], strconvx.FormatInt(req.GetOptSint64(), 10))
			queries["opt_sfixed64"] = append(queries["opt_sfixed64"], strconvx.FormatInt(req.GetOptSfixed64(), 10))
			queries["wrap_int64"] = append(queries["wrap_int64"], strconvx.FormatInt(req.GetWrapInt64().GetValue(), 10))
			queries["uint32"] = append(queries["uint32"], strconvx.FormatUint(req.GetUint32(), 10))
			queries["fixed32"] = append(queries["fixed32"], strconvx.FormatUint(req.GetFixed32(), 10))
			queries["opt_uint32"] = append(queries["opt_uint32"], strconvx.FormatUint(req.GetOptUint32(), 10))
			queries["opt_fixed32"] = append(queries["opt_fixed32"], strconvx.FormatUint(req.GetOptFixed32(), 10))
			queries["wrap_uint32"] = append(queries["wrap_uint32"], strconvx.FormatUint(req.GetWrapUint32().GetValue(), 10))
			queries["uint64"] = append(queries["uint64"], strconvx.FormatUint(req.GetUint64(), 10))
			queries["fixed64"] = append(queries["fixed64"], strconvx.FormatUint(req.GetFixed64(), 10))
			queries["opt_uint64"] = append(queries["opt_uint64"], strconvx.FormatUint(req.GetOptUint64(), 10))
			queries["opt_fixed64"] = append(queries["opt_fixed64"], strconvx.FormatUint(req.GetOptFixed64(), 10))
			queries["wrap_uint64"] = append(queries["wrap_uint64"], strconvx.FormatUint(req.GetWrapUint64().GetValue(), 10))
			queries["float"] = append(queries["float"], strconvx.FormatFloat(req.GetFloat(), 'f', -1, 32))
			queries["opt_float"] = append(queries["opt_float"], strconvx.FormatFloat(req.GetOptFloat(), 'f', -1, 32))
			queries["wrap_float"] = append(queries["wrap_float"], strconvx.FormatFloat(req.GetWrapFloat().GetValue(), 'f', -1, 32))
			queries["string"] = append(queries["string"], req.GetString_())
			queries["opt_string"] = append(queries["opt_string"], req.GetOptString())
			queries["wrap_string"] = append(queries["wrap_string"], req.GetWrapString().GetValue())
			queries["status"] = append(queries["status"], strconvx.FormatInt(req.GetStatus(), 10))
			queries["opt_status"] = append(queries["opt_status"], strconvx.FormatInt(req.GetOptStatus(), 10))
			target := &url.URL{
				Scheme:   scheme,
				Host:     instance,
				Path:     path.Path,
				RawQuery: queries.Encode(),
			}
			r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
			if err != nil {
				return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
			}
			return r, nil
		}
	}
}

func _Path_DoublePath_HttpServer_ResponseEncoder(ctx context.Context, w http1.ResponseWriter, obj any) error {
	resp := obj.(*emptypb.Empty)
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(http1.StatusOK)
	if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
		return statusx.ErrInternal.With(statusx.Wrap(err))
	}
	return nil
}

func _Path_DoublePath_HttpClient_ResponseDecoder(ctx context.Context, r *http1.Response) (any, error) {
	if httpx.IsErrorResponse(r) {
		return nil, httpx.ErrorDecoder(ctx, r)
	}
	resp := &emptypb.Empty{}
	if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
		return nil, err
	}
	return resp, nil
}

func _Path_StringPath_HttpServer_RequestDecoder(ctx context.Context, r *http1.Request) (any, error) {
	req := &PathRequest{}
	vars := urlx.FormFromMap(mux.Vars(r))
	var varErr error
	req.String_ = vars.Get("string")
	req.OptString = proto.String(vars.Get("opt_string"))
	req.WrapString = wrapperspb.String(vars.Get("wrap_string"))
	if varErr != nil {
		return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(varErr))
	}
	queries := r.URL.Query()
	var queryErr error
	req.Bool, queryErr = errorx.Break[bool](queryErr)(urlx.GetBool(queries, "bool"))
	req.OptBool, queryErr = errorx.Break[*bool](queryErr)(urlx.GetBoolPtr(queries, "opt_bool"))
	req.WrapBool, queryErr = errorx.Break[*wrapperspb.BoolValue](queryErr)(urlx.GetBoolValue(queries, "wrap_bool"))
	req.Int32, queryErr = errorx.Break[int32](queryErr)(urlx.GetInt[int32](queries, "int32"))
	req.Sint32, queryErr = errorx.Break[int32](queryErr)(urlx.GetInt[int32](queries, "sint32"))
	req.Sfixed32, queryErr = errorx.Break[int32](queryErr)(urlx.GetInt[int32](queries, "sfixed32"))
	req.OptInt32, queryErr = errorx.Break[*int32](queryErr)(urlx.GetIntPtr[int32](queries, "opt_int32"))
	req.OptSint32, queryErr = errorx.Break[*int32](queryErr)(urlx.GetIntPtr[int32](queries, "opt_sint32"))
	req.OptSfixed32, queryErr = errorx.Break[*int32](queryErr)(urlx.GetIntPtr[int32](queries, "opt_sfixed32"))
	req.WrapInt32, queryErr = errorx.Break[*wrapperspb.Int32Value](queryErr)(urlx.GetInt32Value(queries, "wrap_int32"))
	req.Int64, queryErr = errorx.Break[int64](queryErr)(urlx.GetInt[int64](queries, "int64"))
	req.Sint64, queryErr = errorx.Break[int64](queryErr)(urlx.GetInt[int64](queries, "sint64"))
	req.Sfixed64, queryErr = errorx.Break[int64](queryErr)(urlx.GetInt[int64](queries, "sfixed64"))
	req.OptInt64, queryErr = errorx.Break[*int64](queryErr)(urlx.GetIntPtr[int64](queries, "opt_int64"))
	req.OptSint64, queryErr = errorx.Break[*int64](queryErr)(urlx.GetIntPtr[int64](queries, "opt_sint64"))
	req.OptSfixed64, queryErr = errorx.Break[*int64](queryErr)(urlx.GetIntPtr[int64](queries, "opt_sfixed64"))
	req.WrapInt64, queryErr = errorx.Break[*wrapperspb.Int64Value](queryErr)(urlx.GetInt64Value(queries, "wrap_int64"))
	req.Uint32, queryErr = errorx.Break[uint32](queryErr)(urlx.GetUint[uint32](queries, "uint32"))
	req.Fixed32, queryErr = errorx.Break[uint32](queryErr)(urlx.GetUint[uint32](queries, "fixed32"))
	req.OptUint32, queryErr = errorx.Break[*uint32](queryErr)(urlx.GetUintPtr[uint32](queries, "opt_uint32"))
	req.OptFixed32, queryErr = errorx.Break[*uint32](queryErr)(urlx.GetUintPtr[uint32](queries, "opt_fixed32"))
	req.WrapUint32, queryErr = errorx.Break[*wrapperspb.UInt32Value](queryErr)(urlx.GetUint32Value(queries, "wrap_uint32"))
	req.Uint64, queryErr = errorx.Break[uint64](queryErr)(urlx.GetUint[uint64](queries, "uint64"))
	req.Fixed64, queryErr = errorx.Break[uint64](queryErr)(urlx.GetUint[uint64](queries, "fixed64"))
	req.OptUint64, queryErr = errorx.Break[*uint64](queryErr)(urlx.GetUintPtr[uint64](queries, "opt_uint64"))
	req.OptFixed64, queryErr = errorx.Break[*uint64](queryErr)(urlx.GetUintPtr[uint64](queries, "opt_fixed64"))
	req.WrapUint64, queryErr = errorx.Break[*wrapperspb.UInt64Value](queryErr)(urlx.GetUint64Value(queries, "wrap_uint64"))
	req.Float, queryErr = errorx.Break[float32](queryErr)(urlx.GetFloat[float32](queries, "float"))
	req.OptFloat, queryErr = errorx.Break[*float32](queryErr)(urlx.GetFloatPtr[float32](queries, "opt_float"))
	req.WrapFloat, queryErr = errorx.Break[*wrapperspb.FloatValue](queryErr)(urlx.GetFloat32Value(queries, "wrap_float"))
	req.Double, queryErr = errorx.Break[float64](queryErr)(urlx.GetFloat[float64](queries, "double"))
	req.OptDouble, queryErr = errorx.Break[*float64](queryErr)(urlx.GetFloatPtr[float64](queries, "opt_double"))
	req.WrapDouble, queryErr = errorx.Break[*wrapperspb.DoubleValue](queryErr)(urlx.GetFloat64Value(queries, "wrap_double"))
	req.Status, queryErr = errorx.Break[PathRequest_Status](queryErr)(urlx.GetInt[PathRequest_Status](queries, "status"))
	req.OptStatus, queryErr = errorx.Break[*PathRequest_Status](queryErr)(urlx.GetIntPtr[PathRequest_Status](queries, "opt_status"))
	if queryErr != nil {
		return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(queryErr))
	}
	return req, nil
}

func _Path_StringPath_HttpClient_RequestEncoder(router *mux.Router) func(scheme string, instance string) http.CreateRequestFunc {
	return func(scheme string, instance string) http.CreateRequestFunc {
		return func(ctx context.Context, obj any) (*http1.Request, error) {
			if obj == nil {
				return nil, statusx.ErrInvalidArgument.With(statusx.Message("request is nil"))
			}
			req, ok := obj.(*PathRequest)
			if !ok {
				return nil, statusx.ErrInvalidArgument.With(statusx.Message("invalid request type, %T", obj))
			}
			_ = req
			var body io.Reader
			var pairs []string
			pairs = append(pairs, "string", req.GetString_(), "opt_string", req.GetOptString(), "wrap_string", req.GetWrapString().GetValue())
			path, err := router.Get("/leo.example.path.v1.Path/StringPath").URLPath(pairs...)
			if err != nil {
				return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
			}
			queries := url.Values{}
			queries["bool"] = append(queries["bool"], strconvx.FormatBool(req.GetBool()))
			queries["opt_bool"] = append(queries["opt_bool"], strconvx.FormatBool(req.GetOptBool()))
			queries["wrap_bool"] = append(queries["wrap_bool"], strconvx.FormatBool(req.GetWrapBool().GetValue()))
			queries["int32"] = append(queries["int32"], strconvx.FormatInt(req.GetInt32(), 10))
			queries["sint32"] = append(queries["sint32"], strconvx.FormatInt(req.GetSint32(), 10))
			queries["sfixed32"] = append(queries["sfixed32"], strconvx.FormatInt(req.GetSfixed32(), 10))
			queries["opt_int32"] = append(queries["opt_int32"], strconvx.FormatInt(req.GetOptInt32(), 10))
			queries["opt_sint32"] = append(queries["opt_sint32"], strconvx.FormatInt(req.GetOptSint32(), 10))
			queries["opt_sfixed32"] = append(queries["opt_sfixed32"], strconvx.FormatInt(req.GetOptSfixed32(), 10))
			queries["wrap_int32"] = append(queries["wrap_int32"], strconvx.FormatInt(req.GetWrapInt32().GetValue(), 10))
			queries["int64"] = append(queries["int64"], strconvx.FormatInt(req.GetInt64(), 10))
			queries["sint64"] = append(queries["sint64"], strconvx.FormatInt(req.GetSint64(), 10))
			queries["sfixed64"] = append(queries["sfixed64"], strconvx.FormatInt(req.GetSfixed64(), 10))
			queries["opt_int64"] = append(queries["opt_int64"], strconvx.FormatInt(req.GetOptInt64(), 10))
			queries["opt_sint64"] = append(queries["opt_sint64"], strconvx.FormatInt(req.GetOptSint64(), 10))
			queries["opt_sfixed64"] = append(queries["opt_sfixed64"], strconvx.FormatInt(req.GetOptSfixed64(), 10))
			queries["wrap_int64"] = append(queries["wrap_int64"], strconvx.FormatInt(req.GetWrapInt64().GetValue(), 10))
			queries["uint32"] = append(queries["uint32"], strconvx.FormatUint(req.GetUint32(), 10))
			queries["fixed32"] = append(queries["fixed32"], strconvx.FormatUint(req.GetFixed32(), 10))
			queries["opt_uint32"] = append(queries["opt_uint32"], strconvx.FormatUint(req.GetOptUint32(), 10))
			queries["opt_fixed32"] = append(queries["opt_fixed32"], strconvx.FormatUint(req.GetOptFixed32(), 10))
			queries["wrap_uint32"] = append(queries["wrap_uint32"], strconvx.FormatUint(req.GetWrapUint32().GetValue(), 10))
			queries["uint64"] = append(queries["uint64"], strconvx.FormatUint(req.GetUint64(), 10))
			queries["fixed64"] = append(queries["fixed64"], strconvx.FormatUint(req.GetFixed64(), 10))
			queries["opt_uint64"] = append(queries["opt_uint64"], strconvx.FormatUint(req.GetOptUint64(), 10))
			queries["opt_fixed64"] = append(queries["opt_fixed64"], strconvx.FormatUint(req.GetOptFixed64(), 10))
			queries["wrap_uint64"] = append(queries["wrap_uint64"], strconvx.FormatUint(req.GetWrapUint64().GetValue(), 10))
			queries["float"] = append(queries["float"], strconvx.FormatFloat(req.GetFloat(), 'f', -1, 32))
			queries["opt_float"] = append(queries["opt_float"], strconvx.FormatFloat(req.GetOptFloat(), 'f', -1, 32))
			queries["wrap_float"] = append(queries["wrap_float"], strconvx.FormatFloat(req.GetWrapFloat().GetValue(), 'f', -1, 32))
			queries["double"] = append(queries["double"], strconvx.FormatFloat(req.GetDouble(), 'f', -1, 64))
			queries["opt_double"] = append(queries["opt_double"], strconvx.FormatFloat(req.GetOptDouble(), 'f', -1, 64))
			queries["wrap_double"] = append(queries["wrap_double"], strconvx.FormatFloat(req.GetWrapDouble().GetValue(), 'f', -1, 64))
			queries["status"] = append(queries["status"], strconvx.FormatInt(req.GetStatus(), 10))
			queries["opt_status"] = append(queries["opt_status"], strconvx.FormatInt(req.GetOptStatus(), 10))
			target := &url.URL{
				Scheme:   scheme,
				Host:     instance,
				Path:     path.Path,
				RawQuery: queries.Encode(),
			}
			r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
			if err != nil {
				return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
			}
			return r, nil
		}
	}
}

func _Path_StringPath_HttpServer_ResponseEncoder(ctx context.Context, w http1.ResponseWriter, obj any) error {
	resp := obj.(*emptypb.Empty)
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(http1.StatusOK)
	if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
		return statusx.ErrInternal.With(statusx.Wrap(err))
	}
	return nil
}

func _Path_StringPath_HttpClient_ResponseDecoder(ctx context.Context, r *http1.Response) (any, error) {
	if httpx.IsErrorResponse(r) {
		return nil, httpx.ErrorDecoder(ctx, r)
	}
	resp := &emptypb.Empty{}
	if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
		return nil, err
	}
	return resp, nil
}

func _Path_EnumPath_HttpServer_RequestDecoder(ctx context.Context, r *http1.Request) (any, error) {
	req := &PathRequest{}
	vars := urlx.FormFromMap(mux.Vars(r))
	var varErr error
	req.Status, varErr = errorx.Break[PathRequest_Status](varErr)(urlx.GetInt[PathRequest_Status](vars, "status"))
	req.OptStatus, varErr = errorx.Break[*PathRequest_Status](varErr)(urlx.GetIntPtr[PathRequest_Status](vars, "opt_status"))
	if varErr != nil {
		return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(varErr))
	}
	queries := r.URL.Query()
	var queryErr error
	req.Bool, queryErr = errorx.Break[bool](queryErr)(urlx.GetBool(queries, "bool"))
	req.OptBool, queryErr = errorx.Break[*bool](queryErr)(urlx.GetBoolPtr(queries, "opt_bool"))
	req.WrapBool, queryErr = errorx.Break[*wrapperspb.BoolValue](queryErr)(urlx.GetBoolValue(queries, "wrap_bool"))
	req.Int32, queryErr = errorx.Break[int32](queryErr)(urlx.GetInt[int32](queries, "int32"))
	req.Sint32, queryErr = errorx.Break[int32](queryErr)(urlx.GetInt[int32](queries, "sint32"))
	req.Sfixed32, queryErr = errorx.Break[int32](queryErr)(urlx.GetInt[int32](queries, "sfixed32"))
	req.OptInt32, queryErr = errorx.Break[*int32](queryErr)(urlx.GetIntPtr[int32](queries, "opt_int32"))
	req.OptSint32, queryErr = errorx.Break[*int32](queryErr)(urlx.GetIntPtr[int32](queries, "opt_sint32"))
	req.OptSfixed32, queryErr = errorx.Break[*int32](queryErr)(urlx.GetIntPtr[int32](queries, "opt_sfixed32"))
	req.WrapInt32, queryErr = errorx.Break[*wrapperspb.Int32Value](queryErr)(urlx.GetInt32Value(queries, "wrap_int32"))
	req.Int64, queryErr = errorx.Break[int64](queryErr)(urlx.GetInt[int64](queries, "int64"))
	req.Sint64, queryErr = errorx.Break[int64](queryErr)(urlx.GetInt[int64](queries, "sint64"))
	req.Sfixed64, queryErr = errorx.Break[int64](queryErr)(urlx.GetInt[int64](queries, "sfixed64"))
	req.OptInt64, queryErr = errorx.Break[*int64](queryErr)(urlx.GetIntPtr[int64](queries, "opt_int64"))
	req.OptSint64, queryErr = errorx.Break[*int64](queryErr)(urlx.GetIntPtr[int64](queries, "opt_sint64"))
	req.OptSfixed64, queryErr = errorx.Break[*int64](queryErr)(urlx.GetIntPtr[int64](queries, "opt_sfixed64"))
	req.WrapInt64, queryErr = errorx.Break[*wrapperspb.Int64Value](queryErr)(urlx.GetInt64Value(queries, "wrap_int64"))
	req.Uint32, queryErr = errorx.Break[uint32](queryErr)(urlx.GetUint[uint32](queries, "uint32"))
	req.Fixed32, queryErr = errorx.Break[uint32](queryErr)(urlx.GetUint[uint32](queries, "fixed32"))
	req.OptUint32, queryErr = errorx.Break[*uint32](queryErr)(urlx.GetUintPtr[uint32](queries, "opt_uint32"))
	req.OptFixed32, queryErr = errorx.Break[*uint32](queryErr)(urlx.GetUintPtr[uint32](queries, "opt_fixed32"))
	req.WrapUint32, queryErr = errorx.Break[*wrapperspb.UInt32Value](queryErr)(urlx.GetUint32Value(queries, "wrap_uint32"))
	req.Uint64, queryErr = errorx.Break[uint64](queryErr)(urlx.GetUint[uint64](queries, "uint64"))
	req.Fixed64, queryErr = errorx.Break[uint64](queryErr)(urlx.GetUint[uint64](queries, "fixed64"))
	req.OptUint64, queryErr = errorx.Break[*uint64](queryErr)(urlx.GetUintPtr[uint64](queries, "opt_uint64"))
	req.OptFixed64, queryErr = errorx.Break[*uint64](queryErr)(urlx.GetUintPtr[uint64](queries, "opt_fixed64"))
	req.WrapUint64, queryErr = errorx.Break[*wrapperspb.UInt64Value](queryErr)(urlx.GetUint64Value(queries, "wrap_uint64"))
	req.Float, queryErr = errorx.Break[float32](queryErr)(urlx.GetFloat[float32](queries, "float"))
	req.OptFloat, queryErr = errorx.Break[*float32](queryErr)(urlx.GetFloatPtr[float32](queries, "opt_float"))
	req.WrapFloat, queryErr = errorx.Break[*wrapperspb.FloatValue](queryErr)(urlx.GetFloat32Value(queries, "wrap_float"))
	req.Double, queryErr = errorx.Break[float64](queryErr)(urlx.GetFloat[float64](queries, "double"))
	req.OptDouble, queryErr = errorx.Break[*float64](queryErr)(urlx.GetFloatPtr[float64](queries, "opt_double"))
	req.WrapDouble, queryErr = errorx.Break[*wrapperspb.DoubleValue](queryErr)(urlx.GetFloat64Value(queries, "wrap_double"))
	req.String_ = queries.Get("string")
	req.OptString = proto.String(queries.Get("opt_string"))
	req.WrapString = wrapperspb.String(queries.Get("wrap_string"))
	if queryErr != nil {
		return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(queryErr))
	}
	return req, nil
}

func _Path_EnumPath_HttpClient_RequestEncoder(router *mux.Router) func(scheme string, instance string) http.CreateRequestFunc {
	return func(scheme string, instance string) http.CreateRequestFunc {
		return func(ctx context.Context, obj any) (*http1.Request, error) {
			if obj == nil {
				return nil, statusx.ErrInvalidArgument.With(statusx.Message("request is nil"))
			}
			req, ok := obj.(*PathRequest)
			if !ok {
				return nil, statusx.ErrInvalidArgument.With(statusx.Message("invalid request type, %T", obj))
			}
			_ = req
			var body io.Reader
			var pairs []string
			pairs = append(pairs, "status", strconvx.FormatInt(req.GetStatus(), 10), "opt_status", strconvx.FormatInt(req.GetOptStatus(), 10))
			path, err := router.Get("/leo.example.path.v1.Path/EnumPath").URLPath(pairs...)
			if err != nil {
				return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
			}
			queries := url.Values{}
			queries["bool"] = append(queries["bool"], strconvx.FormatBool(req.GetBool()))
			queries["opt_bool"] = append(queries["opt_bool"], strconvx.FormatBool(req.GetOptBool()))
			queries["wrap_bool"] = append(queries["wrap_bool"], strconvx.FormatBool(req.GetWrapBool().GetValue()))
			queries["int32"] = append(queries["int32"], strconvx.FormatInt(req.GetInt32(), 10))
			queries["sint32"] = append(queries["sint32"], strconvx.FormatInt(req.GetSint32(), 10))
			queries["sfixed32"] = append(queries["sfixed32"], strconvx.FormatInt(req.GetSfixed32(), 10))
			queries["opt_int32"] = append(queries["opt_int32"], strconvx.FormatInt(req.GetOptInt32(), 10))
			queries["opt_sint32"] = append(queries["opt_sint32"], strconvx.FormatInt(req.GetOptSint32(), 10))
			queries["opt_sfixed32"] = append(queries["opt_sfixed32"], strconvx.FormatInt(req.GetOptSfixed32(), 10))
			queries["wrap_int32"] = append(queries["wrap_int32"], strconvx.FormatInt(req.GetWrapInt32().GetValue(), 10))
			queries["int64"] = append(queries["int64"], strconvx.FormatInt(req.GetInt64(), 10))
			queries["sint64"] = append(queries["sint64"], strconvx.FormatInt(req.GetSint64(), 10))
			queries["sfixed64"] = append(queries["sfixed64"], strconvx.FormatInt(req.GetSfixed64(), 10))
			queries["opt_int64"] = append(queries["opt_int64"], strconvx.FormatInt(req.GetOptInt64(), 10))
			queries["opt_sint64"] = append(queries["opt_sint64"], strconvx.FormatInt(req.GetOptSint64(), 10))
			queries["opt_sfixed64"] = append(queries["opt_sfixed64"], strconvx.FormatInt(req.GetOptSfixed64(), 10))
			queries["wrap_int64"] = append(queries["wrap_int64"], strconvx.FormatInt(req.GetWrapInt64().GetValue(), 10))
			queries["uint32"] = append(queries["uint32"], strconvx.FormatUint(req.GetUint32(), 10))
			queries["fixed32"] = append(queries["fixed32"], strconvx.FormatUint(req.GetFixed32(), 10))
			queries["opt_uint32"] = append(queries["opt_uint32"], strconvx.FormatUint(req.GetOptUint32(), 10))
			queries["opt_fixed32"] = append(queries["opt_fixed32"], strconvx.FormatUint(req.GetOptFixed32(), 10))
			queries["wrap_uint32"] = append(queries["wrap_uint32"], strconvx.FormatUint(req.GetWrapUint32().GetValue(), 10))
			queries["uint64"] = append(queries["uint64"], strconvx.FormatUint(req.GetUint64(), 10))
			queries["fixed64"] = append(queries["fixed64"], strconvx.FormatUint(req.GetFixed64(), 10))
			queries["opt_uint64"] = append(queries["opt_uint64"], strconvx.FormatUint(req.GetOptUint64(), 10))
			queries["opt_fixed64"] = append(queries["opt_fixed64"], strconvx.FormatUint(req.GetOptFixed64(), 10))
			queries["wrap_uint64"] = append(queries["wrap_uint64"], strconvx.FormatUint(req.GetWrapUint64().GetValue(), 10))
			queries["float"] = append(queries["float"], strconvx.FormatFloat(req.GetFloat(), 'f', -1, 32))
			queries["opt_float"] = append(queries["opt_float"], strconvx.FormatFloat(req.GetOptFloat(), 'f', -1, 32))
			queries["wrap_float"] = append(queries["wrap_float"], strconvx.FormatFloat(req.GetWrapFloat().GetValue(), 'f', -1, 32))
			queries["double"] = append(queries["double"], strconvx.FormatFloat(req.GetDouble(), 'f', -1, 64))
			queries["opt_double"] = append(queries["opt_double"], strconvx.FormatFloat(req.GetOptDouble(), 'f', -1, 64))
			queries["wrap_double"] = append(queries["wrap_double"], strconvx.FormatFloat(req.GetWrapDouble().GetValue(), 'f', -1, 64))
			queries["string"] = append(queries["string"], req.GetString_())
			queries["opt_string"] = append(queries["opt_string"], req.GetOptString())
			queries["wrap_string"] = append(queries["wrap_string"], req.GetWrapString().GetValue())
			target := &url.URL{
				Scheme:   scheme,
				Host:     instance,
				Path:     path.Path,
				RawQuery: queries.Encode(),
			}
			r, err := http1.NewRequestWithContext(ctx, "GET", target.String(), body)
			if err != nil {
				return nil, statusx.ErrInvalidArgument.With(statusx.Wrap(err))
			}
			return r, nil
		}
	}
}

func _Path_EnumPath_HttpServer_ResponseEncoder(ctx context.Context, w http1.ResponseWriter, obj any) error {
	resp := obj.(*emptypb.Empty)
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(http1.StatusOK)
	if err := jsonx.NewEncoder(w).Encode(resp); err != nil {
		return statusx.ErrInternal.With(statusx.Wrap(err))
	}
	return nil
}

func _Path_EnumPath_HttpClient_ResponseDecoder(ctx context.Context, r *http1.Response) (any, error) {
	if httpx.IsErrorResponse(r) {
		return nil, httpx.ErrorDecoder(ctx, r)
	}
	resp := &emptypb.Empty{}
	if err := jsonx.NewDecoder(r.Body).Decode(resp); err != nil {
		return nil, err
	}
	return resp, nil
}
