// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package path

import (
	context "context"
	errors "errors"
	fmt "fmt"
	endpoint "github.com/go-kit/kit/endpoint"
	http "github.com/go-kit/kit/transport/http"
	endpointx "github.com/go-leo/leo/v3/endpointx"
	mux "github.com/gorilla/mux"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	io "io"
	http1 "net/http"
	strconv "strconv"
	strings "strings"
	time "time"
)

type httpPathClient struct {
	namedPathString          endpoint.Endpoint
	namedPathOptString       endpoint.Endpoint
	namedPathWrapString      endpoint.Endpoint
	embedNamedPathString     endpoint.Endpoint
	embedNamedPathOptString  endpoint.Endpoint
	embedNamedPathWrapString endpoint.Endpoint
	boolPath                 endpoint.Endpoint
	int32Path                endpoint.Endpoint
	int64Path                endpoint.Endpoint
	uint32Path               endpoint.Endpoint
	uint64Path               endpoint.Endpoint
	floatPath                endpoint.Endpoint
	doublePath               endpoint.Endpoint
	stringPath               endpoint.Endpoint
	enumPath                 endpoint.Endpoint
	timePath                 endpoint.Endpoint
	mixPath                  endpoint.Endpoint
}

func (c *httpPathClient) NamedPathString(ctx context.Context, request *NamedPathRequest) (*emptypb.Empty, error) {
	rep, err := c.namedPathString(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpPathClient) NamedPathOptString(ctx context.Context, request *NamedPathRequest) (*emptypb.Empty, error) {
	rep, err := c.namedPathOptString(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpPathClient) NamedPathWrapString(ctx context.Context, request *NamedPathRequest) (*emptypb.Empty, error) {
	rep, err := c.namedPathWrapString(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpPathClient) EmbedNamedPathString(ctx context.Context, request *EmbedNamedPathRequest) (*emptypb.Empty, error) {
	rep, err := c.embedNamedPathString(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpPathClient) EmbedNamedPathOptString(ctx context.Context, request *EmbedNamedPathRequest) (*emptypb.Empty, error) {
	rep, err := c.embedNamedPathOptString(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpPathClient) EmbedNamedPathWrapString(ctx context.Context, request *EmbedNamedPathRequest) (*emptypb.Empty, error) {
	rep, err := c.embedNamedPathWrapString(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpPathClient) BoolPath(ctx context.Context, request *PathRequest) (*emptypb.Empty, error) {
	rep, err := c.boolPath(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpPathClient) Int32Path(ctx context.Context, request *PathRequest) (*emptypb.Empty, error) {
	rep, err := c.int32Path(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpPathClient) Int64Path(ctx context.Context, request *PathRequest) (*emptypb.Empty, error) {
	rep, err := c.int64Path(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpPathClient) Uint32Path(ctx context.Context, request *PathRequest) (*emptypb.Empty, error) {
	rep, err := c.uint32Path(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpPathClient) Uint64Path(ctx context.Context, request *PathRequest) (*emptypb.Empty, error) {
	rep, err := c.uint64Path(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpPathClient) FloatPath(ctx context.Context, request *PathRequest) (*emptypb.Empty, error) {
	rep, err := c.floatPath(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpPathClient) DoublePath(ctx context.Context, request *PathRequest) (*emptypb.Empty, error) {
	rep, err := c.doublePath(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpPathClient) StringPath(ctx context.Context, request *PathRequest) (*emptypb.Empty, error) {
	rep, err := c.stringPath(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpPathClient) EnumPath(ctx context.Context, request *PathRequest) (*emptypb.Empty, error) {
	rep, err := c.enumPath(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpPathClient) TimePath(ctx context.Context, request *PathRequest) (*emptypb.Empty, error) {
	rep, err := c.timePath(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func (c *httpPathClient) MixPath(ctx context.Context, request *MixPathRequest) (*emptypb.Empty, error) {
	rep, err := c.mixPath(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

func NewPathHTTPClient(
	instance string,
	mdw []endpoint.Middleware,
	opts ...http.ClientOption,
) interface {
	NamedPathString(ctx context.Context, request *NamedPathRequest) (*emptypb.Empty, error)
	NamedPathOptString(ctx context.Context, request *NamedPathRequest) (*emptypb.Empty, error)
	NamedPathWrapString(ctx context.Context, request *NamedPathRequest) (*emptypb.Empty, error)
	EmbedNamedPathString(ctx context.Context, request *EmbedNamedPathRequest) (*emptypb.Empty, error)
	EmbedNamedPathOptString(ctx context.Context, request *EmbedNamedPathRequest) (*emptypb.Empty, error)
	EmbedNamedPathWrapString(ctx context.Context, request *EmbedNamedPathRequest) (*emptypb.Empty, error)
	BoolPath(ctx context.Context, request *PathRequest) (*emptypb.Empty, error)
	Int32Path(ctx context.Context, request *PathRequest) (*emptypb.Empty, error)
	Int64Path(ctx context.Context, request *PathRequest) (*emptypb.Empty, error)
	Uint32Path(ctx context.Context, request *PathRequest) (*emptypb.Empty, error)
	Uint64Path(ctx context.Context, request *PathRequest) (*emptypb.Empty, error)
	FloatPath(ctx context.Context, request *PathRequest) (*emptypb.Empty, error)
	DoublePath(ctx context.Context, request *PathRequest) (*emptypb.Empty, error)
	StringPath(ctx context.Context, request *PathRequest) (*emptypb.Empty, error)
	EnumPath(ctx context.Context, request *PathRequest) (*emptypb.Empty, error)
	TimePath(ctx context.Context, request *PathRequest) (*emptypb.Empty, error)
	MixPath(ctx context.Context, request *MixPathRequest) (*emptypb.Empty, error)
} {
	router := mux.NewRouter()
	router.NewRoute().
		Name("/leo.example.path.v1.Path/NamedPathString").
		Methods("GET").
		Path("/v1/string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}")
	router.NewRoute().
		Name("/leo.example.path.v1.Path/NamedPathOptString").
		Methods("GET").
		Path("/v1/opt_string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}")
	router.NewRoute().
		Name("/leo.example.path.v1.Path/NamedPathWrapString").
		Methods("GET").
		Path("/v1/wrap_string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}")
	router.NewRoute().
		Name("/leo.example.path.v1.Path/EmbedNamedPathString").
		Methods("GET").
		Path("/v1/embed/string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}")
	router.NewRoute().
		Name("/leo.example.path.v1.Path/EmbedNamedPathOptString").
		Methods("GET").
		Path("/v1/embed/opt_string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}")
	router.NewRoute().
		Name("/leo.example.path.v1.Path/EmbedNamedPathWrapString").
		Methods("GET").
		Path("/v1/embed/wrap_string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}")
	router.NewRoute().
		Name("/leo.example.path.v1.Path/BoolPath").
		Methods("GET").
		Path("/v1/{bool}/{opt_bool}/{wrap_bool}")
	router.NewRoute().
		Name("/leo.example.path.v1.Path/Int32Path").
		Methods("GET").
		Path("/v1/{int32}/{sint32}/{sfixed32}/{opt_int32}/{opt_sint32}/{opt_sfixed32}/{wrap_int32}")
	router.NewRoute().
		Name("/leo.example.path.v1.Path/Int64Path").
		Methods("GET").
		Path("/v1/{int64}/{sint64}/{sfixed64}/{opt_int64}/{opt_sint64}/{opt_sfixed64}/{wrap_int64}")
	router.NewRoute().
		Name("/leo.example.path.v1.Path/Uint32Path").
		Methods("GET").
		Path("/v1/{uint32}/{fixed32}/{opt_uint32}/{opt_fixed32}/{wrap_uint32}")
	router.NewRoute().
		Name("/leo.example.path.v1.Path/Uint64Path").
		Methods("GET").
		Path("/v1/{uint64}/{fixed64}/{opt_uint64}/{opt_fixed64}/{wrap_uint64}")
	router.NewRoute().
		Name("/leo.example.path.v1.Path/FloatPath").
		Methods("GET").
		Path("/v1/{float}/{opt_float}/{wrap_float}")
	router.NewRoute().
		Name("/leo.example.path.v1.Path/DoublePath").
		Methods("GET").
		Path("/v1/{double}/{opt_double}/{wrap_double}")
	router.NewRoute().
		Name("/leo.example.path.v1.Path/StringPath").
		Methods("GET").
		Path("/v1/{string}/{opt_string}/{wrap_string}")
	router.NewRoute().
		Name("/leo.example.path.v1.Path/EnumPath").
		Methods("GET").
		Path("/v1/{status}/{opt_status}")
	router.NewRoute().
		Name("/leo.example.path.v1.Path/TimePath").
		Methods("GET").
		Path("/v1/{timestamp}/{duration}")
	router.NewRoute().
		Name("/leo.example.path.v1.Path/MixPath").
		Methods("GET").
		Path("/v1/{string}/{opt_string}/{wrap_string}/classes/{class}/shelves/{shelf}/books/{book}/families/{family}")
	return &httpPathClient{
		namedPathString: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					req, ok := obj.(*NamedPathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "GET"
					var url string
					var body io.Reader
					var pairs []string
					namedPathParameter := req.String_
					namedPathValues := strings.Split(namedPathParameter, "/")
					if len(namedPathValues) != 8 {
						return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
					}
					pairs = append(pairs, "class", namedPathValues[1], "shelf", namedPathValues[3], "book", namedPathValues[5], "family", namedPathValues[7])
					path, err := router.Get("/leo.example.path.v1.Path/NamedPathString").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http1.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		namedPathOptString: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					req, ok := obj.(*NamedPathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "GET"
					var url string
					var body io.Reader
					var pairs []string
					namedPathParameter := *req.OptString
					namedPathValues := strings.Split(namedPathParameter, "/")
					if len(namedPathValues) != 8 {
						return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
					}
					pairs = append(pairs, "class", namedPathValues[1], "shelf", namedPathValues[3], "book", namedPathValues[5], "family", namedPathValues[7])
					path, err := router.Get("/leo.example.path.v1.Path/NamedPathOptString").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http1.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		namedPathWrapString: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					req, ok := obj.(*NamedPathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "GET"
					var url string
					var body io.Reader
					var pairs []string
					namedPathParameter := req.WrapString.Value
					namedPathValues := strings.Split(namedPathParameter, "/")
					if len(namedPathValues) != 8 {
						return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
					}
					pairs = append(pairs, "class", namedPathValues[1], "shelf", namedPathValues[3], "book", namedPathValues[5], "family", namedPathValues[7])
					path, err := router.Get("/leo.example.path.v1.Path/NamedPathWrapString").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http1.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		embedNamedPathString: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					req, ok := obj.(*EmbedNamedPathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "GET"
					var url string
					var body io.Reader
					var pairs []string
					if req.Embed == nil {
						return nil, fmt.Errorf("%s is nil", "req.Embed")
					}
					namedPathParameter := req.Embed.String_
					namedPathValues := strings.Split(namedPathParameter, "/")
					if len(namedPathValues) != 8 {
						return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
					}
					pairs = append(pairs, "class", namedPathValues[1], "shelf", namedPathValues[3], "book", namedPathValues[5], "family", namedPathValues[7])
					path, err := router.Get("/leo.example.path.v1.Path/EmbedNamedPathString").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http1.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		embedNamedPathOptString: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					req, ok := obj.(*EmbedNamedPathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "GET"
					var url string
					var body io.Reader
					var pairs []string
					if req.Embed == nil {
						return nil, fmt.Errorf("%s is nil", "req.Embed")
					}
					namedPathParameter := *req.Embed.OptString
					namedPathValues := strings.Split(namedPathParameter, "/")
					if len(namedPathValues) != 8 {
						return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
					}
					pairs = append(pairs, "class", namedPathValues[1], "shelf", namedPathValues[3], "book", namedPathValues[5], "family", namedPathValues[7])
					path, err := router.Get("/leo.example.path.v1.Path/EmbedNamedPathOptString").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http1.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		embedNamedPathWrapString: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					req, ok := obj.(*EmbedNamedPathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "GET"
					var url string
					var body io.Reader
					var pairs []string
					if req.Embed == nil {
						return nil, fmt.Errorf("%s is nil", "req.Embed")
					}
					namedPathParameter := req.Embed.WrapString.Value
					namedPathValues := strings.Split(namedPathParameter, "/")
					if len(namedPathValues) != 8 {
						return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
					}
					pairs = append(pairs, "class", namedPathValues[1], "shelf", namedPathValues[3], "book", namedPathValues[5], "family", namedPathValues[7])
					path, err := router.Get("/leo.example.path.v1.Path/EmbedNamedPathWrapString").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http1.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		boolPath: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					req, ok := obj.(*PathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "GET"
					var url string
					var body io.Reader
					var pairs []string
					if req.OptBool == nil {
						return nil, fmt.Errorf("%s is nil", "req.OptBool")
					}
					if req.WrapBool == nil {
						return nil, fmt.Errorf("%s is nil", "req.WrapBool")
					}
					pairs = append(pairs, "bool", strconv.FormatBool(req.Bool), "opt_bool", strconv.FormatBool(*req.OptBool), "wrap_bool", strconv.FormatBool(req.WrapBool.Value))
					path, err := router.Get("/leo.example.path.v1.Path/BoolPath").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http1.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		int32Path: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					req, ok := obj.(*PathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "GET"
					var url string
					var body io.Reader
					var pairs []string
					if req.OptInt32 == nil {
						return nil, fmt.Errorf("%s is nil", "req.OptInt32")
					}
					if req.OptSint32 == nil {
						return nil, fmt.Errorf("%s is nil", "req.OptSint32")
					}
					if req.OptSfixed32 == nil {
						return nil, fmt.Errorf("%s is nil", "req.OptSfixed32")
					}
					if req.WrapInt32 == nil {
						return nil, fmt.Errorf("%s is nil", "req.WrapInt32")
					}
					pairs = append(pairs, "int32", strconv.FormatInt(int64(req.Int32), 10), "sint32", strconv.FormatInt(int64(req.Sint32), 10), "sfixed32", strconv.FormatInt(int64(req.Sfixed32), 10), "opt_int32", strconv.FormatInt(int64(*req.OptInt32), 10), "opt_sint32", strconv.FormatInt(int64(*req.OptSint32), 10), "opt_sfixed32", strconv.FormatInt(int64(*req.OptSfixed32), 10), "wrap_int32", strconv.FormatInt(int64(req.WrapInt32.Value), 10))
					path, err := router.Get("/leo.example.path.v1.Path/Int32Path").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http1.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		int64Path: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					req, ok := obj.(*PathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "GET"
					var url string
					var body io.Reader
					var pairs []string
					if req.OptInt64 == nil {
						return nil, fmt.Errorf("%s is nil", "req.OptInt64")
					}
					if req.OptSint64 == nil {
						return nil, fmt.Errorf("%s is nil", "req.OptSint64")
					}
					if req.OptSfixed64 == nil {
						return nil, fmt.Errorf("%s is nil", "req.OptSfixed64")
					}
					if req.WrapInt64 == nil {
						return nil, fmt.Errorf("%s is nil", "req.WrapInt64")
					}
					pairs = append(pairs, "int64", strconv.FormatInt(req.Int64, 10), "sint64", strconv.FormatInt(req.Sint64, 10), "sfixed64", strconv.FormatInt(req.Sfixed64, 10), "opt_int64", strconv.FormatInt(*req.OptInt64, 10), "opt_sint64", strconv.FormatInt(*req.OptSint64, 10), "opt_sfixed64", strconv.FormatInt(*req.OptSfixed64, 10), "wrap_int64", strconv.FormatInt(req.WrapInt64.Value, 10))
					path, err := router.Get("/leo.example.path.v1.Path/Int64Path").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http1.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		uint32Path: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					req, ok := obj.(*PathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "GET"
					var url string
					var body io.Reader
					var pairs []string
					if req.OptUint32 == nil {
						return nil, fmt.Errorf("%s is nil", "req.OptUint32")
					}
					if req.OptFixed32 == nil {
						return nil, fmt.Errorf("%s is nil", "req.OptFixed32")
					}
					if req.WrapUint32 == nil {
						return nil, fmt.Errorf("%s is nil", "req.WrapUint32")
					}
					pairs = append(pairs, "uint32", strconv.FormatUint(uint64(req.Uint32), 10), "fixed32", strconv.FormatUint(uint64(req.Fixed32), 10), "opt_uint32", strconv.FormatUint(uint64(*req.OptUint32), 10), "opt_fixed32", strconv.FormatUint(uint64(*req.OptFixed32), 10), "wrap_uint32", strconv.FormatUint(uint64(req.WrapUint32.Value), 10))
					path, err := router.Get("/leo.example.path.v1.Path/Uint32Path").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http1.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		uint64Path: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					req, ok := obj.(*PathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "GET"
					var url string
					var body io.Reader
					var pairs []string
					if req.OptUint64 == nil {
						return nil, fmt.Errorf("%s is nil", "req.OptUint64")
					}
					if req.OptFixed64 == nil {
						return nil, fmt.Errorf("%s is nil", "req.OptFixed64")
					}
					if req.WrapUint64 == nil {
						return nil, fmt.Errorf("%s is nil", "req.WrapUint64")
					}
					pairs = append(pairs, "uint64", strconv.FormatUint(req.Uint64, 10), "fixed64", strconv.FormatUint(req.Fixed64, 10), "opt_uint64", strconv.FormatUint(*req.OptUint64, 10), "opt_fixed64", strconv.FormatUint(*req.OptFixed64, 10), "wrap_uint64", strconv.FormatUint(req.WrapUint64.Value, 10))
					path, err := router.Get("/leo.example.path.v1.Path/Uint64Path").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http1.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		floatPath: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					req, ok := obj.(*PathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "GET"
					var url string
					var body io.Reader
					var pairs []string
					if req.OptFloat == nil {
						return nil, fmt.Errorf("%s is nil", "req.OptFloat")
					}
					if req.WrapFloat == nil {
						return nil, fmt.Errorf("%s is nil", "req.WrapFloat")
					}
					pairs = append(pairs, "float", strconv.FormatFloat(float64(req.Float), 'f', -1, 32), "opt_float", strconv.FormatFloat(float64(*req.OptFloat), 'f', -1, 32), "wrap_float", strconv.FormatFloat(float64(req.WrapFloat.Value), 'f', -1, 32))
					path, err := router.Get("/leo.example.path.v1.Path/FloatPath").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http1.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		doublePath: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					req, ok := obj.(*PathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "GET"
					var url string
					var body io.Reader
					var pairs []string
					if req.OptDouble == nil {
						return nil, fmt.Errorf("%s is nil", "req.OptDouble")
					}
					if req.WrapDouble == nil {
						return nil, fmt.Errorf("%s is nil", "req.WrapDouble")
					}
					pairs = append(pairs, "double", strconv.FormatFloat(req.Double, 'f', -1, 64), "opt_double", strconv.FormatFloat(*req.OptDouble, 'f', -1, 64), "wrap_double", strconv.FormatFloat(req.WrapDouble.Value, 'f', -1, 64))
					path, err := router.Get("/leo.example.path.v1.Path/DoublePath").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http1.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		stringPath: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					req, ok := obj.(*PathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "GET"
					var url string
					var body io.Reader
					var pairs []string
					if req.OptString == nil {
						return nil, fmt.Errorf("%s is nil", "req.OptString")
					}
					if req.WrapString == nil {
						return nil, fmt.Errorf("%s is nil", "req.WrapString")
					}
					pairs = append(pairs, "string", req.String_, "opt_string", *req.OptString, "wrap_string", req.WrapString.Value)
					path, err := router.Get("/leo.example.path.v1.Path/StringPath").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http1.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		enumPath: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					req, ok := obj.(*PathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "GET"
					var url string
					var body io.Reader
					var pairs []string
					if req.OptStatus == nil {
						return nil, fmt.Errorf("%s is nil", "req.OptStatus")
					}
					pairs = append(pairs, "status", strconv.FormatInt(int64(req.Status), 10), "opt_status", strconv.FormatInt(int64(*req.OptStatus), 10))
					path, err := router.Get("/leo.example.path.v1.Path/EnumPath").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http1.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		timePath: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					req, ok := obj.(*PathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "GET"
					var url string
					var body io.Reader
					var pairs []string
					if req.Timestamp == nil {
						return nil, fmt.Errorf("%s is nil", "req.Timestamp")
					}
					if req.Duration == nil {
						return nil, fmt.Errorf("%s is nil", "req.Duration")
					}
					pairs = append(pairs, "timestamp", req.Timestamp.AsTime().Format(time.RFC3339), "duration", req.Duration.AsDuration().String())
					path, err := router.Get("/leo.example.path.v1.Path/TimePath").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http1.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
		mixPath: endpointx.Chain(
			http.NewExplicitClient(
				func(ctx context.Context, obj interface{}) (*http1.Request, error) {
					req, ok := obj.(*MixPathRequest)
					if !ok {
						return nil, fmt.Errorf("invalid request object type, %T", obj)
					}
					if req == nil {
						return nil, errors.New("request object is nil")
					}
					var method = "GET"
					var url string
					var body io.Reader
					var pairs []string
					if req.Embed == nil {
						return nil, fmt.Errorf("%s is nil", "req.Embed")
					}
					namedPathParameter := req.Embed.WrapString.Value
					namedPathValues := strings.Split(namedPathParameter, "/")
					if len(namedPathValues) != 8 {
						return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
					}
					pairs = append(pairs, "class", namedPathValues[1], "shelf", namedPathValues[3], "book", namedPathValues[5], "family", namedPathValues[7])
					if req.OptString == nil {
						return nil, fmt.Errorf("%s is nil", "req.OptString")
					}
					if req.WrapString == nil {
						return nil, fmt.Errorf("%s is nil", "req.WrapString")
					}
					pairs = append(pairs, "string", req.String_, "opt_string", *req.OptString, "wrap_string", req.WrapString.Value)
					path, err := router.Get("/leo.example.path.v1.Path/MixPath").URLPath(pairs...)
					if err != nil {
						return nil, err
					}
					url = fmt.Sprintf("%s://%s%s", "http", instance, path)
					r, err := http1.NewRequestWithContext(ctx, method, url, body)
					if err != nil {
						return nil, err
					}
					return r, nil
				},
				func(ctx context.Context, r *http1.Response) (interface{}, error) {
					return nil, nil
				},
				opts...,
			).Endpoint(),
			mdw...),
	}
}
