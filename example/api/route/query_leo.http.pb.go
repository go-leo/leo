// Code generated by protoc-gen-go-leo. DO NOT EDIT.

package route

import (
	bytes "bytes"
	context "context"
	errors "errors"
	fmt "fmt"
	endpoint "github.com/go-kit/kit/endpoint"
	http1 "github.com/go-kit/kit/transport/http"
	httpx "github.com/go-leo/gox/netx/httpx"
	urlx "github.com/go-leo/gox/netx/urlx"
	strconvx "github.com/go-leo/gox/strconvx"
	endpointx "github.com/go-leo/leo/v3/endpointx"
	metadatax "github.com/go-leo/leo/v3/metadatax"
	stainx "github.com/go-leo/leo/v3/stainx"
	timeoutx "github.com/go-leo/leo/v3/timeoutx"
	httptransportx "github.com/go-leo/leo/v3/transportx/httptransportx"
	coder "github.com/go-leo/leo/v3/transportx/httptransportx/coder"
	mux "github.com/gorilla/mux"
	protojson "google.golang.org/protobuf/encoding/protojson"
	proto "google.golang.org/protobuf/proto"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	io "io"
	http "net/http"
	url "net/url"
)

func appendBoolQueryHttpRoutes(router *mux.Router) *mux.Router {
	router.NewRoute().
		Name("/leo.example.route.query.BoolQuery/BoolQuery").
		Methods(http.MethodGet).
		Path("/v1/bool")
	return router
}
func AppendBoolQueryHttpServerRoutes(router *mux.Router, svc BoolQueryService, opts ...httptransportx.ServerOption) *mux.Router {
	options := httptransportx.NewServerOptions(opts...)
	endpoints := &boolQueryServerEndpoints{
		svc:         svc,
		middlewares: options.Middlewares(),
	}
	requestDecoder := boolQueryHttpServerRequestDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	responseEncoder := boolQueryHttpServerResponseEncoder{
		marshalOptions: options.MarshalOptions(),
	}
	transports := &boolQueryHttpServerTransports{
		endpoints:       endpoints,
		requestDecoder:  requestDecoder,
		responseEncoder: responseEncoder,
	}
	router = appendBoolQueryHttpRoutes(router)
	router.Get("/leo.example.route.query.BoolQuery/BoolQuery").Handler(transports.BoolQuery())
	return router
}

func NewBoolQueryHttpClient(target string, opts ...httptransportx.ClientOption) BoolQueryService {
	options := httptransportx.NewClientOptions(opts...)
	requestEncoder := &boolQueryHttpClientRequestEncoder{
		marshalOptions: options.MarshalOptions(),
		router:         appendBoolQueryHttpRoutes(mux.NewRouter()),
		scheme:         options.Scheme(),
	}
	responseDecoder := &boolQueryHttpClientResponseDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	transports := &boolQueryHttpClientTransports{
		clientOptions:   options.ClientTransportOptions(),
		middlewares:     options.Middlewares(),
		requestEncoder:  requestEncoder,
		responseDecoder: responseDecoder,
	}
	factories := &boolQueryFactories{
		transports: transports,
	}
	endpointer := &boolQueryEndpointers{
		target:    target,
		builder:   options.Builder(),
		factories: factories,
		logger:    options.Logger(),
		options:   options.EndpointerOptions(),
	}
	balancers := &boolQueryBalancers{
		factory:    options.BalancerFactory(),
		endpointer: endpointer,
	}
	endpoints := &boolQueryClientEndpoints{
		balancers: balancers,
	}
	return &boolQueryClientService{
		endpoints:     endpoints,
		transportName: httptransportx.HttpClient,
	}
}

type BoolQueryHttpServerTransports interface {
	BoolQuery() http.Handler
}

type BoolQueryHttpServerRequestDecoder interface {
	BoolQuery() http1.DecodeRequestFunc
}

type BoolQueryHttpServerResponseEncoder interface {
	BoolQuery() http1.EncodeResponseFunc
}

type BoolQueryHttpClientRequestEncoder interface {
	BoolQuery(instance string) http1.CreateRequestFunc
}

type BoolQueryHttpClientResponseDecoder interface {
	BoolQuery() http1.DecodeResponseFunc
}

type boolQueryHttpServerTransports struct {
	endpoints       BoolQueryServerEndpoints
	requestDecoder  BoolQueryHttpServerRequestDecoder
	responseEncoder BoolQueryHttpServerResponseEncoder
}

func (t *boolQueryHttpServerTransports) BoolQuery() http.Handler {
	return http1.NewServer(
		t.endpoints.BoolQuery(context.TODO()),
		t.requestDecoder.BoolQuery(),
		t.responseEncoder.BoolQuery(),
		http1.ServerBefore(httptransportx.EndpointInjector("/leo.example.route.query.BoolQuery/BoolQuery")),
		http1.ServerBefore(httptransportx.ServerTransportInjector),
		http1.ServerBefore(metadatax.HttpIncomingInjector),
		http1.ServerBefore(timeoutx.IncomingInjector),
		http1.ServerBefore(stainx.HttpIncomingInjector),
		http1.ServerFinalizer(timeoutx.CancelInvoker),
		http1.ServerErrorEncoder(coder.EncodeErrorToResponse),
	)
}

type boolQueryHttpServerRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder boolQueryHttpServerRequestDecoder) BoolQuery() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &BoolQueryRequest{}
		queries := r.URL.Query()
		var queryErr error
		req.Bool, queryErr = coder.DecodeForm[bool](queryErr, queries, "bool", urlx.GetBool)
		req.OptBool, queryErr = coder.DecodeForm[*bool](queryErr, queries, "opt_bool", urlx.GetBoolPtr)
		req.WrapBool, queryErr = coder.DecodeForm[*wrapperspb.BoolValue](queryErr, queries, "wrap_bool", urlx.GetBoolValue)
		if queryErr != nil {
			return nil, queryErr
		}
		return req, nil
	}
}

type boolQueryHttpServerResponseEncoder struct {
	marshalOptions protojson.MarshalOptions
}

func (encoder boolQueryHttpServerResponseEncoder) BoolQuery() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*emptypb.Empty)
		return coder.EncodeMessageToResponse(ctx, w, resp, encoder.marshalOptions)
	}
}

type boolQueryHttpClientTransports struct {
	clientOptions   []http1.ClientOption
	middlewares     []endpoint.Middleware
	requestEncoder  BoolQueryHttpClientRequestEncoder
	responseDecoder BoolQueryHttpClientResponseDecoder
}

func (t *boolQueryHttpClientTransports) BoolQuery(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(metadatax.HttpOutgoingInjector),
		http1.ClientBefore(timeoutx.OutgoingInjector),
		http1.ClientBefore(stainx.HttpOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.BoolQuery(instance),
		t.responseDecoder.BoolQuery(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

type boolQueryHttpClientRequestEncoder struct {
	marshalOptions protojson.MarshalOptions
	router         *mux.Router
	scheme         string
}

func (encoder boolQueryHttpClientRequestEncoder) BoolQuery(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*BoolQueryRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodGet
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		var pairs []string
		path, err := encoder.router.Get("/leo.example.route.query.BoolQuery/BoolQuery").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		queries := url.Values{}
		queries["bool"] = append(queries["bool"], strconvx.FormatBool(req.GetBool()))
		queries["opt_bool"] = append(queries["opt_bool"], strconvx.FormatBool(req.GetOptBool()))
		queries["wrap_bool"] = append(queries["wrap_bool"], strconvx.FormatBool(req.GetWrapBool().GetValue()))
		target.RawQuery = queries.Encode()
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx.CopyHeader(r.Header, header)
		return r, nil
	}
}

type boolQueryHttpClientResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder boolQueryHttpClientResponseDecoder) BoolQuery() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if r.StatusCode != http.StatusOK {
			return nil, coder.DecodeErrorFromResponse(ctx, r)
		}
		resp := &emptypb.Empty{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}

func appendInt32QueryHttpRoutes(router *mux.Router) *mux.Router {
	router.NewRoute().
		Name("/leo.example.route.query.Int32Query/Int32Query").
		Methods(http.MethodGet).
		Path("/v1/int32")
	return router
}
func AppendInt32QueryHttpServerRoutes(router *mux.Router, svc Int32QueryService, opts ...httptransportx.ServerOption) *mux.Router {
	options := httptransportx.NewServerOptions(opts...)
	endpoints := &int32QueryServerEndpoints{
		svc:         svc,
		middlewares: options.Middlewares(),
	}
	requestDecoder := int32QueryHttpServerRequestDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	responseEncoder := int32QueryHttpServerResponseEncoder{
		marshalOptions: options.MarshalOptions(),
	}
	transports := &int32QueryHttpServerTransports{
		endpoints:       endpoints,
		requestDecoder:  requestDecoder,
		responseEncoder: responseEncoder,
	}
	router = appendInt32QueryHttpRoutes(router)
	router.Get("/leo.example.route.query.Int32Query/Int32Query").Handler(transports.Int32Query())
	return router
}

func NewInt32QueryHttpClient(target string, opts ...httptransportx.ClientOption) Int32QueryService {
	options := httptransportx.NewClientOptions(opts...)
	requestEncoder := &int32QueryHttpClientRequestEncoder{
		marshalOptions: options.MarshalOptions(),
		router:         appendInt32QueryHttpRoutes(mux.NewRouter()),
		scheme:         options.Scheme(),
	}
	responseDecoder := &int32QueryHttpClientResponseDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	transports := &int32QueryHttpClientTransports{
		clientOptions:   options.ClientTransportOptions(),
		middlewares:     options.Middlewares(),
		requestEncoder:  requestEncoder,
		responseDecoder: responseDecoder,
	}
	factories := &int32QueryFactories{
		transports: transports,
	}
	endpointer := &int32QueryEndpointers{
		target:    target,
		builder:   options.Builder(),
		factories: factories,
		logger:    options.Logger(),
		options:   options.EndpointerOptions(),
	}
	balancers := &int32QueryBalancers{
		factory:    options.BalancerFactory(),
		endpointer: endpointer,
	}
	endpoints := &int32QueryClientEndpoints{
		balancers: balancers,
	}
	return &int32QueryClientService{
		endpoints:     endpoints,
		transportName: httptransportx.HttpClient,
	}
}

type Int32QueryHttpServerTransports interface {
	Int32Query() http.Handler
}

type Int32QueryHttpServerRequestDecoder interface {
	Int32Query() http1.DecodeRequestFunc
}

type Int32QueryHttpServerResponseEncoder interface {
	Int32Query() http1.EncodeResponseFunc
}

type Int32QueryHttpClientRequestEncoder interface {
	Int32Query(instance string) http1.CreateRequestFunc
}

type Int32QueryHttpClientResponseDecoder interface {
	Int32Query() http1.DecodeResponseFunc
}

type int32QueryHttpServerTransports struct {
	endpoints       Int32QueryServerEndpoints
	requestDecoder  Int32QueryHttpServerRequestDecoder
	responseEncoder Int32QueryHttpServerResponseEncoder
}

func (t *int32QueryHttpServerTransports) Int32Query() http.Handler {
	return http1.NewServer(
		t.endpoints.Int32Query(context.TODO()),
		t.requestDecoder.Int32Query(),
		t.responseEncoder.Int32Query(),
		http1.ServerBefore(httptransportx.EndpointInjector("/leo.example.route.query.Int32Query/Int32Query")),
		http1.ServerBefore(httptransportx.ServerTransportInjector),
		http1.ServerBefore(metadatax.HttpIncomingInjector),
		http1.ServerBefore(timeoutx.IncomingInjector),
		http1.ServerBefore(stainx.HttpIncomingInjector),
		http1.ServerFinalizer(timeoutx.CancelInvoker),
		http1.ServerErrorEncoder(coder.EncodeErrorToResponse),
	)
}

type int32QueryHttpServerRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder int32QueryHttpServerRequestDecoder) Int32Query() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &Int32QueryRequest{}
		queries := r.URL.Query()
		var queryErr error
		req.Int32, queryErr = coder.DecodeForm[int32](queryErr, queries, "int32", urlx.GetInt[int32])
		req.Sint32, queryErr = coder.DecodeForm[int32](queryErr, queries, "sint32", urlx.GetInt[int32])
		req.Sfixed32, queryErr = coder.DecodeForm[int32](queryErr, queries, "sfixed32", urlx.GetInt[int32])
		req.OptInt32, queryErr = coder.DecodeForm[*int32](queryErr, queries, "opt_int32", urlx.GetIntPtr[int32])
		req.OptSint32, queryErr = coder.DecodeForm[*int32](queryErr, queries, "opt_sint32", urlx.GetIntPtr[int32])
		req.OptSfixed32, queryErr = coder.DecodeForm[*int32](queryErr, queries, "opt_sfixed32", urlx.GetIntPtr[int32])
		req.WrapInt32, queryErr = coder.DecodeForm[*wrapperspb.Int32Value](queryErr, queries, "wrap_int32", urlx.GetInt32Value)
		if queryErr != nil {
			return nil, queryErr
		}
		return req, nil
	}
}

type int32QueryHttpServerResponseEncoder struct {
	marshalOptions protojson.MarshalOptions
}

func (encoder int32QueryHttpServerResponseEncoder) Int32Query() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*emptypb.Empty)
		return coder.EncodeMessageToResponse(ctx, w, resp, encoder.marshalOptions)
	}
}

type int32QueryHttpClientTransports struct {
	clientOptions   []http1.ClientOption
	middlewares     []endpoint.Middleware
	requestEncoder  Int32QueryHttpClientRequestEncoder
	responseDecoder Int32QueryHttpClientResponseDecoder
}

func (t *int32QueryHttpClientTransports) Int32Query(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(metadatax.HttpOutgoingInjector),
		http1.ClientBefore(timeoutx.OutgoingInjector),
		http1.ClientBefore(stainx.HttpOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.Int32Query(instance),
		t.responseDecoder.Int32Query(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

type int32QueryHttpClientRequestEncoder struct {
	marshalOptions protojson.MarshalOptions
	router         *mux.Router
	scheme         string
}

func (encoder int32QueryHttpClientRequestEncoder) Int32Query(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*Int32QueryRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodGet
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		var pairs []string
		path, err := encoder.router.Get("/leo.example.route.query.Int32Query/Int32Query").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		queries := url.Values{}
		queries["int32"] = append(queries["int32"], strconvx.FormatInt(req.GetInt32(), 10))
		queries["sint32"] = append(queries["sint32"], strconvx.FormatInt(req.GetSint32(), 10))
		queries["sfixed32"] = append(queries["sfixed32"], strconvx.FormatInt(req.GetSfixed32(), 10))
		queries["opt_int32"] = append(queries["opt_int32"], strconvx.FormatInt(req.GetOptInt32(), 10))
		queries["opt_sint32"] = append(queries["opt_sint32"], strconvx.FormatInt(req.GetOptSint32(), 10))
		queries["opt_sfixed32"] = append(queries["opt_sfixed32"], strconvx.FormatInt(req.GetOptSfixed32(), 10))
		queries["wrap_int32"] = append(queries["wrap_int32"], strconvx.FormatInt(req.GetWrapInt32().GetValue(), 10))
		target.RawQuery = queries.Encode()
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx.CopyHeader(r.Header, header)
		return r, nil
	}
}

type int32QueryHttpClientResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder int32QueryHttpClientResponseDecoder) Int32Query() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if r.StatusCode != http.StatusOK {
			return nil, coder.DecodeErrorFromResponse(ctx, r)
		}
		resp := &emptypb.Empty{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}

func appendInt64QueryHttpRoutes(router *mux.Router) *mux.Router {
	router.NewRoute().
		Name("/leo.example.route.query.Int64Query/Int64Query").
		Methods(http.MethodGet).
		Path("/v1/int64")
	return router
}
func AppendInt64QueryHttpServerRoutes(router *mux.Router, svc Int64QueryService, opts ...httptransportx.ServerOption) *mux.Router {
	options := httptransportx.NewServerOptions(opts...)
	endpoints := &int64QueryServerEndpoints{
		svc:         svc,
		middlewares: options.Middlewares(),
	}
	requestDecoder := int64QueryHttpServerRequestDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	responseEncoder := int64QueryHttpServerResponseEncoder{
		marshalOptions: options.MarshalOptions(),
	}
	transports := &int64QueryHttpServerTransports{
		endpoints:       endpoints,
		requestDecoder:  requestDecoder,
		responseEncoder: responseEncoder,
	}
	router = appendInt64QueryHttpRoutes(router)
	router.Get("/leo.example.route.query.Int64Query/Int64Query").Handler(transports.Int64Query())
	return router
}

func NewInt64QueryHttpClient(target string, opts ...httptransportx.ClientOption) Int64QueryService {
	options := httptransportx.NewClientOptions(opts...)
	requestEncoder := &int64QueryHttpClientRequestEncoder{
		marshalOptions: options.MarshalOptions(),
		router:         appendInt64QueryHttpRoutes(mux.NewRouter()),
		scheme:         options.Scheme(),
	}
	responseDecoder := &int64QueryHttpClientResponseDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	transports := &int64QueryHttpClientTransports{
		clientOptions:   options.ClientTransportOptions(),
		middlewares:     options.Middlewares(),
		requestEncoder:  requestEncoder,
		responseDecoder: responseDecoder,
	}
	factories := &int64QueryFactories{
		transports: transports,
	}
	endpointer := &int64QueryEndpointers{
		target:    target,
		builder:   options.Builder(),
		factories: factories,
		logger:    options.Logger(),
		options:   options.EndpointerOptions(),
	}
	balancers := &int64QueryBalancers{
		factory:    options.BalancerFactory(),
		endpointer: endpointer,
	}
	endpoints := &int64QueryClientEndpoints{
		balancers: balancers,
	}
	return &int64QueryClientService{
		endpoints:     endpoints,
		transportName: httptransportx.HttpClient,
	}
}

type Int64QueryHttpServerTransports interface {
	Int64Query() http.Handler
}

type Int64QueryHttpServerRequestDecoder interface {
	Int64Query() http1.DecodeRequestFunc
}

type Int64QueryHttpServerResponseEncoder interface {
	Int64Query() http1.EncodeResponseFunc
}

type Int64QueryHttpClientRequestEncoder interface {
	Int64Query(instance string) http1.CreateRequestFunc
}

type Int64QueryHttpClientResponseDecoder interface {
	Int64Query() http1.DecodeResponseFunc
}

type int64QueryHttpServerTransports struct {
	endpoints       Int64QueryServerEndpoints
	requestDecoder  Int64QueryHttpServerRequestDecoder
	responseEncoder Int64QueryHttpServerResponseEncoder
}

func (t *int64QueryHttpServerTransports) Int64Query() http.Handler {
	return http1.NewServer(
		t.endpoints.Int64Query(context.TODO()),
		t.requestDecoder.Int64Query(),
		t.responseEncoder.Int64Query(),
		http1.ServerBefore(httptransportx.EndpointInjector("/leo.example.route.query.Int64Query/Int64Query")),
		http1.ServerBefore(httptransportx.ServerTransportInjector),
		http1.ServerBefore(metadatax.HttpIncomingInjector),
		http1.ServerBefore(timeoutx.IncomingInjector),
		http1.ServerBefore(stainx.HttpIncomingInjector),
		http1.ServerFinalizer(timeoutx.CancelInvoker),
		http1.ServerErrorEncoder(coder.EncodeErrorToResponse),
	)
}

type int64QueryHttpServerRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder int64QueryHttpServerRequestDecoder) Int64Query() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &Int64QueryRequest{}
		queries := r.URL.Query()
		var queryErr error
		req.Int64, queryErr = coder.DecodeForm[int64](queryErr, queries, "int64", urlx.GetInt[int64])
		req.Sint64, queryErr = coder.DecodeForm[int64](queryErr, queries, "sint64", urlx.GetInt[int64])
		req.Sfixed64, queryErr = coder.DecodeForm[int64](queryErr, queries, "sfixed64", urlx.GetInt[int64])
		req.OptInt64, queryErr = coder.DecodeForm[*int64](queryErr, queries, "opt_int64", urlx.GetIntPtr[int64])
		req.OptSint64, queryErr = coder.DecodeForm[*int64](queryErr, queries, "opt_sint64", urlx.GetIntPtr[int64])
		req.OptSfixed64, queryErr = coder.DecodeForm[*int64](queryErr, queries, "opt_sfixed64", urlx.GetIntPtr[int64])
		req.WrapInt64, queryErr = coder.DecodeForm[*wrapperspb.Int64Value](queryErr, queries, "wrap_int64", urlx.GetInt64Value)
		if queryErr != nil {
			return nil, queryErr
		}
		return req, nil
	}
}

type int64QueryHttpServerResponseEncoder struct {
	marshalOptions protojson.MarshalOptions
}

func (encoder int64QueryHttpServerResponseEncoder) Int64Query() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*emptypb.Empty)
		return coder.EncodeMessageToResponse(ctx, w, resp, encoder.marshalOptions)
	}
}

type int64QueryHttpClientTransports struct {
	clientOptions   []http1.ClientOption
	middlewares     []endpoint.Middleware
	requestEncoder  Int64QueryHttpClientRequestEncoder
	responseDecoder Int64QueryHttpClientResponseDecoder
}

func (t *int64QueryHttpClientTransports) Int64Query(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(metadatax.HttpOutgoingInjector),
		http1.ClientBefore(timeoutx.OutgoingInjector),
		http1.ClientBefore(stainx.HttpOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.Int64Query(instance),
		t.responseDecoder.Int64Query(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

type int64QueryHttpClientRequestEncoder struct {
	marshalOptions protojson.MarshalOptions
	router         *mux.Router
	scheme         string
}

func (encoder int64QueryHttpClientRequestEncoder) Int64Query(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*Int64QueryRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodGet
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		var pairs []string
		path, err := encoder.router.Get("/leo.example.route.query.Int64Query/Int64Query").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		queries := url.Values{}
		queries["int64"] = append(queries["int64"], strconvx.FormatInt(req.GetInt64(), 10))
		queries["sint64"] = append(queries["sint64"], strconvx.FormatInt(req.GetSint64(), 10))
		queries["sfixed64"] = append(queries["sfixed64"], strconvx.FormatInt(req.GetSfixed64(), 10))
		queries["opt_int64"] = append(queries["opt_int64"], strconvx.FormatInt(req.GetOptInt64(), 10))
		queries["opt_sint64"] = append(queries["opt_sint64"], strconvx.FormatInt(req.GetOptSint64(), 10))
		queries["opt_sfixed64"] = append(queries["opt_sfixed64"], strconvx.FormatInt(req.GetOptSfixed64(), 10))
		queries["wrap_int64"] = append(queries["wrap_int64"], strconvx.FormatInt(req.GetWrapInt64().GetValue(), 10))
		target.RawQuery = queries.Encode()
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx.CopyHeader(r.Header, header)
		return r, nil
	}
}

type int64QueryHttpClientResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder int64QueryHttpClientResponseDecoder) Int64Query() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if r.StatusCode != http.StatusOK {
			return nil, coder.DecodeErrorFromResponse(ctx, r)
		}
		resp := &emptypb.Empty{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}

func appendUint32QueryHttpRoutes(router *mux.Router) *mux.Router {
	router.NewRoute().
		Name("/leo.example.route.query.Uint32Query/Uint32Query").
		Methods(http.MethodGet).
		Path("/v1/uint32")
	return router
}
func AppendUint32QueryHttpServerRoutes(router *mux.Router, svc Uint32QueryService, opts ...httptransportx.ServerOption) *mux.Router {
	options := httptransportx.NewServerOptions(opts...)
	endpoints := &uint32QueryServerEndpoints{
		svc:         svc,
		middlewares: options.Middlewares(),
	}
	requestDecoder := uint32QueryHttpServerRequestDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	responseEncoder := uint32QueryHttpServerResponseEncoder{
		marshalOptions: options.MarshalOptions(),
	}
	transports := &uint32QueryHttpServerTransports{
		endpoints:       endpoints,
		requestDecoder:  requestDecoder,
		responseEncoder: responseEncoder,
	}
	router = appendUint32QueryHttpRoutes(router)
	router.Get("/leo.example.route.query.Uint32Query/Uint32Query").Handler(transports.Uint32Query())
	return router
}

func NewUint32QueryHttpClient(target string, opts ...httptransportx.ClientOption) Uint32QueryService {
	options := httptransportx.NewClientOptions(opts...)
	requestEncoder := &uint32QueryHttpClientRequestEncoder{
		marshalOptions: options.MarshalOptions(),
		router:         appendUint32QueryHttpRoutes(mux.NewRouter()),
		scheme:         options.Scheme(),
	}
	responseDecoder := &uint32QueryHttpClientResponseDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	transports := &uint32QueryHttpClientTransports{
		clientOptions:   options.ClientTransportOptions(),
		middlewares:     options.Middlewares(),
		requestEncoder:  requestEncoder,
		responseDecoder: responseDecoder,
	}
	factories := &uint32QueryFactories{
		transports: transports,
	}
	endpointer := &uint32QueryEndpointers{
		target:    target,
		builder:   options.Builder(),
		factories: factories,
		logger:    options.Logger(),
		options:   options.EndpointerOptions(),
	}
	balancers := &uint32QueryBalancers{
		factory:    options.BalancerFactory(),
		endpointer: endpointer,
	}
	endpoints := &uint32QueryClientEndpoints{
		balancers: balancers,
	}
	return &uint32QueryClientService{
		endpoints:     endpoints,
		transportName: httptransportx.HttpClient,
	}
}

type Uint32QueryHttpServerTransports interface {
	Uint32Query() http.Handler
}

type Uint32QueryHttpServerRequestDecoder interface {
	Uint32Query() http1.DecodeRequestFunc
}

type Uint32QueryHttpServerResponseEncoder interface {
	Uint32Query() http1.EncodeResponseFunc
}

type Uint32QueryHttpClientRequestEncoder interface {
	Uint32Query(instance string) http1.CreateRequestFunc
}

type Uint32QueryHttpClientResponseDecoder interface {
	Uint32Query() http1.DecodeResponseFunc
}

type uint32QueryHttpServerTransports struct {
	endpoints       Uint32QueryServerEndpoints
	requestDecoder  Uint32QueryHttpServerRequestDecoder
	responseEncoder Uint32QueryHttpServerResponseEncoder
}

func (t *uint32QueryHttpServerTransports) Uint32Query() http.Handler {
	return http1.NewServer(
		t.endpoints.Uint32Query(context.TODO()),
		t.requestDecoder.Uint32Query(),
		t.responseEncoder.Uint32Query(),
		http1.ServerBefore(httptransportx.EndpointInjector("/leo.example.route.query.Uint32Query/Uint32Query")),
		http1.ServerBefore(httptransportx.ServerTransportInjector),
		http1.ServerBefore(metadatax.HttpIncomingInjector),
		http1.ServerBefore(timeoutx.IncomingInjector),
		http1.ServerBefore(stainx.HttpIncomingInjector),
		http1.ServerFinalizer(timeoutx.CancelInvoker),
		http1.ServerErrorEncoder(coder.EncodeErrorToResponse),
	)
}

type uint32QueryHttpServerRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder uint32QueryHttpServerRequestDecoder) Uint32Query() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &Uint32QueryRequest{}
		queries := r.URL.Query()
		var queryErr error
		req.Uint32, queryErr = coder.DecodeForm[uint32](queryErr, queries, "uint32", urlx.GetUint[uint32])
		req.Fixed32, queryErr = coder.DecodeForm[uint32](queryErr, queries, "fixed32", urlx.GetUint[uint32])
		req.OptUint32, queryErr = coder.DecodeForm[*uint32](queryErr, queries, "opt_uint32", urlx.GetUintPtr[uint32])
		req.OptFixed32, queryErr = coder.DecodeForm[*uint32](queryErr, queries, "opt_fixed32", urlx.GetUintPtr[uint32])
		req.WrapUint32, queryErr = coder.DecodeForm[*wrapperspb.UInt32Value](queryErr, queries, "wrap_uint32", urlx.GetUint32Value)
		if queryErr != nil {
			return nil, queryErr
		}
		return req, nil
	}
}

type uint32QueryHttpServerResponseEncoder struct {
	marshalOptions protojson.MarshalOptions
}

func (encoder uint32QueryHttpServerResponseEncoder) Uint32Query() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*emptypb.Empty)
		return coder.EncodeMessageToResponse(ctx, w, resp, encoder.marshalOptions)
	}
}

type uint32QueryHttpClientTransports struct {
	clientOptions   []http1.ClientOption
	middlewares     []endpoint.Middleware
	requestEncoder  Uint32QueryHttpClientRequestEncoder
	responseDecoder Uint32QueryHttpClientResponseDecoder
}

func (t *uint32QueryHttpClientTransports) Uint32Query(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(metadatax.HttpOutgoingInjector),
		http1.ClientBefore(timeoutx.OutgoingInjector),
		http1.ClientBefore(stainx.HttpOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.Uint32Query(instance),
		t.responseDecoder.Uint32Query(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

type uint32QueryHttpClientRequestEncoder struct {
	marshalOptions protojson.MarshalOptions
	router         *mux.Router
	scheme         string
}

func (encoder uint32QueryHttpClientRequestEncoder) Uint32Query(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*Uint32QueryRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodGet
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		var pairs []string
		path, err := encoder.router.Get("/leo.example.route.query.Uint32Query/Uint32Query").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		queries := url.Values{}
		queries["uint32"] = append(queries["uint32"], strconvx.FormatUint(req.GetUint32(), 10))
		queries["fixed32"] = append(queries["fixed32"], strconvx.FormatUint(req.GetFixed32(), 10))
		queries["opt_uint32"] = append(queries["opt_uint32"], strconvx.FormatUint(req.GetOptUint32(), 10))
		queries["opt_fixed32"] = append(queries["opt_fixed32"], strconvx.FormatUint(req.GetOptFixed32(), 10))
		queries["wrap_uint32"] = append(queries["wrap_uint32"], strconvx.FormatUint(req.GetWrapUint32().GetValue(), 10))
		target.RawQuery = queries.Encode()
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx.CopyHeader(r.Header, header)
		return r, nil
	}
}

type uint32QueryHttpClientResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder uint32QueryHttpClientResponseDecoder) Uint32Query() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if r.StatusCode != http.StatusOK {
			return nil, coder.DecodeErrorFromResponse(ctx, r)
		}
		resp := &emptypb.Empty{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}

func appendUint64QueryHttpRoutes(router *mux.Router) *mux.Router {
	router.NewRoute().
		Name("/leo.example.route.query.Uint64Query/Uint64Query").
		Methods(http.MethodGet).
		Path("/v1/uint64")
	return router
}
func AppendUint64QueryHttpServerRoutes(router *mux.Router, svc Uint64QueryService, opts ...httptransportx.ServerOption) *mux.Router {
	options := httptransportx.NewServerOptions(opts...)
	endpoints := &uint64QueryServerEndpoints{
		svc:         svc,
		middlewares: options.Middlewares(),
	}
	requestDecoder := uint64QueryHttpServerRequestDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	responseEncoder := uint64QueryHttpServerResponseEncoder{
		marshalOptions: options.MarshalOptions(),
	}
	transports := &uint64QueryHttpServerTransports{
		endpoints:       endpoints,
		requestDecoder:  requestDecoder,
		responseEncoder: responseEncoder,
	}
	router = appendUint64QueryHttpRoutes(router)
	router.Get("/leo.example.route.query.Uint64Query/Uint64Query").Handler(transports.Uint64Query())
	return router
}

func NewUint64QueryHttpClient(target string, opts ...httptransportx.ClientOption) Uint64QueryService {
	options := httptransportx.NewClientOptions(opts...)
	requestEncoder := &uint64QueryHttpClientRequestEncoder{
		marshalOptions: options.MarshalOptions(),
		router:         appendUint64QueryHttpRoutes(mux.NewRouter()),
		scheme:         options.Scheme(),
	}
	responseDecoder := &uint64QueryHttpClientResponseDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	transports := &uint64QueryHttpClientTransports{
		clientOptions:   options.ClientTransportOptions(),
		middlewares:     options.Middlewares(),
		requestEncoder:  requestEncoder,
		responseDecoder: responseDecoder,
	}
	factories := &uint64QueryFactories{
		transports: transports,
	}
	endpointer := &uint64QueryEndpointers{
		target:    target,
		builder:   options.Builder(),
		factories: factories,
		logger:    options.Logger(),
		options:   options.EndpointerOptions(),
	}
	balancers := &uint64QueryBalancers{
		factory:    options.BalancerFactory(),
		endpointer: endpointer,
	}
	endpoints := &uint64QueryClientEndpoints{
		balancers: balancers,
	}
	return &uint64QueryClientService{
		endpoints:     endpoints,
		transportName: httptransportx.HttpClient,
	}
}

type Uint64QueryHttpServerTransports interface {
	Uint64Query() http.Handler
}

type Uint64QueryHttpServerRequestDecoder interface {
	Uint64Query() http1.DecodeRequestFunc
}

type Uint64QueryHttpServerResponseEncoder interface {
	Uint64Query() http1.EncodeResponseFunc
}

type Uint64QueryHttpClientRequestEncoder interface {
	Uint64Query(instance string) http1.CreateRequestFunc
}

type Uint64QueryHttpClientResponseDecoder interface {
	Uint64Query() http1.DecodeResponseFunc
}

type uint64QueryHttpServerTransports struct {
	endpoints       Uint64QueryServerEndpoints
	requestDecoder  Uint64QueryHttpServerRequestDecoder
	responseEncoder Uint64QueryHttpServerResponseEncoder
}

func (t *uint64QueryHttpServerTransports) Uint64Query() http.Handler {
	return http1.NewServer(
		t.endpoints.Uint64Query(context.TODO()),
		t.requestDecoder.Uint64Query(),
		t.responseEncoder.Uint64Query(),
		http1.ServerBefore(httptransportx.EndpointInjector("/leo.example.route.query.Uint64Query/Uint64Query")),
		http1.ServerBefore(httptransportx.ServerTransportInjector),
		http1.ServerBefore(metadatax.HttpIncomingInjector),
		http1.ServerBefore(timeoutx.IncomingInjector),
		http1.ServerBefore(stainx.HttpIncomingInjector),
		http1.ServerFinalizer(timeoutx.CancelInvoker),
		http1.ServerErrorEncoder(coder.EncodeErrorToResponse),
	)
}

type uint64QueryHttpServerRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder uint64QueryHttpServerRequestDecoder) Uint64Query() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &Uint64QueryRequest{}
		queries := r.URL.Query()
		var queryErr error
		req.Uint64, queryErr = coder.DecodeForm[uint64](queryErr, queries, "uint64", urlx.GetUint[uint64])
		req.Fixed64, queryErr = coder.DecodeForm[uint64](queryErr, queries, "fixed64", urlx.GetUint[uint64])
		req.OptUint64, queryErr = coder.DecodeForm[*uint64](queryErr, queries, "opt_uint64", urlx.GetUintPtr[uint64])
		req.OptFixed64, queryErr = coder.DecodeForm[*uint64](queryErr, queries, "opt_fixed64", urlx.GetUintPtr[uint64])
		req.WrapUint64, queryErr = coder.DecodeForm[*wrapperspb.UInt64Value](queryErr, queries, "wrap_uint64", urlx.GetUint64Value)
		if queryErr != nil {
			return nil, queryErr
		}
		return req, nil
	}
}

type uint64QueryHttpServerResponseEncoder struct {
	marshalOptions protojson.MarshalOptions
}

func (encoder uint64QueryHttpServerResponseEncoder) Uint64Query() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*emptypb.Empty)
		return coder.EncodeMessageToResponse(ctx, w, resp, encoder.marshalOptions)
	}
}

type uint64QueryHttpClientTransports struct {
	clientOptions   []http1.ClientOption
	middlewares     []endpoint.Middleware
	requestEncoder  Uint64QueryHttpClientRequestEncoder
	responseDecoder Uint64QueryHttpClientResponseDecoder
}

func (t *uint64QueryHttpClientTransports) Uint64Query(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(metadatax.HttpOutgoingInjector),
		http1.ClientBefore(timeoutx.OutgoingInjector),
		http1.ClientBefore(stainx.HttpOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.Uint64Query(instance),
		t.responseDecoder.Uint64Query(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

type uint64QueryHttpClientRequestEncoder struct {
	marshalOptions protojson.MarshalOptions
	router         *mux.Router
	scheme         string
}

func (encoder uint64QueryHttpClientRequestEncoder) Uint64Query(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*Uint64QueryRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodGet
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		var pairs []string
		path, err := encoder.router.Get("/leo.example.route.query.Uint64Query/Uint64Query").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		queries := url.Values{}
		queries["uint64"] = append(queries["uint64"], strconvx.FormatUint(req.GetUint64(), 10))
		queries["fixed64"] = append(queries["fixed64"], strconvx.FormatUint(req.GetFixed64(), 10))
		queries["opt_uint64"] = append(queries["opt_uint64"], strconvx.FormatUint(req.GetOptUint64(), 10))
		queries["opt_fixed64"] = append(queries["opt_fixed64"], strconvx.FormatUint(req.GetOptFixed64(), 10))
		queries["wrap_uint64"] = append(queries["wrap_uint64"], strconvx.FormatUint(req.GetWrapUint64().GetValue(), 10))
		target.RawQuery = queries.Encode()
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx.CopyHeader(r.Header, header)
		return r, nil
	}
}

type uint64QueryHttpClientResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder uint64QueryHttpClientResponseDecoder) Uint64Query() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if r.StatusCode != http.StatusOK {
			return nil, coder.DecodeErrorFromResponse(ctx, r)
		}
		resp := &emptypb.Empty{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}

func appendFloatQueryHttpRoutes(router *mux.Router) *mux.Router {
	router.NewRoute().
		Name("/leo.example.route.query.FloatQuery/FloatQuery").
		Methods(http.MethodGet).
		Path("/v1/float")
	return router
}
func AppendFloatQueryHttpServerRoutes(router *mux.Router, svc FloatQueryService, opts ...httptransportx.ServerOption) *mux.Router {
	options := httptransportx.NewServerOptions(opts...)
	endpoints := &floatQueryServerEndpoints{
		svc:         svc,
		middlewares: options.Middlewares(),
	}
	requestDecoder := floatQueryHttpServerRequestDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	responseEncoder := floatQueryHttpServerResponseEncoder{
		marshalOptions: options.MarshalOptions(),
	}
	transports := &floatQueryHttpServerTransports{
		endpoints:       endpoints,
		requestDecoder:  requestDecoder,
		responseEncoder: responseEncoder,
	}
	router = appendFloatQueryHttpRoutes(router)
	router.Get("/leo.example.route.query.FloatQuery/FloatQuery").Handler(transports.FloatQuery())
	return router
}

func NewFloatQueryHttpClient(target string, opts ...httptransportx.ClientOption) FloatQueryService {
	options := httptransportx.NewClientOptions(opts...)
	requestEncoder := &floatQueryHttpClientRequestEncoder{
		marshalOptions: options.MarshalOptions(),
		router:         appendFloatQueryHttpRoutes(mux.NewRouter()),
		scheme:         options.Scheme(),
	}
	responseDecoder := &floatQueryHttpClientResponseDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	transports := &floatQueryHttpClientTransports{
		clientOptions:   options.ClientTransportOptions(),
		middlewares:     options.Middlewares(),
		requestEncoder:  requestEncoder,
		responseDecoder: responseDecoder,
	}
	factories := &floatQueryFactories{
		transports: transports,
	}
	endpointer := &floatQueryEndpointers{
		target:    target,
		builder:   options.Builder(),
		factories: factories,
		logger:    options.Logger(),
		options:   options.EndpointerOptions(),
	}
	balancers := &floatQueryBalancers{
		factory:    options.BalancerFactory(),
		endpointer: endpointer,
	}
	endpoints := &floatQueryClientEndpoints{
		balancers: balancers,
	}
	return &floatQueryClientService{
		endpoints:     endpoints,
		transportName: httptransportx.HttpClient,
	}
}

type FloatQueryHttpServerTransports interface {
	FloatQuery() http.Handler
}

type FloatQueryHttpServerRequestDecoder interface {
	FloatQuery() http1.DecodeRequestFunc
}

type FloatQueryHttpServerResponseEncoder interface {
	FloatQuery() http1.EncodeResponseFunc
}

type FloatQueryHttpClientRequestEncoder interface {
	FloatQuery(instance string) http1.CreateRequestFunc
}

type FloatQueryHttpClientResponseDecoder interface {
	FloatQuery() http1.DecodeResponseFunc
}

type floatQueryHttpServerTransports struct {
	endpoints       FloatQueryServerEndpoints
	requestDecoder  FloatQueryHttpServerRequestDecoder
	responseEncoder FloatQueryHttpServerResponseEncoder
}

func (t *floatQueryHttpServerTransports) FloatQuery() http.Handler {
	return http1.NewServer(
		t.endpoints.FloatQuery(context.TODO()),
		t.requestDecoder.FloatQuery(),
		t.responseEncoder.FloatQuery(),
		http1.ServerBefore(httptransportx.EndpointInjector("/leo.example.route.query.FloatQuery/FloatQuery")),
		http1.ServerBefore(httptransportx.ServerTransportInjector),
		http1.ServerBefore(metadatax.HttpIncomingInjector),
		http1.ServerBefore(timeoutx.IncomingInjector),
		http1.ServerBefore(stainx.HttpIncomingInjector),
		http1.ServerFinalizer(timeoutx.CancelInvoker),
		http1.ServerErrorEncoder(coder.EncodeErrorToResponse),
	)
}

type floatQueryHttpServerRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder floatQueryHttpServerRequestDecoder) FloatQuery() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &FloatQueryRequest{}
		queries := r.URL.Query()
		var queryErr error
		req.Float, queryErr = coder.DecodeForm[float32](queryErr, queries, "float", urlx.GetFloat[float32])
		req.OptFloat, queryErr = coder.DecodeForm[*float32](queryErr, queries, "opt_float", urlx.GetFloatPtr[float32])
		req.WrapFloat, queryErr = coder.DecodeForm[*wrapperspb.FloatValue](queryErr, queries, "wrap_float", urlx.GetFloat32Value)
		if queryErr != nil {
			return nil, queryErr
		}
		return req, nil
	}
}

type floatQueryHttpServerResponseEncoder struct {
	marshalOptions protojson.MarshalOptions
}

func (encoder floatQueryHttpServerResponseEncoder) FloatQuery() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*emptypb.Empty)
		return coder.EncodeMessageToResponse(ctx, w, resp, encoder.marshalOptions)
	}
}

type floatQueryHttpClientTransports struct {
	clientOptions   []http1.ClientOption
	middlewares     []endpoint.Middleware
	requestEncoder  FloatQueryHttpClientRequestEncoder
	responseDecoder FloatQueryHttpClientResponseDecoder
}

func (t *floatQueryHttpClientTransports) FloatQuery(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(metadatax.HttpOutgoingInjector),
		http1.ClientBefore(timeoutx.OutgoingInjector),
		http1.ClientBefore(stainx.HttpOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.FloatQuery(instance),
		t.responseDecoder.FloatQuery(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

type floatQueryHttpClientRequestEncoder struct {
	marshalOptions protojson.MarshalOptions
	router         *mux.Router
	scheme         string
}

func (encoder floatQueryHttpClientRequestEncoder) FloatQuery(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*FloatQueryRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodGet
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		var pairs []string
		path, err := encoder.router.Get("/leo.example.route.query.FloatQuery/FloatQuery").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		queries := url.Values{}
		queries["float"] = append(queries["float"], strconvx.FormatFloat(req.GetFloat(), 'f', -1, 32))
		queries["opt_float"] = append(queries["opt_float"], strconvx.FormatFloat(req.GetOptFloat(), 'f', -1, 32))
		queries["wrap_float"] = append(queries["wrap_float"], strconvx.FormatFloat(req.GetWrapFloat().GetValue(), 'f', -1, 32))
		target.RawQuery = queries.Encode()
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx.CopyHeader(r.Header, header)
		return r, nil
	}
}

type floatQueryHttpClientResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder floatQueryHttpClientResponseDecoder) FloatQuery() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if r.StatusCode != http.StatusOK {
			return nil, coder.DecodeErrorFromResponse(ctx, r)
		}
		resp := &emptypb.Empty{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}

func appendDoubleQueryHttpRoutes(router *mux.Router) *mux.Router {
	router.NewRoute().
		Name("/leo.example.route.query.DoubleQuery/DoubleQuery").
		Methods(http.MethodGet).
		Path("/v1/double")
	return router
}
func AppendDoubleQueryHttpServerRoutes(router *mux.Router, svc DoubleQueryService, opts ...httptransportx.ServerOption) *mux.Router {
	options := httptransportx.NewServerOptions(opts...)
	endpoints := &doubleQueryServerEndpoints{
		svc:         svc,
		middlewares: options.Middlewares(),
	}
	requestDecoder := doubleQueryHttpServerRequestDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	responseEncoder := doubleQueryHttpServerResponseEncoder{
		marshalOptions: options.MarshalOptions(),
	}
	transports := &doubleQueryHttpServerTransports{
		endpoints:       endpoints,
		requestDecoder:  requestDecoder,
		responseEncoder: responseEncoder,
	}
	router = appendDoubleQueryHttpRoutes(router)
	router.Get("/leo.example.route.query.DoubleQuery/DoubleQuery").Handler(transports.DoubleQuery())
	return router
}

func NewDoubleQueryHttpClient(target string, opts ...httptransportx.ClientOption) DoubleQueryService {
	options := httptransportx.NewClientOptions(opts...)
	requestEncoder := &doubleQueryHttpClientRequestEncoder{
		marshalOptions: options.MarshalOptions(),
		router:         appendDoubleQueryHttpRoutes(mux.NewRouter()),
		scheme:         options.Scheme(),
	}
	responseDecoder := &doubleQueryHttpClientResponseDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	transports := &doubleQueryHttpClientTransports{
		clientOptions:   options.ClientTransportOptions(),
		middlewares:     options.Middlewares(),
		requestEncoder:  requestEncoder,
		responseDecoder: responseDecoder,
	}
	factories := &doubleQueryFactories{
		transports: transports,
	}
	endpointer := &doubleQueryEndpointers{
		target:    target,
		builder:   options.Builder(),
		factories: factories,
		logger:    options.Logger(),
		options:   options.EndpointerOptions(),
	}
	balancers := &doubleQueryBalancers{
		factory:    options.BalancerFactory(),
		endpointer: endpointer,
	}
	endpoints := &doubleQueryClientEndpoints{
		balancers: balancers,
	}
	return &doubleQueryClientService{
		endpoints:     endpoints,
		transportName: httptransportx.HttpClient,
	}
}

type DoubleQueryHttpServerTransports interface {
	DoubleQuery() http.Handler
}

type DoubleQueryHttpServerRequestDecoder interface {
	DoubleQuery() http1.DecodeRequestFunc
}

type DoubleQueryHttpServerResponseEncoder interface {
	DoubleQuery() http1.EncodeResponseFunc
}

type DoubleQueryHttpClientRequestEncoder interface {
	DoubleQuery(instance string) http1.CreateRequestFunc
}

type DoubleQueryHttpClientResponseDecoder interface {
	DoubleQuery() http1.DecodeResponseFunc
}

type doubleQueryHttpServerTransports struct {
	endpoints       DoubleQueryServerEndpoints
	requestDecoder  DoubleQueryHttpServerRequestDecoder
	responseEncoder DoubleQueryHttpServerResponseEncoder
}

func (t *doubleQueryHttpServerTransports) DoubleQuery() http.Handler {
	return http1.NewServer(
		t.endpoints.DoubleQuery(context.TODO()),
		t.requestDecoder.DoubleQuery(),
		t.responseEncoder.DoubleQuery(),
		http1.ServerBefore(httptransportx.EndpointInjector("/leo.example.route.query.DoubleQuery/DoubleQuery")),
		http1.ServerBefore(httptransportx.ServerTransportInjector),
		http1.ServerBefore(metadatax.HttpIncomingInjector),
		http1.ServerBefore(timeoutx.IncomingInjector),
		http1.ServerBefore(stainx.HttpIncomingInjector),
		http1.ServerFinalizer(timeoutx.CancelInvoker),
		http1.ServerErrorEncoder(coder.EncodeErrorToResponse),
	)
}

type doubleQueryHttpServerRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder doubleQueryHttpServerRequestDecoder) DoubleQuery() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &DoubleQueryRequest{}
		queries := r.URL.Query()
		var queryErr error
		req.Double, queryErr = coder.DecodeForm[float64](queryErr, queries, "double", urlx.GetFloat[float64])
		req.OptDouble, queryErr = coder.DecodeForm[*float64](queryErr, queries, "opt_double", urlx.GetFloatPtr[float64])
		req.WrapDouble, queryErr = coder.DecodeForm[*wrapperspb.DoubleValue](queryErr, queries, "wrap_double", urlx.GetFloat64Value)
		if queryErr != nil {
			return nil, queryErr
		}
		return req, nil
	}
}

type doubleQueryHttpServerResponseEncoder struct {
	marshalOptions protojson.MarshalOptions
}

func (encoder doubleQueryHttpServerResponseEncoder) DoubleQuery() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*emptypb.Empty)
		return coder.EncodeMessageToResponse(ctx, w, resp, encoder.marshalOptions)
	}
}

type doubleQueryHttpClientTransports struct {
	clientOptions   []http1.ClientOption
	middlewares     []endpoint.Middleware
	requestEncoder  DoubleQueryHttpClientRequestEncoder
	responseDecoder DoubleQueryHttpClientResponseDecoder
}

func (t *doubleQueryHttpClientTransports) DoubleQuery(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(metadatax.HttpOutgoingInjector),
		http1.ClientBefore(timeoutx.OutgoingInjector),
		http1.ClientBefore(stainx.HttpOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.DoubleQuery(instance),
		t.responseDecoder.DoubleQuery(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

type doubleQueryHttpClientRequestEncoder struct {
	marshalOptions protojson.MarshalOptions
	router         *mux.Router
	scheme         string
}

func (encoder doubleQueryHttpClientRequestEncoder) DoubleQuery(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*DoubleQueryRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodGet
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		var pairs []string
		path, err := encoder.router.Get("/leo.example.route.query.DoubleQuery/DoubleQuery").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		queries := url.Values{}
		queries["double"] = append(queries["double"], strconvx.FormatFloat(req.GetDouble(), 'f', -1, 64))
		queries["opt_double"] = append(queries["opt_double"], strconvx.FormatFloat(req.GetOptDouble(), 'f', -1, 64))
		queries["wrap_double"] = append(queries["wrap_double"], strconvx.FormatFloat(req.GetWrapDouble().GetValue(), 'f', -1, 64))
		target.RawQuery = queries.Encode()
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx.CopyHeader(r.Header, header)
		return r, nil
	}
}

type doubleQueryHttpClientResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder doubleQueryHttpClientResponseDecoder) DoubleQuery() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if r.StatusCode != http.StatusOK {
			return nil, coder.DecodeErrorFromResponse(ctx, r)
		}
		resp := &emptypb.Empty{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}

func appendStringQueryHttpRoutes(router *mux.Router) *mux.Router {
	router.NewRoute().
		Name("/leo.example.route.query.StringQuery/StringQuery").
		Methods(http.MethodGet).
		Path("/v1/string")
	return router
}
func AppendStringQueryHttpServerRoutes(router *mux.Router, svc StringQueryService, opts ...httptransportx.ServerOption) *mux.Router {
	options := httptransportx.NewServerOptions(opts...)
	endpoints := &stringQueryServerEndpoints{
		svc:         svc,
		middlewares: options.Middlewares(),
	}
	requestDecoder := stringQueryHttpServerRequestDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	responseEncoder := stringQueryHttpServerResponseEncoder{
		marshalOptions: options.MarshalOptions(),
	}
	transports := &stringQueryHttpServerTransports{
		endpoints:       endpoints,
		requestDecoder:  requestDecoder,
		responseEncoder: responseEncoder,
	}
	router = appendStringQueryHttpRoutes(router)
	router.Get("/leo.example.route.query.StringQuery/StringQuery").Handler(transports.StringQuery())
	return router
}

func NewStringQueryHttpClient(target string, opts ...httptransportx.ClientOption) StringQueryService {
	options := httptransportx.NewClientOptions(opts...)
	requestEncoder := &stringQueryHttpClientRequestEncoder{
		marshalOptions: options.MarshalOptions(),
		router:         appendStringQueryHttpRoutes(mux.NewRouter()),
		scheme:         options.Scheme(),
	}
	responseDecoder := &stringQueryHttpClientResponseDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	transports := &stringQueryHttpClientTransports{
		clientOptions:   options.ClientTransportOptions(),
		middlewares:     options.Middlewares(),
		requestEncoder:  requestEncoder,
		responseDecoder: responseDecoder,
	}
	factories := &stringQueryFactories{
		transports: transports,
	}
	endpointer := &stringQueryEndpointers{
		target:    target,
		builder:   options.Builder(),
		factories: factories,
		logger:    options.Logger(),
		options:   options.EndpointerOptions(),
	}
	balancers := &stringQueryBalancers{
		factory:    options.BalancerFactory(),
		endpointer: endpointer,
	}
	endpoints := &stringQueryClientEndpoints{
		balancers: balancers,
	}
	return &stringQueryClientService{
		endpoints:     endpoints,
		transportName: httptransportx.HttpClient,
	}
}

type StringQueryHttpServerTransports interface {
	StringQuery() http.Handler
}

type StringQueryHttpServerRequestDecoder interface {
	StringQuery() http1.DecodeRequestFunc
}

type StringQueryHttpServerResponseEncoder interface {
	StringQuery() http1.EncodeResponseFunc
}

type StringQueryHttpClientRequestEncoder interface {
	StringQuery(instance string) http1.CreateRequestFunc
}

type StringQueryHttpClientResponseDecoder interface {
	StringQuery() http1.DecodeResponseFunc
}

type stringQueryHttpServerTransports struct {
	endpoints       StringQueryServerEndpoints
	requestDecoder  StringQueryHttpServerRequestDecoder
	responseEncoder StringQueryHttpServerResponseEncoder
}

func (t *stringQueryHttpServerTransports) StringQuery() http.Handler {
	return http1.NewServer(
		t.endpoints.StringQuery(context.TODO()),
		t.requestDecoder.StringQuery(),
		t.responseEncoder.StringQuery(),
		http1.ServerBefore(httptransportx.EndpointInjector("/leo.example.route.query.StringQuery/StringQuery")),
		http1.ServerBefore(httptransportx.ServerTransportInjector),
		http1.ServerBefore(metadatax.HttpIncomingInjector),
		http1.ServerBefore(timeoutx.IncomingInjector),
		http1.ServerBefore(stainx.HttpIncomingInjector),
		http1.ServerFinalizer(timeoutx.CancelInvoker),
		http1.ServerErrorEncoder(coder.EncodeErrorToResponse),
	)
}

type stringQueryHttpServerRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder stringQueryHttpServerRequestDecoder) StringQuery() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &StringQueryRequest{}
		queries := r.URL.Query()
		var queryErr error
		req.String_ = queries.Get("string")
		req.OptString = proto.String(queries.Get("opt_string"))
		req.WrapString = wrapperspb.String(queries.Get("wrap_string"))
		if queryErr != nil {
			return nil, queryErr
		}
		return req, nil
	}
}

type stringQueryHttpServerResponseEncoder struct {
	marshalOptions protojson.MarshalOptions
}

func (encoder stringQueryHttpServerResponseEncoder) StringQuery() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*emptypb.Empty)
		return coder.EncodeMessageToResponse(ctx, w, resp, encoder.marshalOptions)
	}
}

type stringQueryHttpClientTransports struct {
	clientOptions   []http1.ClientOption
	middlewares     []endpoint.Middleware
	requestEncoder  StringQueryHttpClientRequestEncoder
	responseDecoder StringQueryHttpClientResponseDecoder
}

func (t *stringQueryHttpClientTransports) StringQuery(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(metadatax.HttpOutgoingInjector),
		http1.ClientBefore(timeoutx.OutgoingInjector),
		http1.ClientBefore(stainx.HttpOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.StringQuery(instance),
		t.responseDecoder.StringQuery(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

type stringQueryHttpClientRequestEncoder struct {
	marshalOptions protojson.MarshalOptions
	router         *mux.Router
	scheme         string
}

func (encoder stringQueryHttpClientRequestEncoder) StringQuery(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*StringQueryRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodGet
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		var pairs []string
		path, err := encoder.router.Get("/leo.example.route.query.StringQuery/StringQuery").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		queries := url.Values{}
		queries["string"] = append(queries["string"], req.GetString_())
		queries["opt_string"] = append(queries["opt_string"], req.GetOptString())
		queries["wrap_string"] = append(queries["wrap_string"], req.GetWrapString().GetValue())
		target.RawQuery = queries.Encode()
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx.CopyHeader(r.Header, header)
		return r, nil
	}
}

type stringQueryHttpClientResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder stringQueryHttpClientResponseDecoder) StringQuery() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if r.StatusCode != http.StatusOK {
			return nil, coder.DecodeErrorFromResponse(ctx, r)
		}
		resp := &emptypb.Empty{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}

func appendEnumQueryHttpRoutes(router *mux.Router) *mux.Router {
	router.NewRoute().
		Name("/leo.example.route.query.EnumQuery/EnumQuery").
		Methods(http.MethodGet).
		Path("/v1/enum")
	return router
}
func AppendEnumQueryHttpServerRoutes(router *mux.Router, svc EnumQueryService, opts ...httptransportx.ServerOption) *mux.Router {
	options := httptransportx.NewServerOptions(opts...)
	endpoints := &enumQueryServerEndpoints{
		svc:         svc,
		middlewares: options.Middlewares(),
	}
	requestDecoder := enumQueryHttpServerRequestDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	responseEncoder := enumQueryHttpServerResponseEncoder{
		marshalOptions: options.MarshalOptions(),
	}
	transports := &enumQueryHttpServerTransports{
		endpoints:       endpoints,
		requestDecoder:  requestDecoder,
		responseEncoder: responseEncoder,
	}
	router = appendEnumQueryHttpRoutes(router)
	router.Get("/leo.example.route.query.EnumQuery/EnumQuery").Handler(transports.EnumQuery())
	return router
}

func NewEnumQueryHttpClient(target string, opts ...httptransportx.ClientOption) EnumQueryService {
	options := httptransportx.NewClientOptions(opts...)
	requestEncoder := &enumQueryHttpClientRequestEncoder{
		marshalOptions: options.MarshalOptions(),
		router:         appendEnumQueryHttpRoutes(mux.NewRouter()),
		scheme:         options.Scheme(),
	}
	responseDecoder := &enumQueryHttpClientResponseDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	transports := &enumQueryHttpClientTransports{
		clientOptions:   options.ClientTransportOptions(),
		middlewares:     options.Middlewares(),
		requestEncoder:  requestEncoder,
		responseDecoder: responseDecoder,
	}
	factories := &enumQueryFactories{
		transports: transports,
	}
	endpointer := &enumQueryEndpointers{
		target:    target,
		builder:   options.Builder(),
		factories: factories,
		logger:    options.Logger(),
		options:   options.EndpointerOptions(),
	}
	balancers := &enumQueryBalancers{
		factory:    options.BalancerFactory(),
		endpointer: endpointer,
	}
	endpoints := &enumQueryClientEndpoints{
		balancers: balancers,
	}
	return &enumQueryClientService{
		endpoints:     endpoints,
		transportName: httptransportx.HttpClient,
	}
}

type EnumQueryHttpServerTransports interface {
	EnumQuery() http.Handler
}

type EnumQueryHttpServerRequestDecoder interface {
	EnumQuery() http1.DecodeRequestFunc
}

type EnumQueryHttpServerResponseEncoder interface {
	EnumQuery() http1.EncodeResponseFunc
}

type EnumQueryHttpClientRequestEncoder interface {
	EnumQuery(instance string) http1.CreateRequestFunc
}

type EnumQueryHttpClientResponseDecoder interface {
	EnumQuery() http1.DecodeResponseFunc
}

type enumQueryHttpServerTransports struct {
	endpoints       EnumQueryServerEndpoints
	requestDecoder  EnumQueryHttpServerRequestDecoder
	responseEncoder EnumQueryHttpServerResponseEncoder
}

func (t *enumQueryHttpServerTransports) EnumQuery() http.Handler {
	return http1.NewServer(
		t.endpoints.EnumQuery(context.TODO()),
		t.requestDecoder.EnumQuery(),
		t.responseEncoder.EnumQuery(),
		http1.ServerBefore(httptransportx.EndpointInjector("/leo.example.route.query.EnumQuery/EnumQuery")),
		http1.ServerBefore(httptransportx.ServerTransportInjector),
		http1.ServerBefore(metadatax.HttpIncomingInjector),
		http1.ServerBefore(timeoutx.IncomingInjector),
		http1.ServerBefore(stainx.HttpIncomingInjector),
		http1.ServerFinalizer(timeoutx.CancelInvoker),
		http1.ServerErrorEncoder(coder.EncodeErrorToResponse),
	)
}

type enumQueryHttpServerRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder enumQueryHttpServerRequestDecoder) EnumQuery() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &EnumQueryRequest{}
		queries := r.URL.Query()
		var queryErr error
		req.Status, queryErr = coder.DecodeForm[EnumQueryRequest_Status](queryErr, queries, "status", urlx.GetInt[EnumQueryRequest_Status])
		req.OptStatus, queryErr = coder.DecodeForm[*EnumQueryRequest_Status](queryErr, queries, "opt_status", urlx.GetIntPtr[EnumQueryRequest_Status])
		if queryErr != nil {
			return nil, queryErr
		}
		return req, nil
	}
}

type enumQueryHttpServerResponseEncoder struct {
	marshalOptions protojson.MarshalOptions
}

func (encoder enumQueryHttpServerResponseEncoder) EnumQuery() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*emptypb.Empty)
		return coder.EncodeMessageToResponse(ctx, w, resp, encoder.marshalOptions)
	}
}

type enumQueryHttpClientTransports struct {
	clientOptions   []http1.ClientOption
	middlewares     []endpoint.Middleware
	requestEncoder  EnumQueryHttpClientRequestEncoder
	responseDecoder EnumQueryHttpClientResponseDecoder
}

func (t *enumQueryHttpClientTransports) EnumQuery(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(metadatax.HttpOutgoingInjector),
		http1.ClientBefore(timeoutx.OutgoingInjector),
		http1.ClientBefore(stainx.HttpOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.EnumQuery(instance),
		t.responseDecoder.EnumQuery(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

type enumQueryHttpClientRequestEncoder struct {
	marshalOptions protojson.MarshalOptions
	router         *mux.Router
	scheme         string
}

func (encoder enumQueryHttpClientRequestEncoder) EnumQuery(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*EnumQueryRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodGet
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		var pairs []string
		path, err := encoder.router.Get("/leo.example.route.query.EnumQuery/EnumQuery").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		queries := url.Values{}
		queries["status"] = append(queries["status"], strconvx.FormatInt(req.GetStatus(), 10))
		queries["opt_status"] = append(queries["opt_status"], strconvx.FormatInt(req.GetOptStatus(), 10))
		target.RawQuery = queries.Encode()
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx.CopyHeader(r.Header, header)
		return r, nil
	}
}

type enumQueryHttpClientResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder enumQueryHttpClientResponseDecoder) EnumQuery() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if r.StatusCode != http.StatusOK {
			return nil, coder.DecodeErrorFromResponse(ctx, r)
		}
		resp := &emptypb.Empty{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}
