// Code generated by protoc-gen-go-leo. DO NOT EDIT.

package route

import (
	bytes "bytes"
	context "context"
	errors "errors"
	fmt "fmt"
	endpoint "github.com/go-kit/kit/endpoint"
	http1 "github.com/go-kit/kit/transport/http"
	httpx "github.com/go-leo/gox/netx/httpx"
	urlx "github.com/go-leo/gox/netx/urlx"
	strconvx "github.com/go-leo/gox/strconvx"
	endpointx "github.com/go-leo/leo/v3/endpointx"
	metadatax "github.com/go-leo/leo/v3/metadatax"
	stainx "github.com/go-leo/leo/v3/stainx"
	timeoutx "github.com/go-leo/leo/v3/timeoutx"
	httptransportx "github.com/go-leo/leo/v3/transportx/httptransportx"
	coder "github.com/go-leo/leo/v3/transportx/httptransportx/coder"
	mux "github.com/gorilla/mux"
	protojson "google.golang.org/protobuf/encoding/protojson"
	proto "google.golang.org/protobuf/proto"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	io "io"
	http "net/http"
	url "net/url"
	strings "strings"
)

func appendBoolPathHttpRoutes(router *mux.Router) *mux.Router {
	router.NewRoute().
		Name("/leo.example.route.path.BoolPath/BoolPath").
		Methods(http.MethodGet).
		Path("/v1/{bool}/{opt_bool}/{wrap_bool}")
	return router
}
func AppendBoolPathHttpServerRoutes(router *mux.Router, svc BoolPathService, opts ...httptransportx.ServerOption) *mux.Router {
	options := httptransportx.NewServerOptions(opts...)
	endpoints := &boolPathServerEndpoints{
		svc:         svc,
		middlewares: options.Middlewares(),
	}
	requestDecoder := boolPathHttpServerRequestDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	responseEncoder := boolPathHttpServerResponseEncoder{
		marshalOptions: options.MarshalOptions(),
	}
	transports := &boolPathHttpServerTransports{
		endpoints:       endpoints,
		requestDecoder:  requestDecoder,
		responseEncoder: responseEncoder,
	}
	router = appendBoolPathHttpRoutes(router)
	router.Get("/leo.example.route.path.BoolPath/BoolPath").Handler(transports.BoolPath())
	return router
}

func NewBoolPathHttpClient(target string, opts ...httptransportx.ClientOption) BoolPathService {
	options := httptransportx.NewClientOptions(opts...)
	requestEncoder := &boolPathHttpClientRequestEncoder{
		marshalOptions: options.MarshalOptions(),
		router:         appendBoolPathHttpRoutes(mux.NewRouter()),
		scheme:         options.Scheme(),
	}
	responseDecoder := &boolPathHttpClientResponseDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	transports := &boolPathHttpClientTransports{
		clientOptions:   options.ClientTransportOptions(),
		middlewares:     options.Middlewares(),
		requestEncoder:  requestEncoder,
		responseDecoder: responseDecoder,
	}
	factories := &boolPathFactories{
		transports: transports,
	}
	endpointer := &boolPathEndpointers{
		target:    target,
		builder:   options.Builder(),
		factories: factories,
		logger:    options.Logger(),
		options:   options.EndpointerOptions(),
	}
	balancers := &boolPathBalancers{
		factory:    options.BalancerFactory(),
		endpointer: endpointer,
	}
	endpoints := &boolPathClientEndpoints{
		balancers: balancers,
	}
	return &boolPathClientService{
		endpoints:     endpoints,
		transportName: httptransportx.HttpClient,
	}
}

type BoolPathHttpServerTransports interface {
	BoolPath() http.Handler
}

type BoolPathHttpServerRequestDecoder interface {
	BoolPath() http1.DecodeRequestFunc
}

type BoolPathHttpServerResponseEncoder interface {
	BoolPath() http1.EncodeResponseFunc
}

type BoolPathHttpClientRequestEncoder interface {
	BoolPath(instance string) http1.CreateRequestFunc
}

type BoolPathHttpClientResponseDecoder interface {
	BoolPath() http1.DecodeResponseFunc
}

type boolPathHttpServerTransports struct {
	endpoints       BoolPathServerEndpoints
	requestDecoder  BoolPathHttpServerRequestDecoder
	responseEncoder BoolPathHttpServerResponseEncoder
}

func (t *boolPathHttpServerTransports) BoolPath() http.Handler {
	return http1.NewServer(
		t.endpoints.BoolPath(context.TODO()),
		t.requestDecoder.BoolPath(),
		t.responseEncoder.BoolPath(),
		http1.ServerBefore(httptransportx.EndpointInjector("/leo.example.route.path.BoolPath/BoolPath")),
		http1.ServerBefore(httptransportx.ServerTransportInjector),
		http1.ServerBefore(metadatax.HttpIncomingInjector),
		http1.ServerBefore(timeoutx.IncomingInjector),
		http1.ServerBefore(stainx.HttpIncomingInjector),
		http1.ServerFinalizer(timeoutx.CancelInvoker),
		http1.ServerErrorEncoder(coder.EncodeErrorToResponse),
	)
}

type boolPathHttpServerRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder boolPathHttpServerRequestDecoder) BoolPath() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &BoolPathRequest{}
		vars := urlx.FormFromMap(mux.Vars(r))
		var varErr error
		req.Bool, varErr = coder.DecodeForm[bool](varErr, vars, "bool", urlx.GetBool)
		req.OptBool, varErr = coder.DecodeForm[*bool](varErr, vars, "opt_bool", urlx.GetBoolPtr)
		req.WrapBool, varErr = coder.DecodeForm[*wrapperspb.BoolValue](varErr, vars, "wrap_bool", urlx.GetBoolValue)
		if varErr != nil {
			return nil, varErr
		}
		return req, nil
	}
}

type boolPathHttpServerResponseEncoder struct {
	marshalOptions protojson.MarshalOptions
}

func (encoder boolPathHttpServerResponseEncoder) BoolPath() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*emptypb.Empty)
		return coder.EncodeMessageToResponse(ctx, w, resp, encoder.marshalOptions)
	}
}

type boolPathHttpClientTransports struct {
	clientOptions   []http1.ClientOption
	middlewares     []endpoint.Middleware
	requestEncoder  BoolPathHttpClientRequestEncoder
	responseDecoder BoolPathHttpClientResponseDecoder
}

func (t *boolPathHttpClientTransports) BoolPath(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(metadatax.HttpOutgoingInjector),
		http1.ClientBefore(timeoutx.OutgoingInjector),
		http1.ClientBefore(stainx.HttpOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.BoolPath(instance),
		t.responseDecoder.BoolPath(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

type boolPathHttpClientRequestEncoder struct {
	marshalOptions protojson.MarshalOptions
	router         *mux.Router
	scheme         string
}

func (encoder boolPathHttpClientRequestEncoder) BoolPath(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*BoolPathRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodGet
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		var pairs []string
		pairs = append(pairs,
			"bool", strconvx.FormatBool(req.GetBool()),
			"opt_bool", strconvx.FormatBool(req.GetOptBool()),
			"wrap_bool", strconvx.FormatBool(req.GetWrapBool().GetValue()),
		)
		path, err := encoder.router.Get("/leo.example.route.path.BoolPath/BoolPath").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx.CopyHeader(r.Header, header)
		return r, nil
	}
}

type boolPathHttpClientResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder boolPathHttpClientResponseDecoder) BoolPath() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if r.StatusCode != http.StatusOK {
			return nil, coder.DecodeErrorFromResponse(ctx, r)
		}
		resp := &emptypb.Empty{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}

func appendInt32PathHttpRoutes(router *mux.Router) *mux.Router {
	router.NewRoute().
		Name("/leo.example.route.path.Int32Path/Int32Path").
		Methods(http.MethodGet).
		Path("/v1/{int32}/{sint32}/{sfixed32}/{opt_int32}/{opt_sint32}/{opt_sfixed32}/{wrap_int32}")
	return router
}
func AppendInt32PathHttpServerRoutes(router *mux.Router, svc Int32PathService, opts ...httptransportx.ServerOption) *mux.Router {
	options := httptransportx.NewServerOptions(opts...)
	endpoints := &int32PathServerEndpoints{
		svc:         svc,
		middlewares: options.Middlewares(),
	}
	requestDecoder := int32PathHttpServerRequestDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	responseEncoder := int32PathHttpServerResponseEncoder{
		marshalOptions: options.MarshalOptions(),
	}
	transports := &int32PathHttpServerTransports{
		endpoints:       endpoints,
		requestDecoder:  requestDecoder,
		responseEncoder: responseEncoder,
	}
	router = appendInt32PathHttpRoutes(router)
	router.Get("/leo.example.route.path.Int32Path/Int32Path").Handler(transports.Int32Path())
	return router
}

func NewInt32PathHttpClient(target string, opts ...httptransportx.ClientOption) Int32PathService {
	options := httptransportx.NewClientOptions(opts...)
	requestEncoder := &int32PathHttpClientRequestEncoder{
		marshalOptions: options.MarshalOptions(),
		router:         appendInt32PathHttpRoutes(mux.NewRouter()),
		scheme:         options.Scheme(),
	}
	responseDecoder := &int32PathHttpClientResponseDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	transports := &int32PathHttpClientTransports{
		clientOptions:   options.ClientTransportOptions(),
		middlewares:     options.Middlewares(),
		requestEncoder:  requestEncoder,
		responseDecoder: responseDecoder,
	}
	factories := &int32PathFactories{
		transports: transports,
	}
	endpointer := &int32PathEndpointers{
		target:    target,
		builder:   options.Builder(),
		factories: factories,
		logger:    options.Logger(),
		options:   options.EndpointerOptions(),
	}
	balancers := &int32PathBalancers{
		factory:    options.BalancerFactory(),
		endpointer: endpointer,
	}
	endpoints := &int32PathClientEndpoints{
		balancers: balancers,
	}
	return &int32PathClientService{
		endpoints:     endpoints,
		transportName: httptransportx.HttpClient,
	}
}

type Int32PathHttpServerTransports interface {
	Int32Path() http.Handler
}

type Int32PathHttpServerRequestDecoder interface {
	Int32Path() http1.DecodeRequestFunc
}

type Int32PathHttpServerResponseEncoder interface {
	Int32Path() http1.EncodeResponseFunc
}

type Int32PathHttpClientRequestEncoder interface {
	Int32Path(instance string) http1.CreateRequestFunc
}

type Int32PathHttpClientResponseDecoder interface {
	Int32Path() http1.DecodeResponseFunc
}

type int32PathHttpServerTransports struct {
	endpoints       Int32PathServerEndpoints
	requestDecoder  Int32PathHttpServerRequestDecoder
	responseEncoder Int32PathHttpServerResponseEncoder
}

func (t *int32PathHttpServerTransports) Int32Path() http.Handler {
	return http1.NewServer(
		t.endpoints.Int32Path(context.TODO()),
		t.requestDecoder.Int32Path(),
		t.responseEncoder.Int32Path(),
		http1.ServerBefore(httptransportx.EndpointInjector("/leo.example.route.path.Int32Path/Int32Path")),
		http1.ServerBefore(httptransportx.ServerTransportInjector),
		http1.ServerBefore(metadatax.HttpIncomingInjector),
		http1.ServerBefore(timeoutx.IncomingInjector),
		http1.ServerBefore(stainx.HttpIncomingInjector),
		http1.ServerFinalizer(timeoutx.CancelInvoker),
		http1.ServerErrorEncoder(coder.EncodeErrorToResponse),
	)
}

type int32PathHttpServerRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder int32PathHttpServerRequestDecoder) Int32Path() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &Int32PathRequest{}
		vars := urlx.FormFromMap(mux.Vars(r))
		var varErr error
		req.Int32, varErr = coder.DecodeForm[int32](varErr, vars, "int32", urlx.GetInt)
		req.Sint32, varErr = coder.DecodeForm[int32](varErr, vars, "sint32", urlx.GetInt)
		req.Sfixed32, varErr = coder.DecodeForm[int32](varErr, vars, "sfixed32", urlx.GetInt)
		req.OptInt32, varErr = coder.DecodeForm[*int32](varErr, vars, "opt_int32", urlx.GetIntPtr)
		req.OptSint32, varErr = coder.DecodeForm[*int32](varErr, vars, "opt_sint32", urlx.GetIntPtr)
		req.OptSfixed32, varErr = coder.DecodeForm[*int32](varErr, vars, "opt_sfixed32", urlx.GetIntPtr)
		req.WrapInt32, varErr = coder.DecodeForm[*wrapperspb.Int32Value](varErr, vars, "wrap_int32", urlx.GetInt32Value)
		if varErr != nil {
			return nil, varErr
		}
		return req, nil
	}
}

type int32PathHttpServerResponseEncoder struct {
	marshalOptions protojson.MarshalOptions
}

func (encoder int32PathHttpServerResponseEncoder) Int32Path() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*emptypb.Empty)
		return coder.EncodeMessageToResponse(ctx, w, resp, encoder.marshalOptions)
	}
}

type int32PathHttpClientTransports struct {
	clientOptions   []http1.ClientOption
	middlewares     []endpoint.Middleware
	requestEncoder  Int32PathHttpClientRequestEncoder
	responseDecoder Int32PathHttpClientResponseDecoder
}

func (t *int32PathHttpClientTransports) Int32Path(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(metadatax.HttpOutgoingInjector),
		http1.ClientBefore(timeoutx.OutgoingInjector),
		http1.ClientBefore(stainx.HttpOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.Int32Path(instance),
		t.responseDecoder.Int32Path(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

type int32PathHttpClientRequestEncoder struct {
	marshalOptions protojson.MarshalOptions
	router         *mux.Router
	scheme         string
}

func (encoder int32PathHttpClientRequestEncoder) Int32Path(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*Int32PathRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodGet
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		var pairs []string
		pairs = append(pairs,
			"int32", strconvx.FormatInt(req.GetInt32(), 10),
			"sint32", strconvx.FormatInt(req.GetSint32(), 10),
			"sfixed32", strconvx.FormatInt(req.GetSfixed32(), 10),
			"opt_int32", strconvx.FormatInt(req.GetOptInt32(), 10),
			"opt_sint32", strconvx.FormatInt(req.GetOptSint32(), 10),
			"opt_sfixed32", strconvx.FormatInt(req.GetOptSfixed32(), 10),
			"wrap_int32", strconvx.FormatInt(req.GetWrapInt32().GetValue(), 10),
		)
		path, err := encoder.router.Get("/leo.example.route.path.Int32Path/Int32Path").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx.CopyHeader(r.Header, header)
		return r, nil
	}
}

type int32PathHttpClientResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder int32PathHttpClientResponseDecoder) Int32Path() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if r.StatusCode != http.StatusOK {
			return nil, coder.DecodeErrorFromResponse(ctx, r)
		}
		resp := &emptypb.Empty{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}

func appendInt64PathHttpRoutes(router *mux.Router) *mux.Router {
	router.NewRoute().
		Name("/leo.example.route.path.Int64Path/Int64Path").
		Methods(http.MethodGet).
		Path("/v1/{int64}/{sint64}/{sfixed64}/{opt_int64}/{opt_sint64}/{opt_sfixed64}/{wrap_int64}")
	return router
}
func AppendInt64PathHttpServerRoutes(router *mux.Router, svc Int64PathService, opts ...httptransportx.ServerOption) *mux.Router {
	options := httptransportx.NewServerOptions(opts...)
	endpoints := &int64PathServerEndpoints{
		svc:         svc,
		middlewares: options.Middlewares(),
	}
	requestDecoder := int64PathHttpServerRequestDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	responseEncoder := int64PathHttpServerResponseEncoder{
		marshalOptions: options.MarshalOptions(),
	}
	transports := &int64PathHttpServerTransports{
		endpoints:       endpoints,
		requestDecoder:  requestDecoder,
		responseEncoder: responseEncoder,
	}
	router = appendInt64PathHttpRoutes(router)
	router.Get("/leo.example.route.path.Int64Path/Int64Path").Handler(transports.Int64Path())
	return router
}

func NewInt64PathHttpClient(target string, opts ...httptransportx.ClientOption) Int64PathService {
	options := httptransportx.NewClientOptions(opts...)
	requestEncoder := &int64PathHttpClientRequestEncoder{
		marshalOptions: options.MarshalOptions(),
		router:         appendInt64PathHttpRoutes(mux.NewRouter()),
		scheme:         options.Scheme(),
	}
	responseDecoder := &int64PathHttpClientResponseDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	transports := &int64PathHttpClientTransports{
		clientOptions:   options.ClientTransportOptions(),
		middlewares:     options.Middlewares(),
		requestEncoder:  requestEncoder,
		responseDecoder: responseDecoder,
	}
	factories := &int64PathFactories{
		transports: transports,
	}
	endpointer := &int64PathEndpointers{
		target:    target,
		builder:   options.Builder(),
		factories: factories,
		logger:    options.Logger(),
		options:   options.EndpointerOptions(),
	}
	balancers := &int64PathBalancers{
		factory:    options.BalancerFactory(),
		endpointer: endpointer,
	}
	endpoints := &int64PathClientEndpoints{
		balancers: balancers,
	}
	return &int64PathClientService{
		endpoints:     endpoints,
		transportName: httptransportx.HttpClient,
	}
}

type Int64PathHttpServerTransports interface {
	Int64Path() http.Handler
}

type Int64PathHttpServerRequestDecoder interface {
	Int64Path() http1.DecodeRequestFunc
}

type Int64PathHttpServerResponseEncoder interface {
	Int64Path() http1.EncodeResponseFunc
}

type Int64PathHttpClientRequestEncoder interface {
	Int64Path(instance string) http1.CreateRequestFunc
}

type Int64PathHttpClientResponseDecoder interface {
	Int64Path() http1.DecodeResponseFunc
}

type int64PathHttpServerTransports struct {
	endpoints       Int64PathServerEndpoints
	requestDecoder  Int64PathHttpServerRequestDecoder
	responseEncoder Int64PathHttpServerResponseEncoder
}

func (t *int64PathHttpServerTransports) Int64Path() http.Handler {
	return http1.NewServer(
		t.endpoints.Int64Path(context.TODO()),
		t.requestDecoder.Int64Path(),
		t.responseEncoder.Int64Path(),
		http1.ServerBefore(httptransportx.EndpointInjector("/leo.example.route.path.Int64Path/Int64Path")),
		http1.ServerBefore(httptransportx.ServerTransportInjector),
		http1.ServerBefore(metadatax.HttpIncomingInjector),
		http1.ServerBefore(timeoutx.IncomingInjector),
		http1.ServerBefore(stainx.HttpIncomingInjector),
		http1.ServerFinalizer(timeoutx.CancelInvoker),
		http1.ServerErrorEncoder(coder.EncodeErrorToResponse),
	)
}

type int64PathHttpServerRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder int64PathHttpServerRequestDecoder) Int64Path() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &Int64PathRequest{}
		vars := urlx.FormFromMap(mux.Vars(r))
		var varErr error
		req.Int64, varErr = coder.DecodeForm[int64](varErr, vars, "int64", urlx.GetInt)
		req.Sint64, varErr = coder.DecodeForm[int64](varErr, vars, "sint64", urlx.GetInt)
		req.Sfixed64, varErr = coder.DecodeForm[int64](varErr, vars, "sfixed64", urlx.GetInt)
		req.OptInt64, varErr = coder.DecodeForm[*int64](varErr, vars, "opt_int64", urlx.GetIntPtr)
		req.OptSint64, varErr = coder.DecodeForm[*int64](varErr, vars, "opt_sint64", urlx.GetIntPtr)
		req.OptSfixed64, varErr = coder.DecodeForm[*int64](varErr, vars, "opt_sfixed64", urlx.GetIntPtr)
		req.WrapInt64, varErr = coder.DecodeForm[*wrapperspb.Int64Value](varErr, vars, "wrap_int64", urlx.GetInt64Value)
		if varErr != nil {
			return nil, varErr
		}
		return req, nil
	}
}

type int64PathHttpServerResponseEncoder struct {
	marshalOptions protojson.MarshalOptions
}

func (encoder int64PathHttpServerResponseEncoder) Int64Path() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*emptypb.Empty)
		return coder.EncodeMessageToResponse(ctx, w, resp, encoder.marshalOptions)
	}
}

type int64PathHttpClientTransports struct {
	clientOptions   []http1.ClientOption
	middlewares     []endpoint.Middleware
	requestEncoder  Int64PathHttpClientRequestEncoder
	responseDecoder Int64PathHttpClientResponseDecoder
}

func (t *int64PathHttpClientTransports) Int64Path(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(metadatax.HttpOutgoingInjector),
		http1.ClientBefore(timeoutx.OutgoingInjector),
		http1.ClientBefore(stainx.HttpOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.Int64Path(instance),
		t.responseDecoder.Int64Path(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

type int64PathHttpClientRequestEncoder struct {
	marshalOptions protojson.MarshalOptions
	router         *mux.Router
	scheme         string
}

func (encoder int64PathHttpClientRequestEncoder) Int64Path(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*Int64PathRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodGet
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		var pairs []string
		pairs = append(pairs,
			"int64", strconvx.FormatInt(req.GetInt64(), 10),
			"sint64", strconvx.FormatInt(req.GetSint64(), 10),
			"sfixed64", strconvx.FormatInt(req.GetSfixed64(), 10),
			"opt_int64", strconvx.FormatInt(req.GetOptInt64(), 10),
			"opt_sint64", strconvx.FormatInt(req.GetOptSint64(), 10),
			"opt_sfixed64", strconvx.FormatInt(req.GetOptSfixed64(), 10),
			"wrap_int64", strconvx.FormatInt(req.GetWrapInt64().GetValue(), 10),
		)
		path, err := encoder.router.Get("/leo.example.route.path.Int64Path/Int64Path").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx.CopyHeader(r.Header, header)
		return r, nil
	}
}

type int64PathHttpClientResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder int64PathHttpClientResponseDecoder) Int64Path() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if r.StatusCode != http.StatusOK {
			return nil, coder.DecodeErrorFromResponse(ctx, r)
		}
		resp := &emptypb.Empty{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}

func appendUint32PathHttpRoutes(router *mux.Router) *mux.Router {
	router.NewRoute().
		Name("/leo.example.route.path.Uint32Path/Uint32Path").
		Methods(http.MethodGet).
		Path("/v1/{uint32}/{fixed32}/{opt_uint32}/{opt_fixed32}/{wrap_uint32}")
	return router
}
func AppendUint32PathHttpServerRoutes(router *mux.Router, svc Uint32PathService, opts ...httptransportx.ServerOption) *mux.Router {
	options := httptransportx.NewServerOptions(opts...)
	endpoints := &uint32PathServerEndpoints{
		svc:         svc,
		middlewares: options.Middlewares(),
	}
	requestDecoder := uint32PathHttpServerRequestDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	responseEncoder := uint32PathHttpServerResponseEncoder{
		marshalOptions: options.MarshalOptions(),
	}
	transports := &uint32PathHttpServerTransports{
		endpoints:       endpoints,
		requestDecoder:  requestDecoder,
		responseEncoder: responseEncoder,
	}
	router = appendUint32PathHttpRoutes(router)
	router.Get("/leo.example.route.path.Uint32Path/Uint32Path").Handler(transports.Uint32Path())
	return router
}

func NewUint32PathHttpClient(target string, opts ...httptransportx.ClientOption) Uint32PathService {
	options := httptransportx.NewClientOptions(opts...)
	requestEncoder := &uint32PathHttpClientRequestEncoder{
		marshalOptions: options.MarshalOptions(),
		router:         appendUint32PathHttpRoutes(mux.NewRouter()),
		scheme:         options.Scheme(),
	}
	responseDecoder := &uint32PathHttpClientResponseDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	transports := &uint32PathHttpClientTransports{
		clientOptions:   options.ClientTransportOptions(),
		middlewares:     options.Middlewares(),
		requestEncoder:  requestEncoder,
		responseDecoder: responseDecoder,
	}
	factories := &uint32PathFactories{
		transports: transports,
	}
	endpointer := &uint32PathEndpointers{
		target:    target,
		builder:   options.Builder(),
		factories: factories,
		logger:    options.Logger(),
		options:   options.EndpointerOptions(),
	}
	balancers := &uint32PathBalancers{
		factory:    options.BalancerFactory(),
		endpointer: endpointer,
	}
	endpoints := &uint32PathClientEndpoints{
		balancers: balancers,
	}
	return &uint32PathClientService{
		endpoints:     endpoints,
		transportName: httptransportx.HttpClient,
	}
}

type Uint32PathHttpServerTransports interface {
	Uint32Path() http.Handler
}

type Uint32PathHttpServerRequestDecoder interface {
	Uint32Path() http1.DecodeRequestFunc
}

type Uint32PathHttpServerResponseEncoder interface {
	Uint32Path() http1.EncodeResponseFunc
}

type Uint32PathHttpClientRequestEncoder interface {
	Uint32Path(instance string) http1.CreateRequestFunc
}

type Uint32PathHttpClientResponseDecoder interface {
	Uint32Path() http1.DecodeResponseFunc
}

type uint32PathHttpServerTransports struct {
	endpoints       Uint32PathServerEndpoints
	requestDecoder  Uint32PathHttpServerRequestDecoder
	responseEncoder Uint32PathHttpServerResponseEncoder
}

func (t *uint32PathHttpServerTransports) Uint32Path() http.Handler {
	return http1.NewServer(
		t.endpoints.Uint32Path(context.TODO()),
		t.requestDecoder.Uint32Path(),
		t.responseEncoder.Uint32Path(),
		http1.ServerBefore(httptransportx.EndpointInjector("/leo.example.route.path.Uint32Path/Uint32Path")),
		http1.ServerBefore(httptransportx.ServerTransportInjector),
		http1.ServerBefore(metadatax.HttpIncomingInjector),
		http1.ServerBefore(timeoutx.IncomingInjector),
		http1.ServerBefore(stainx.HttpIncomingInjector),
		http1.ServerFinalizer(timeoutx.CancelInvoker),
		http1.ServerErrorEncoder(coder.EncodeErrorToResponse),
	)
}

type uint32PathHttpServerRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder uint32PathHttpServerRequestDecoder) Uint32Path() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &Uint32PathRequest{}
		vars := urlx.FormFromMap(mux.Vars(r))
		var varErr error
		req.Uint32, varErr = coder.DecodeForm[uint32](varErr, vars, "uint32", urlx.GetUint)
		req.Fixed32, varErr = coder.DecodeForm[uint32](varErr, vars, "fixed32", urlx.GetUint)
		req.OptUint32, varErr = coder.DecodeForm[*uint32](varErr, vars, "opt_uint32", urlx.GetUintPtr)
		req.OptFixed32, varErr = coder.DecodeForm[*uint32](varErr, vars, "opt_fixed32", urlx.GetUintPtr)
		req.WrapUint32, varErr = coder.DecodeForm[*wrapperspb.UInt32Value](varErr, vars, "wrap_uint32", urlx.GetUint32Value)
		if varErr != nil {
			return nil, varErr
		}
		return req, nil
	}
}

type uint32PathHttpServerResponseEncoder struct {
	marshalOptions protojson.MarshalOptions
}

func (encoder uint32PathHttpServerResponseEncoder) Uint32Path() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*emptypb.Empty)
		return coder.EncodeMessageToResponse(ctx, w, resp, encoder.marshalOptions)
	}
}

type uint32PathHttpClientTransports struct {
	clientOptions   []http1.ClientOption
	middlewares     []endpoint.Middleware
	requestEncoder  Uint32PathHttpClientRequestEncoder
	responseDecoder Uint32PathHttpClientResponseDecoder
}

func (t *uint32PathHttpClientTransports) Uint32Path(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(metadatax.HttpOutgoingInjector),
		http1.ClientBefore(timeoutx.OutgoingInjector),
		http1.ClientBefore(stainx.HttpOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.Uint32Path(instance),
		t.responseDecoder.Uint32Path(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

type uint32PathHttpClientRequestEncoder struct {
	marshalOptions protojson.MarshalOptions
	router         *mux.Router
	scheme         string
}

func (encoder uint32PathHttpClientRequestEncoder) Uint32Path(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*Uint32PathRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodGet
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		var pairs []string
		pairs = append(pairs,
			"uint32", strconvx.FormatUint(req.GetUint32(), 10),
			"fixed32", strconvx.FormatUint(req.GetFixed32(), 10),
			"opt_uint32", strconvx.FormatUint(req.GetOptUint32(), 10),
			"opt_fixed32", strconvx.FormatUint(req.GetOptFixed32(), 10),
			"wrap_uint32", strconvx.FormatUint(req.GetWrapUint32().GetValue(), 10),
		)
		path, err := encoder.router.Get("/leo.example.route.path.Uint32Path/Uint32Path").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx.CopyHeader(r.Header, header)
		return r, nil
	}
}

type uint32PathHttpClientResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder uint32PathHttpClientResponseDecoder) Uint32Path() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if r.StatusCode != http.StatusOK {
			return nil, coder.DecodeErrorFromResponse(ctx, r)
		}
		resp := &emptypb.Empty{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}

func appendUint64PathHttpRoutes(router *mux.Router) *mux.Router {
	router.NewRoute().
		Name("/leo.example.route.path.Uint64Path/Uint64Path").
		Methods(http.MethodGet).
		Path("/v1/{uint64}/{fixed64}/{opt_uint64}/{opt_fixed64}/{wrap_uint64}")
	return router
}
func AppendUint64PathHttpServerRoutes(router *mux.Router, svc Uint64PathService, opts ...httptransportx.ServerOption) *mux.Router {
	options := httptransportx.NewServerOptions(opts...)
	endpoints := &uint64PathServerEndpoints{
		svc:         svc,
		middlewares: options.Middlewares(),
	}
	requestDecoder := uint64PathHttpServerRequestDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	responseEncoder := uint64PathHttpServerResponseEncoder{
		marshalOptions: options.MarshalOptions(),
	}
	transports := &uint64PathHttpServerTransports{
		endpoints:       endpoints,
		requestDecoder:  requestDecoder,
		responseEncoder: responseEncoder,
	}
	router = appendUint64PathHttpRoutes(router)
	router.Get("/leo.example.route.path.Uint64Path/Uint64Path").Handler(transports.Uint64Path())
	return router
}

func NewUint64PathHttpClient(target string, opts ...httptransportx.ClientOption) Uint64PathService {
	options := httptransportx.NewClientOptions(opts...)
	requestEncoder := &uint64PathHttpClientRequestEncoder{
		marshalOptions: options.MarshalOptions(),
		router:         appendUint64PathHttpRoutes(mux.NewRouter()),
		scheme:         options.Scheme(),
	}
	responseDecoder := &uint64PathHttpClientResponseDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	transports := &uint64PathHttpClientTransports{
		clientOptions:   options.ClientTransportOptions(),
		middlewares:     options.Middlewares(),
		requestEncoder:  requestEncoder,
		responseDecoder: responseDecoder,
	}
	factories := &uint64PathFactories{
		transports: transports,
	}
	endpointer := &uint64PathEndpointers{
		target:    target,
		builder:   options.Builder(),
		factories: factories,
		logger:    options.Logger(),
		options:   options.EndpointerOptions(),
	}
	balancers := &uint64PathBalancers{
		factory:    options.BalancerFactory(),
		endpointer: endpointer,
	}
	endpoints := &uint64PathClientEndpoints{
		balancers: balancers,
	}
	return &uint64PathClientService{
		endpoints:     endpoints,
		transportName: httptransportx.HttpClient,
	}
}

type Uint64PathHttpServerTransports interface {
	Uint64Path() http.Handler
}

type Uint64PathHttpServerRequestDecoder interface {
	Uint64Path() http1.DecodeRequestFunc
}

type Uint64PathHttpServerResponseEncoder interface {
	Uint64Path() http1.EncodeResponseFunc
}

type Uint64PathHttpClientRequestEncoder interface {
	Uint64Path(instance string) http1.CreateRequestFunc
}

type Uint64PathHttpClientResponseDecoder interface {
	Uint64Path() http1.DecodeResponseFunc
}

type uint64PathHttpServerTransports struct {
	endpoints       Uint64PathServerEndpoints
	requestDecoder  Uint64PathHttpServerRequestDecoder
	responseEncoder Uint64PathHttpServerResponseEncoder
}

func (t *uint64PathHttpServerTransports) Uint64Path() http.Handler {
	return http1.NewServer(
		t.endpoints.Uint64Path(context.TODO()),
		t.requestDecoder.Uint64Path(),
		t.responseEncoder.Uint64Path(),
		http1.ServerBefore(httptransportx.EndpointInjector("/leo.example.route.path.Uint64Path/Uint64Path")),
		http1.ServerBefore(httptransportx.ServerTransportInjector),
		http1.ServerBefore(metadatax.HttpIncomingInjector),
		http1.ServerBefore(timeoutx.IncomingInjector),
		http1.ServerBefore(stainx.HttpIncomingInjector),
		http1.ServerFinalizer(timeoutx.CancelInvoker),
		http1.ServerErrorEncoder(coder.EncodeErrorToResponse),
	)
}

type uint64PathHttpServerRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder uint64PathHttpServerRequestDecoder) Uint64Path() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &Uint64PathRequest{}
		vars := urlx.FormFromMap(mux.Vars(r))
		var varErr error
		req.Uint64, varErr = coder.DecodeForm[uint64](varErr, vars, "uint64", urlx.GetUint)
		req.Fixed64, varErr = coder.DecodeForm[uint64](varErr, vars, "fixed64", urlx.GetUint)
		req.OptUint64, varErr = coder.DecodeForm[*uint64](varErr, vars, "opt_uint64", urlx.GetUintPtr)
		req.OptFixed64, varErr = coder.DecodeForm[*uint64](varErr, vars, "opt_fixed64", urlx.GetUintPtr)
		req.WrapUint64, varErr = coder.DecodeForm[*wrapperspb.UInt64Value](varErr, vars, "wrap_uint64", urlx.GetUint64Value)
		if varErr != nil {
			return nil, varErr
		}
		return req, nil
	}
}

type uint64PathHttpServerResponseEncoder struct {
	marshalOptions protojson.MarshalOptions
}

func (encoder uint64PathHttpServerResponseEncoder) Uint64Path() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*emptypb.Empty)
		return coder.EncodeMessageToResponse(ctx, w, resp, encoder.marshalOptions)
	}
}

type uint64PathHttpClientTransports struct {
	clientOptions   []http1.ClientOption
	middlewares     []endpoint.Middleware
	requestEncoder  Uint64PathHttpClientRequestEncoder
	responseDecoder Uint64PathHttpClientResponseDecoder
}

func (t *uint64PathHttpClientTransports) Uint64Path(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(metadatax.HttpOutgoingInjector),
		http1.ClientBefore(timeoutx.OutgoingInjector),
		http1.ClientBefore(stainx.HttpOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.Uint64Path(instance),
		t.responseDecoder.Uint64Path(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

type uint64PathHttpClientRequestEncoder struct {
	marshalOptions protojson.MarshalOptions
	router         *mux.Router
	scheme         string
}

func (encoder uint64PathHttpClientRequestEncoder) Uint64Path(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*Uint64PathRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodGet
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		var pairs []string
		pairs = append(pairs,
			"uint64", strconvx.FormatUint(req.GetUint64(), 10),
			"fixed64", strconvx.FormatUint(req.GetFixed64(), 10),
			"opt_uint64", strconvx.FormatUint(req.GetOptUint64(), 10),
			"opt_fixed64", strconvx.FormatUint(req.GetOptFixed64(), 10),
			"wrap_uint64", strconvx.FormatUint(req.GetWrapUint64().GetValue(), 10),
		)
		path, err := encoder.router.Get("/leo.example.route.path.Uint64Path/Uint64Path").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx.CopyHeader(r.Header, header)
		return r, nil
	}
}

type uint64PathHttpClientResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder uint64PathHttpClientResponseDecoder) Uint64Path() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if r.StatusCode != http.StatusOK {
			return nil, coder.DecodeErrorFromResponse(ctx, r)
		}
		resp := &emptypb.Empty{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}

func appendFloatPathHttpRoutes(router *mux.Router) *mux.Router {
	router.NewRoute().
		Name("/leo.example.route.path.FloatPath/FloatPath").
		Methods(http.MethodGet).
		Path("/v1/{float}/{opt_float}/{wrap_float}")
	return router
}
func AppendFloatPathHttpServerRoutes(router *mux.Router, svc FloatPathService, opts ...httptransportx.ServerOption) *mux.Router {
	options := httptransportx.NewServerOptions(opts...)
	endpoints := &floatPathServerEndpoints{
		svc:         svc,
		middlewares: options.Middlewares(),
	}
	requestDecoder := floatPathHttpServerRequestDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	responseEncoder := floatPathHttpServerResponseEncoder{
		marshalOptions: options.MarshalOptions(),
	}
	transports := &floatPathHttpServerTransports{
		endpoints:       endpoints,
		requestDecoder:  requestDecoder,
		responseEncoder: responseEncoder,
	}
	router = appendFloatPathHttpRoutes(router)
	router.Get("/leo.example.route.path.FloatPath/FloatPath").Handler(transports.FloatPath())
	return router
}

func NewFloatPathHttpClient(target string, opts ...httptransportx.ClientOption) FloatPathService {
	options := httptransportx.NewClientOptions(opts...)
	requestEncoder := &floatPathHttpClientRequestEncoder{
		marshalOptions: options.MarshalOptions(),
		router:         appendFloatPathHttpRoutes(mux.NewRouter()),
		scheme:         options.Scheme(),
	}
	responseDecoder := &floatPathHttpClientResponseDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	transports := &floatPathHttpClientTransports{
		clientOptions:   options.ClientTransportOptions(),
		middlewares:     options.Middlewares(),
		requestEncoder:  requestEncoder,
		responseDecoder: responseDecoder,
	}
	factories := &floatPathFactories{
		transports: transports,
	}
	endpointer := &floatPathEndpointers{
		target:    target,
		builder:   options.Builder(),
		factories: factories,
		logger:    options.Logger(),
		options:   options.EndpointerOptions(),
	}
	balancers := &floatPathBalancers{
		factory:    options.BalancerFactory(),
		endpointer: endpointer,
	}
	endpoints := &floatPathClientEndpoints{
		balancers: balancers,
	}
	return &floatPathClientService{
		endpoints:     endpoints,
		transportName: httptransportx.HttpClient,
	}
}

type FloatPathHttpServerTransports interface {
	FloatPath() http.Handler
}

type FloatPathHttpServerRequestDecoder interface {
	FloatPath() http1.DecodeRequestFunc
}

type FloatPathHttpServerResponseEncoder interface {
	FloatPath() http1.EncodeResponseFunc
}

type FloatPathHttpClientRequestEncoder interface {
	FloatPath(instance string) http1.CreateRequestFunc
}

type FloatPathHttpClientResponseDecoder interface {
	FloatPath() http1.DecodeResponseFunc
}

type floatPathHttpServerTransports struct {
	endpoints       FloatPathServerEndpoints
	requestDecoder  FloatPathHttpServerRequestDecoder
	responseEncoder FloatPathHttpServerResponseEncoder
}

func (t *floatPathHttpServerTransports) FloatPath() http.Handler {
	return http1.NewServer(
		t.endpoints.FloatPath(context.TODO()),
		t.requestDecoder.FloatPath(),
		t.responseEncoder.FloatPath(),
		http1.ServerBefore(httptransportx.EndpointInjector("/leo.example.route.path.FloatPath/FloatPath")),
		http1.ServerBefore(httptransportx.ServerTransportInjector),
		http1.ServerBefore(metadatax.HttpIncomingInjector),
		http1.ServerBefore(timeoutx.IncomingInjector),
		http1.ServerBefore(stainx.HttpIncomingInjector),
		http1.ServerFinalizer(timeoutx.CancelInvoker),
		http1.ServerErrorEncoder(coder.EncodeErrorToResponse),
	)
}

type floatPathHttpServerRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder floatPathHttpServerRequestDecoder) FloatPath() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &FloatPathRequest{}
		vars := urlx.FormFromMap(mux.Vars(r))
		var varErr error
		req.Float, varErr = coder.DecodeForm[float32](varErr, vars, "float", urlx.GetFloat)
		req.OptFloat, varErr = coder.DecodeForm[*float32](varErr, vars, "opt_float", urlx.GetFloatPtr)
		req.WrapFloat, varErr = coder.DecodeForm[*wrapperspb.FloatValue](varErr, vars, "wrap_float", urlx.GetFloat32Value)
		if varErr != nil {
			return nil, varErr
		}
		return req, nil
	}
}

type floatPathHttpServerResponseEncoder struct {
	marshalOptions protojson.MarshalOptions
}

func (encoder floatPathHttpServerResponseEncoder) FloatPath() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*emptypb.Empty)
		return coder.EncodeMessageToResponse(ctx, w, resp, encoder.marshalOptions)
	}
}

type floatPathHttpClientTransports struct {
	clientOptions   []http1.ClientOption
	middlewares     []endpoint.Middleware
	requestEncoder  FloatPathHttpClientRequestEncoder
	responseDecoder FloatPathHttpClientResponseDecoder
}

func (t *floatPathHttpClientTransports) FloatPath(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(metadatax.HttpOutgoingInjector),
		http1.ClientBefore(timeoutx.OutgoingInjector),
		http1.ClientBefore(stainx.HttpOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.FloatPath(instance),
		t.responseDecoder.FloatPath(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

type floatPathHttpClientRequestEncoder struct {
	marshalOptions protojson.MarshalOptions
	router         *mux.Router
	scheme         string
}

func (encoder floatPathHttpClientRequestEncoder) FloatPath(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*FloatPathRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodGet
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		var pairs []string
		pairs = append(pairs,
			"float", strconvx.FormatFloat(req.GetFloat(), 'f', -1, 32),
			"opt_float", strconvx.FormatFloat(req.GetOptFloat(), 'f', -1, 32),
			"wrap_float", strconvx.FormatFloat(req.GetWrapFloat().GetValue(), 'f', -1, 32),
		)
		path, err := encoder.router.Get("/leo.example.route.path.FloatPath/FloatPath").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx.CopyHeader(r.Header, header)
		return r, nil
	}
}

type floatPathHttpClientResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder floatPathHttpClientResponseDecoder) FloatPath() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if r.StatusCode != http.StatusOK {
			return nil, coder.DecodeErrorFromResponse(ctx, r)
		}
		resp := &emptypb.Empty{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}

func appendDoublePathHttpRoutes(router *mux.Router) *mux.Router {
	router.NewRoute().
		Name("/leo.example.route.path.DoublePath/DoublePath").
		Methods(http.MethodGet).
		Path("/v1/{double}/{opt_double}/{wrap_double}")
	return router
}
func AppendDoublePathHttpServerRoutes(router *mux.Router, svc DoublePathService, opts ...httptransportx.ServerOption) *mux.Router {
	options := httptransportx.NewServerOptions(opts...)
	endpoints := &doublePathServerEndpoints{
		svc:         svc,
		middlewares: options.Middlewares(),
	}
	requestDecoder := doublePathHttpServerRequestDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	responseEncoder := doublePathHttpServerResponseEncoder{
		marshalOptions: options.MarshalOptions(),
	}
	transports := &doublePathHttpServerTransports{
		endpoints:       endpoints,
		requestDecoder:  requestDecoder,
		responseEncoder: responseEncoder,
	}
	router = appendDoublePathHttpRoutes(router)
	router.Get("/leo.example.route.path.DoublePath/DoublePath").Handler(transports.DoublePath())
	return router
}

func NewDoublePathHttpClient(target string, opts ...httptransportx.ClientOption) DoublePathService {
	options := httptransportx.NewClientOptions(opts...)
	requestEncoder := &doublePathHttpClientRequestEncoder{
		marshalOptions: options.MarshalOptions(),
		router:         appendDoublePathHttpRoutes(mux.NewRouter()),
		scheme:         options.Scheme(),
	}
	responseDecoder := &doublePathHttpClientResponseDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	transports := &doublePathHttpClientTransports{
		clientOptions:   options.ClientTransportOptions(),
		middlewares:     options.Middlewares(),
		requestEncoder:  requestEncoder,
		responseDecoder: responseDecoder,
	}
	factories := &doublePathFactories{
		transports: transports,
	}
	endpointer := &doublePathEndpointers{
		target:    target,
		builder:   options.Builder(),
		factories: factories,
		logger:    options.Logger(),
		options:   options.EndpointerOptions(),
	}
	balancers := &doublePathBalancers{
		factory:    options.BalancerFactory(),
		endpointer: endpointer,
	}
	endpoints := &doublePathClientEndpoints{
		balancers: balancers,
	}
	return &doublePathClientService{
		endpoints:     endpoints,
		transportName: httptransportx.HttpClient,
	}
}

type DoublePathHttpServerTransports interface {
	DoublePath() http.Handler
}

type DoublePathHttpServerRequestDecoder interface {
	DoublePath() http1.DecodeRequestFunc
}

type DoublePathHttpServerResponseEncoder interface {
	DoublePath() http1.EncodeResponseFunc
}

type DoublePathHttpClientRequestEncoder interface {
	DoublePath(instance string) http1.CreateRequestFunc
}

type DoublePathHttpClientResponseDecoder interface {
	DoublePath() http1.DecodeResponseFunc
}

type doublePathHttpServerTransports struct {
	endpoints       DoublePathServerEndpoints
	requestDecoder  DoublePathHttpServerRequestDecoder
	responseEncoder DoublePathHttpServerResponseEncoder
}

func (t *doublePathHttpServerTransports) DoublePath() http.Handler {
	return http1.NewServer(
		t.endpoints.DoublePath(context.TODO()),
		t.requestDecoder.DoublePath(),
		t.responseEncoder.DoublePath(),
		http1.ServerBefore(httptransportx.EndpointInjector("/leo.example.route.path.DoublePath/DoublePath")),
		http1.ServerBefore(httptransportx.ServerTransportInjector),
		http1.ServerBefore(metadatax.HttpIncomingInjector),
		http1.ServerBefore(timeoutx.IncomingInjector),
		http1.ServerBefore(stainx.HttpIncomingInjector),
		http1.ServerFinalizer(timeoutx.CancelInvoker),
		http1.ServerErrorEncoder(coder.EncodeErrorToResponse),
	)
}

type doublePathHttpServerRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder doublePathHttpServerRequestDecoder) DoublePath() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &DoublePathRequest{}
		vars := urlx.FormFromMap(mux.Vars(r))
		var varErr error
		req.Double, varErr = coder.DecodeForm[float64](varErr, vars, "double", urlx.GetFloat)
		req.OptDouble, varErr = coder.DecodeForm[*float64](varErr, vars, "opt_double", urlx.GetFloatPtr)
		req.WrapDouble, varErr = coder.DecodeForm[*wrapperspb.DoubleValue](varErr, vars, "wrap_double", urlx.GetFloat64Value)
		if varErr != nil {
			return nil, varErr
		}
		return req, nil
	}
}

type doublePathHttpServerResponseEncoder struct {
	marshalOptions protojson.MarshalOptions
}

func (encoder doublePathHttpServerResponseEncoder) DoublePath() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*emptypb.Empty)
		return coder.EncodeMessageToResponse(ctx, w, resp, encoder.marshalOptions)
	}
}

type doublePathHttpClientTransports struct {
	clientOptions   []http1.ClientOption
	middlewares     []endpoint.Middleware
	requestEncoder  DoublePathHttpClientRequestEncoder
	responseDecoder DoublePathHttpClientResponseDecoder
}

func (t *doublePathHttpClientTransports) DoublePath(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(metadatax.HttpOutgoingInjector),
		http1.ClientBefore(timeoutx.OutgoingInjector),
		http1.ClientBefore(stainx.HttpOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.DoublePath(instance),
		t.responseDecoder.DoublePath(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

type doublePathHttpClientRequestEncoder struct {
	marshalOptions protojson.MarshalOptions
	router         *mux.Router
	scheme         string
}

func (encoder doublePathHttpClientRequestEncoder) DoublePath(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*DoublePathRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodGet
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		var pairs []string
		pairs = append(pairs,
			"double", strconvx.FormatFloat(req.GetDouble(), 'f', -1, 64),
			"opt_double", strconvx.FormatFloat(req.GetOptDouble(), 'f', -1, 64),
			"wrap_double", strconvx.FormatFloat(req.GetWrapDouble().GetValue(), 'f', -1, 64),
		)
		path, err := encoder.router.Get("/leo.example.route.path.DoublePath/DoublePath").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx.CopyHeader(r.Header, header)
		return r, nil
	}
}

type doublePathHttpClientResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder doublePathHttpClientResponseDecoder) DoublePath() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if r.StatusCode != http.StatusOK {
			return nil, coder.DecodeErrorFromResponse(ctx, r)
		}
		resp := &emptypb.Empty{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}

func appendStringPathHttpRoutes(router *mux.Router) *mux.Router {
	router.NewRoute().
		Name("/leo.example.route.path.StringPath/StringPath").
		Methods(http.MethodGet).
		Path("/v1/{string}/{opt_string}/{wrap_string}")
	return router
}
func AppendStringPathHttpServerRoutes(router *mux.Router, svc StringPathService, opts ...httptransportx.ServerOption) *mux.Router {
	options := httptransportx.NewServerOptions(opts...)
	endpoints := &stringPathServerEndpoints{
		svc:         svc,
		middlewares: options.Middlewares(),
	}
	requestDecoder := stringPathHttpServerRequestDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	responseEncoder := stringPathHttpServerResponseEncoder{
		marshalOptions: options.MarshalOptions(),
	}
	transports := &stringPathHttpServerTransports{
		endpoints:       endpoints,
		requestDecoder:  requestDecoder,
		responseEncoder: responseEncoder,
	}
	router = appendStringPathHttpRoutes(router)
	router.Get("/leo.example.route.path.StringPath/StringPath").Handler(transports.StringPath())
	return router
}

func NewStringPathHttpClient(target string, opts ...httptransportx.ClientOption) StringPathService {
	options := httptransportx.NewClientOptions(opts...)
	requestEncoder := &stringPathHttpClientRequestEncoder{
		marshalOptions: options.MarshalOptions(),
		router:         appendStringPathHttpRoutes(mux.NewRouter()),
		scheme:         options.Scheme(),
	}
	responseDecoder := &stringPathHttpClientResponseDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	transports := &stringPathHttpClientTransports{
		clientOptions:   options.ClientTransportOptions(),
		middlewares:     options.Middlewares(),
		requestEncoder:  requestEncoder,
		responseDecoder: responseDecoder,
	}
	factories := &stringPathFactories{
		transports: transports,
	}
	endpointer := &stringPathEndpointers{
		target:    target,
		builder:   options.Builder(),
		factories: factories,
		logger:    options.Logger(),
		options:   options.EndpointerOptions(),
	}
	balancers := &stringPathBalancers{
		factory:    options.BalancerFactory(),
		endpointer: endpointer,
	}
	endpoints := &stringPathClientEndpoints{
		balancers: balancers,
	}
	return &stringPathClientService{
		endpoints:     endpoints,
		transportName: httptransportx.HttpClient,
	}
}

type StringPathHttpServerTransports interface {
	StringPath() http.Handler
}

type StringPathHttpServerRequestDecoder interface {
	StringPath() http1.DecodeRequestFunc
}

type StringPathHttpServerResponseEncoder interface {
	StringPath() http1.EncodeResponseFunc
}

type StringPathHttpClientRequestEncoder interface {
	StringPath(instance string) http1.CreateRequestFunc
}

type StringPathHttpClientResponseDecoder interface {
	StringPath() http1.DecodeResponseFunc
}

type stringPathHttpServerTransports struct {
	endpoints       StringPathServerEndpoints
	requestDecoder  StringPathHttpServerRequestDecoder
	responseEncoder StringPathHttpServerResponseEncoder
}

func (t *stringPathHttpServerTransports) StringPath() http.Handler {
	return http1.NewServer(
		t.endpoints.StringPath(context.TODO()),
		t.requestDecoder.StringPath(),
		t.responseEncoder.StringPath(),
		http1.ServerBefore(httptransportx.EndpointInjector("/leo.example.route.path.StringPath/StringPath")),
		http1.ServerBefore(httptransportx.ServerTransportInjector),
		http1.ServerBefore(metadatax.HttpIncomingInjector),
		http1.ServerBefore(timeoutx.IncomingInjector),
		http1.ServerBefore(stainx.HttpIncomingInjector),
		http1.ServerFinalizer(timeoutx.CancelInvoker),
		http1.ServerErrorEncoder(coder.EncodeErrorToResponse),
	)
}

type stringPathHttpServerRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder stringPathHttpServerRequestDecoder) StringPath() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &StringPathRequest{}
		vars := urlx.FormFromMap(mux.Vars(r))
		var varErr error
		req.String_ = vars.Get("string")
		req.OptString = proto.String(vars.Get("opt_string"))
		req.WrapString = wrapperspb.String(vars.Get("wrap_string"))
		if varErr != nil {
			return nil, varErr
		}
		return req, nil
	}
}

type stringPathHttpServerResponseEncoder struct {
	marshalOptions protojson.MarshalOptions
}

func (encoder stringPathHttpServerResponseEncoder) StringPath() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*emptypb.Empty)
		return coder.EncodeMessageToResponse(ctx, w, resp, encoder.marshalOptions)
	}
}

type stringPathHttpClientTransports struct {
	clientOptions   []http1.ClientOption
	middlewares     []endpoint.Middleware
	requestEncoder  StringPathHttpClientRequestEncoder
	responseDecoder StringPathHttpClientResponseDecoder
}

func (t *stringPathHttpClientTransports) StringPath(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(metadatax.HttpOutgoingInjector),
		http1.ClientBefore(timeoutx.OutgoingInjector),
		http1.ClientBefore(stainx.HttpOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.StringPath(instance),
		t.responseDecoder.StringPath(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

type stringPathHttpClientRequestEncoder struct {
	marshalOptions protojson.MarshalOptions
	router         *mux.Router
	scheme         string
}

func (encoder stringPathHttpClientRequestEncoder) StringPath(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*StringPathRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodGet
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		var pairs []string
		pairs = append(pairs,
			"string", req.GetString_(),
			"opt_string", req.GetOptString(),
			"wrap_string", req.GetWrapString().GetValue(),
		)
		path, err := encoder.router.Get("/leo.example.route.path.StringPath/StringPath").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx.CopyHeader(r.Header, header)
		return r, nil
	}
}

type stringPathHttpClientResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder stringPathHttpClientResponseDecoder) StringPath() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if r.StatusCode != http.StatusOK {
			return nil, coder.DecodeErrorFromResponse(ctx, r)
		}
		resp := &emptypb.Empty{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}

func appendEnumPathHttpRoutes(router *mux.Router) *mux.Router {
	router.NewRoute().
		Name("/leo.example.route.path.EnumPath/EnumPath").
		Methods(http.MethodGet).
		Path("/v1/{status}/{opt_status}")
	return router
}
func AppendEnumPathHttpServerRoutes(router *mux.Router, svc EnumPathService, opts ...httptransportx.ServerOption) *mux.Router {
	options := httptransportx.NewServerOptions(opts...)
	endpoints := &enumPathServerEndpoints{
		svc:         svc,
		middlewares: options.Middlewares(),
	}
	requestDecoder := enumPathHttpServerRequestDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	responseEncoder := enumPathHttpServerResponseEncoder{
		marshalOptions: options.MarshalOptions(),
	}
	transports := &enumPathHttpServerTransports{
		endpoints:       endpoints,
		requestDecoder:  requestDecoder,
		responseEncoder: responseEncoder,
	}
	router = appendEnumPathHttpRoutes(router)
	router.Get("/leo.example.route.path.EnumPath/EnumPath").Handler(transports.EnumPath())
	return router
}

func NewEnumPathHttpClient(target string, opts ...httptransportx.ClientOption) EnumPathService {
	options := httptransportx.NewClientOptions(opts...)
	requestEncoder := &enumPathHttpClientRequestEncoder{
		marshalOptions: options.MarshalOptions(),
		router:         appendEnumPathHttpRoutes(mux.NewRouter()),
		scheme:         options.Scheme(),
	}
	responseDecoder := &enumPathHttpClientResponseDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	transports := &enumPathHttpClientTransports{
		clientOptions:   options.ClientTransportOptions(),
		middlewares:     options.Middlewares(),
		requestEncoder:  requestEncoder,
		responseDecoder: responseDecoder,
	}
	factories := &enumPathFactories{
		transports: transports,
	}
	endpointer := &enumPathEndpointers{
		target:    target,
		builder:   options.Builder(),
		factories: factories,
		logger:    options.Logger(),
		options:   options.EndpointerOptions(),
	}
	balancers := &enumPathBalancers{
		factory:    options.BalancerFactory(),
		endpointer: endpointer,
	}
	endpoints := &enumPathClientEndpoints{
		balancers: balancers,
	}
	return &enumPathClientService{
		endpoints:     endpoints,
		transportName: httptransportx.HttpClient,
	}
}

type EnumPathHttpServerTransports interface {
	EnumPath() http.Handler
}

type EnumPathHttpServerRequestDecoder interface {
	EnumPath() http1.DecodeRequestFunc
}

type EnumPathHttpServerResponseEncoder interface {
	EnumPath() http1.EncodeResponseFunc
}

type EnumPathHttpClientRequestEncoder interface {
	EnumPath(instance string) http1.CreateRequestFunc
}

type EnumPathHttpClientResponseDecoder interface {
	EnumPath() http1.DecodeResponseFunc
}

type enumPathHttpServerTransports struct {
	endpoints       EnumPathServerEndpoints
	requestDecoder  EnumPathHttpServerRequestDecoder
	responseEncoder EnumPathHttpServerResponseEncoder
}

func (t *enumPathHttpServerTransports) EnumPath() http.Handler {
	return http1.NewServer(
		t.endpoints.EnumPath(context.TODO()),
		t.requestDecoder.EnumPath(),
		t.responseEncoder.EnumPath(),
		http1.ServerBefore(httptransportx.EndpointInjector("/leo.example.route.path.EnumPath/EnumPath")),
		http1.ServerBefore(httptransportx.ServerTransportInjector),
		http1.ServerBefore(metadatax.HttpIncomingInjector),
		http1.ServerBefore(timeoutx.IncomingInjector),
		http1.ServerBefore(stainx.HttpIncomingInjector),
		http1.ServerFinalizer(timeoutx.CancelInvoker),
		http1.ServerErrorEncoder(coder.EncodeErrorToResponse),
	)
}

type enumPathHttpServerRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder enumPathHttpServerRequestDecoder) EnumPath() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &EnumPathRequest{}
		vars := urlx.FormFromMap(mux.Vars(r))
		var varErr error
		req.Status, varErr = coder.DecodeForm[EnumPathRequest_Status](varErr, vars, "status", urlx.GetInt[EnumPathRequest_Status])
		req.OptStatus, varErr = coder.DecodeForm[*EnumPathRequest_Status](varErr, vars, "opt_status", urlx.GetIntPtr[EnumPathRequest_Status])
		if varErr != nil {
			return nil, varErr
		}
		return req, nil
	}
}

type enumPathHttpServerResponseEncoder struct {
	marshalOptions protojson.MarshalOptions
}

func (encoder enumPathHttpServerResponseEncoder) EnumPath() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*emptypb.Empty)
		return coder.EncodeMessageToResponse(ctx, w, resp, encoder.marshalOptions)
	}
}

type enumPathHttpClientTransports struct {
	clientOptions   []http1.ClientOption
	middlewares     []endpoint.Middleware
	requestEncoder  EnumPathHttpClientRequestEncoder
	responseDecoder EnumPathHttpClientResponseDecoder
}

func (t *enumPathHttpClientTransports) EnumPath(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(metadatax.HttpOutgoingInjector),
		http1.ClientBefore(timeoutx.OutgoingInjector),
		http1.ClientBefore(stainx.HttpOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.EnumPath(instance),
		t.responseDecoder.EnumPath(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

type enumPathHttpClientRequestEncoder struct {
	marshalOptions protojson.MarshalOptions
	router         *mux.Router
	scheme         string
}

func (encoder enumPathHttpClientRequestEncoder) EnumPath(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*EnumPathRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodGet
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		var pairs []string
		pairs = append(pairs,
			"status", strconvx.FormatInt(req.GetStatus(), 10),
			"opt_status", strconvx.FormatInt(req.GetOptStatus(), 10),
		)
		path, err := encoder.router.Get("/leo.example.route.path.EnumPath/EnumPath").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx.CopyHeader(r.Header, header)
		return r, nil
	}
}

type enumPathHttpClientResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder enumPathHttpClientResponseDecoder) EnumPath() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if r.StatusCode != http.StatusOK {
			return nil, coder.DecodeErrorFromResponse(ctx, r)
		}
		resp := &emptypb.Empty{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}

func appendNamedPathHttpRoutes(router *mux.Router) *mux.Router {
	router.NewRoute().
		Name("/leo.example.route.path.NamedPath/NamedPathString").
		Methods(http.MethodGet).
		Path("/v1/string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}")
	router.NewRoute().
		Name("/leo.example.route.path.NamedPath/NamedPathOptString").
		Methods(http.MethodGet).
		Path("/v1/opt_string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}")
	router.NewRoute().
		Name("/leo.example.route.path.NamedPath/NamedPathWrapString").
		Methods(http.MethodGet).
		Path("/v1/wrap_string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}")
	router.NewRoute().
		Name("/leo.example.route.path.NamedPath/EmbedNamedPathString").
		Methods(http.MethodGet).
		Path("/v1/embed/string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}")
	router.NewRoute().
		Name("/leo.example.route.path.NamedPath/EmbedNamedPathOptString").
		Methods(http.MethodGet).
		Path("/v1/embed/opt_string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}")
	router.NewRoute().
		Name("/leo.example.route.path.NamedPath/EmbedNamedPathWrapString").
		Methods(http.MethodGet).
		Path("/v1/embed/wrap_string/classes/{class}/shelves/{shelf}/books/{book}/families/{family}")
	return router
}
func AppendNamedPathHttpServerRoutes(router *mux.Router, svc NamedPathService, opts ...httptransportx.ServerOption) *mux.Router {
	options := httptransportx.NewServerOptions(opts...)
	endpoints := &namedPathServerEndpoints{
		svc:         svc,
		middlewares: options.Middlewares(),
	}
	requestDecoder := namedPathHttpServerRequestDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	responseEncoder := namedPathHttpServerResponseEncoder{
		marshalOptions: options.MarshalOptions(),
	}
	transports := &namedPathHttpServerTransports{
		endpoints:       endpoints,
		requestDecoder:  requestDecoder,
		responseEncoder: responseEncoder,
	}
	router = appendNamedPathHttpRoutes(router)
	router.Get("/leo.example.route.path.NamedPath/NamedPathString").Handler(transports.NamedPathString())
	router.Get("/leo.example.route.path.NamedPath/NamedPathOptString").Handler(transports.NamedPathOptString())
	router.Get("/leo.example.route.path.NamedPath/NamedPathWrapString").Handler(transports.NamedPathWrapString())
	router.Get("/leo.example.route.path.NamedPath/EmbedNamedPathString").Handler(transports.EmbedNamedPathString())
	router.Get("/leo.example.route.path.NamedPath/EmbedNamedPathOptString").Handler(transports.EmbedNamedPathOptString())
	router.Get("/leo.example.route.path.NamedPath/EmbedNamedPathWrapString").Handler(transports.EmbedNamedPathWrapString())
	return router
}

func NewNamedPathHttpClient(target string, opts ...httptransportx.ClientOption) NamedPathService {
	options := httptransportx.NewClientOptions(opts...)
	requestEncoder := &namedPathHttpClientRequestEncoder{
		marshalOptions: options.MarshalOptions(),
		router:         appendNamedPathHttpRoutes(mux.NewRouter()),
		scheme:         options.Scheme(),
	}
	responseDecoder := &namedPathHttpClientResponseDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	transports := &namedPathHttpClientTransports{
		clientOptions:   options.ClientTransportOptions(),
		middlewares:     options.Middlewares(),
		requestEncoder:  requestEncoder,
		responseDecoder: responseDecoder,
	}
	factories := &namedPathFactories{
		transports: transports,
	}
	endpointer := &namedPathEndpointers{
		target:    target,
		builder:   options.Builder(),
		factories: factories,
		logger:    options.Logger(),
		options:   options.EndpointerOptions(),
	}
	balancers := &namedPathBalancers{
		factory:    options.BalancerFactory(),
		endpointer: endpointer,
	}
	endpoints := &namedPathClientEndpoints{
		balancers: balancers,
	}
	return &namedPathClientService{
		endpoints:     endpoints,
		transportName: httptransportx.HttpClient,
	}
}

type NamedPathHttpServerTransports interface {
	NamedPathString() http.Handler
	NamedPathOptString() http.Handler
	NamedPathWrapString() http.Handler
	EmbedNamedPathString() http.Handler
	EmbedNamedPathOptString() http.Handler
	EmbedNamedPathWrapString() http.Handler
}

type NamedPathHttpServerRequestDecoder interface {
	NamedPathString() http1.DecodeRequestFunc
	NamedPathOptString() http1.DecodeRequestFunc
	NamedPathWrapString() http1.DecodeRequestFunc
	EmbedNamedPathString() http1.DecodeRequestFunc
	EmbedNamedPathOptString() http1.DecodeRequestFunc
	EmbedNamedPathWrapString() http1.DecodeRequestFunc
}

type NamedPathHttpServerResponseEncoder interface {
	NamedPathString() http1.EncodeResponseFunc
	NamedPathOptString() http1.EncodeResponseFunc
	NamedPathWrapString() http1.EncodeResponseFunc
	EmbedNamedPathString() http1.EncodeResponseFunc
	EmbedNamedPathOptString() http1.EncodeResponseFunc
	EmbedNamedPathWrapString() http1.EncodeResponseFunc
}

type NamedPathHttpClientRequestEncoder interface {
	NamedPathString(instance string) http1.CreateRequestFunc
	NamedPathOptString(instance string) http1.CreateRequestFunc
	NamedPathWrapString(instance string) http1.CreateRequestFunc
	EmbedNamedPathString(instance string) http1.CreateRequestFunc
	EmbedNamedPathOptString(instance string) http1.CreateRequestFunc
	EmbedNamedPathWrapString(instance string) http1.CreateRequestFunc
}

type NamedPathHttpClientResponseDecoder interface {
	NamedPathString() http1.DecodeResponseFunc
	NamedPathOptString() http1.DecodeResponseFunc
	NamedPathWrapString() http1.DecodeResponseFunc
	EmbedNamedPathString() http1.DecodeResponseFunc
	EmbedNamedPathOptString() http1.DecodeResponseFunc
	EmbedNamedPathWrapString() http1.DecodeResponseFunc
}

type namedPathHttpServerTransports struct {
	endpoints       NamedPathServerEndpoints
	requestDecoder  NamedPathHttpServerRequestDecoder
	responseEncoder NamedPathHttpServerResponseEncoder
}

func (t *namedPathHttpServerTransports) NamedPathString() http.Handler {
	return http1.NewServer(
		t.endpoints.NamedPathString(context.TODO()),
		t.requestDecoder.NamedPathString(),
		t.responseEncoder.NamedPathString(),
		http1.ServerBefore(httptransportx.EndpointInjector("/leo.example.route.path.NamedPath/NamedPathString")),
		http1.ServerBefore(httptransportx.ServerTransportInjector),
		http1.ServerBefore(metadatax.HttpIncomingInjector),
		http1.ServerBefore(timeoutx.IncomingInjector),
		http1.ServerBefore(stainx.HttpIncomingInjector),
		http1.ServerFinalizer(timeoutx.CancelInvoker),
		http1.ServerErrorEncoder(coder.EncodeErrorToResponse),
	)
}

func (t *namedPathHttpServerTransports) NamedPathOptString() http.Handler {
	return http1.NewServer(
		t.endpoints.NamedPathOptString(context.TODO()),
		t.requestDecoder.NamedPathOptString(),
		t.responseEncoder.NamedPathOptString(),
		http1.ServerBefore(httptransportx.EndpointInjector("/leo.example.route.path.NamedPath/NamedPathOptString")),
		http1.ServerBefore(httptransportx.ServerTransportInjector),
		http1.ServerBefore(metadatax.HttpIncomingInjector),
		http1.ServerBefore(timeoutx.IncomingInjector),
		http1.ServerBefore(stainx.HttpIncomingInjector),
		http1.ServerFinalizer(timeoutx.CancelInvoker),
		http1.ServerErrorEncoder(coder.EncodeErrorToResponse),
	)
}

func (t *namedPathHttpServerTransports) NamedPathWrapString() http.Handler {
	return http1.NewServer(
		t.endpoints.NamedPathWrapString(context.TODO()),
		t.requestDecoder.NamedPathWrapString(),
		t.responseEncoder.NamedPathWrapString(),
		http1.ServerBefore(httptransportx.EndpointInjector("/leo.example.route.path.NamedPath/NamedPathWrapString")),
		http1.ServerBefore(httptransportx.ServerTransportInjector),
		http1.ServerBefore(metadatax.HttpIncomingInjector),
		http1.ServerBefore(timeoutx.IncomingInjector),
		http1.ServerBefore(stainx.HttpIncomingInjector),
		http1.ServerFinalizer(timeoutx.CancelInvoker),
		http1.ServerErrorEncoder(coder.EncodeErrorToResponse),
	)
}

func (t *namedPathHttpServerTransports) EmbedNamedPathString() http.Handler {
	return http1.NewServer(
		t.endpoints.EmbedNamedPathString(context.TODO()),
		t.requestDecoder.EmbedNamedPathString(),
		t.responseEncoder.EmbedNamedPathString(),
		http1.ServerBefore(httptransportx.EndpointInjector("/leo.example.route.path.NamedPath/EmbedNamedPathString")),
		http1.ServerBefore(httptransportx.ServerTransportInjector),
		http1.ServerBefore(metadatax.HttpIncomingInjector),
		http1.ServerBefore(timeoutx.IncomingInjector),
		http1.ServerBefore(stainx.HttpIncomingInjector),
		http1.ServerFinalizer(timeoutx.CancelInvoker),
		http1.ServerErrorEncoder(coder.EncodeErrorToResponse),
	)
}

func (t *namedPathHttpServerTransports) EmbedNamedPathOptString() http.Handler {
	return http1.NewServer(
		t.endpoints.EmbedNamedPathOptString(context.TODO()),
		t.requestDecoder.EmbedNamedPathOptString(),
		t.responseEncoder.EmbedNamedPathOptString(),
		http1.ServerBefore(httptransportx.EndpointInjector("/leo.example.route.path.NamedPath/EmbedNamedPathOptString")),
		http1.ServerBefore(httptransportx.ServerTransportInjector),
		http1.ServerBefore(metadatax.HttpIncomingInjector),
		http1.ServerBefore(timeoutx.IncomingInjector),
		http1.ServerBefore(stainx.HttpIncomingInjector),
		http1.ServerFinalizer(timeoutx.CancelInvoker),
		http1.ServerErrorEncoder(coder.EncodeErrorToResponse),
	)
}

func (t *namedPathHttpServerTransports) EmbedNamedPathWrapString() http.Handler {
	return http1.NewServer(
		t.endpoints.EmbedNamedPathWrapString(context.TODO()),
		t.requestDecoder.EmbedNamedPathWrapString(),
		t.responseEncoder.EmbedNamedPathWrapString(),
		http1.ServerBefore(httptransportx.EndpointInjector("/leo.example.route.path.NamedPath/EmbedNamedPathWrapString")),
		http1.ServerBefore(httptransportx.ServerTransportInjector),
		http1.ServerBefore(metadatax.HttpIncomingInjector),
		http1.ServerBefore(timeoutx.IncomingInjector),
		http1.ServerBefore(stainx.HttpIncomingInjector),
		http1.ServerFinalizer(timeoutx.CancelInvoker),
		http1.ServerErrorEncoder(coder.EncodeErrorToResponse),
	)
}

type namedPathHttpServerRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder namedPathHttpServerRequestDecoder) NamedPathString() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &NamedPathRequest{}
		vars := urlx.FormFromMap(mux.Vars(r))
		req.String_ = fmt.Sprintf("classes/%s/shelves/%s/books/%s/families/%s", vars.Get("class"), vars.Get("shelf"), vars.Get("book"), vars.Get("family"))
		queries := r.URL.Query()
		var queryErr error
		req.OptString = proto.String(queries.Get("opt_string"))
		req.WrapString = wrapperspb.String(queries.Get("wrap_string"))
		if queryErr != nil {
			return nil, queryErr
		}
		return req, nil
	}
}
func (decoder namedPathHttpServerRequestDecoder) NamedPathOptString() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &NamedPathRequest{}
		vars := urlx.FormFromMap(mux.Vars(r))
		req.OptString = proto.String(fmt.Sprintf("classes/%s/shelves/%s/books/%s/families/%s", vars.Get("class"), vars.Get("shelf"), vars.Get("book"), vars.Get("family")))
		queries := r.URL.Query()
		var queryErr error
		req.String_ = queries.Get("string")
		req.WrapString = wrapperspb.String(queries.Get("wrap_string"))
		if queryErr != nil {
			return nil, queryErr
		}
		return req, nil
	}
}
func (decoder namedPathHttpServerRequestDecoder) NamedPathWrapString() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &NamedPathRequest{}
		vars := urlx.FormFromMap(mux.Vars(r))
		req.WrapString = wrapperspb.String(fmt.Sprintf("classes/%s/shelves/%s/books/%s/families/%s", vars.Get("class"), vars.Get("shelf"), vars.Get("book"), vars.Get("family")))
		queries := r.URL.Query()
		var queryErr error
		req.String_ = queries.Get("string")
		req.OptString = proto.String(queries.Get("opt_string"))
		if queryErr != nil {
			return nil, queryErr
		}
		return req, nil
	}
}
func (decoder namedPathHttpServerRequestDecoder) EmbedNamedPathString() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &EmbedNamedPathRequest{}
		vars := urlx.FormFromMap(mux.Vars(r))
		if req.Embed == nil {
			req.Embed = &NamedPathRequest{}
		}
		req.Embed.String_ = fmt.Sprintf("classes/%s/shelves/%s/books/%s/families/%s", vars.Get("class"), vars.Get("shelf"), vars.Get("book"), vars.Get("family"))
		return req, nil
	}
}
func (decoder namedPathHttpServerRequestDecoder) EmbedNamedPathOptString() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &EmbedNamedPathRequest{}
		vars := urlx.FormFromMap(mux.Vars(r))
		if req.Embed == nil {
			req.Embed = &NamedPathRequest{}
		}
		req.Embed.OptString = proto.String(fmt.Sprintf("classes/%s/shelves/%s/books/%s/families/%s", vars.Get("class"), vars.Get("shelf"), vars.Get("book"), vars.Get("family")))
		return req, nil
	}
}
func (decoder namedPathHttpServerRequestDecoder) EmbedNamedPathWrapString() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &EmbedNamedPathRequest{}
		vars := urlx.FormFromMap(mux.Vars(r))
		if req.Embed == nil {
			req.Embed = &NamedPathRequest{}
		}
		req.Embed.WrapString = wrapperspb.String(fmt.Sprintf("classes/%s/shelves/%s/books/%s/families/%s", vars.Get("class"), vars.Get("shelf"), vars.Get("book"), vars.Get("family")))
		return req, nil
	}
}

type namedPathHttpServerResponseEncoder struct {
	marshalOptions protojson.MarshalOptions
}

func (encoder namedPathHttpServerResponseEncoder) NamedPathString() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*emptypb.Empty)
		return coder.EncodeMessageToResponse(ctx, w, resp, encoder.marshalOptions)
	}
}
func (encoder namedPathHttpServerResponseEncoder) NamedPathOptString() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*emptypb.Empty)
		return coder.EncodeMessageToResponse(ctx, w, resp, encoder.marshalOptions)
	}
}
func (encoder namedPathHttpServerResponseEncoder) NamedPathWrapString() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*emptypb.Empty)
		return coder.EncodeMessageToResponse(ctx, w, resp, encoder.marshalOptions)
	}
}
func (encoder namedPathHttpServerResponseEncoder) EmbedNamedPathString() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*emptypb.Empty)
		return coder.EncodeMessageToResponse(ctx, w, resp, encoder.marshalOptions)
	}
}
func (encoder namedPathHttpServerResponseEncoder) EmbedNamedPathOptString() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*emptypb.Empty)
		return coder.EncodeMessageToResponse(ctx, w, resp, encoder.marshalOptions)
	}
}
func (encoder namedPathHttpServerResponseEncoder) EmbedNamedPathWrapString() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*emptypb.Empty)
		return coder.EncodeMessageToResponse(ctx, w, resp, encoder.marshalOptions)
	}
}

type namedPathHttpClientTransports struct {
	clientOptions   []http1.ClientOption
	middlewares     []endpoint.Middleware
	requestEncoder  NamedPathHttpClientRequestEncoder
	responseDecoder NamedPathHttpClientResponseDecoder
}

func (t *namedPathHttpClientTransports) NamedPathString(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(metadatax.HttpOutgoingInjector),
		http1.ClientBefore(timeoutx.OutgoingInjector),
		http1.ClientBefore(stainx.HttpOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.NamedPathString(instance),
		t.responseDecoder.NamedPathString(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func (t *namedPathHttpClientTransports) NamedPathOptString(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(metadatax.HttpOutgoingInjector),
		http1.ClientBefore(timeoutx.OutgoingInjector),
		http1.ClientBefore(stainx.HttpOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.NamedPathOptString(instance),
		t.responseDecoder.NamedPathOptString(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func (t *namedPathHttpClientTransports) NamedPathWrapString(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(metadatax.HttpOutgoingInjector),
		http1.ClientBefore(timeoutx.OutgoingInjector),
		http1.ClientBefore(stainx.HttpOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.NamedPathWrapString(instance),
		t.responseDecoder.NamedPathWrapString(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func (t *namedPathHttpClientTransports) EmbedNamedPathString(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(metadatax.HttpOutgoingInjector),
		http1.ClientBefore(timeoutx.OutgoingInjector),
		http1.ClientBefore(stainx.HttpOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.EmbedNamedPathString(instance),
		t.responseDecoder.EmbedNamedPathString(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func (t *namedPathHttpClientTransports) EmbedNamedPathOptString(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(metadatax.HttpOutgoingInjector),
		http1.ClientBefore(timeoutx.OutgoingInjector),
		http1.ClientBefore(stainx.HttpOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.EmbedNamedPathOptString(instance),
		t.responseDecoder.EmbedNamedPathOptString(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

func (t *namedPathHttpClientTransports) EmbedNamedPathWrapString(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(metadatax.HttpOutgoingInjector),
		http1.ClientBefore(timeoutx.OutgoingInjector),
		http1.ClientBefore(stainx.HttpOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.EmbedNamedPathWrapString(instance),
		t.responseDecoder.EmbedNamedPathWrapString(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

type namedPathHttpClientRequestEncoder struct {
	marshalOptions protojson.MarshalOptions
	router         *mux.Router
	scheme         string
}

func (encoder namedPathHttpClientRequestEncoder) NamedPathString(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*NamedPathRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodGet
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		var pairs []string
		namedPathParameter := req.GetString_()
		namedPathValues := strings.Split(namedPathParameter, "/")
		if len(namedPathValues) != 8 {
			return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
		}
		pairs = append(pairs,
			"class", namedPathValues[1],
			"shelf", namedPathValues[3],
			"book", namedPathValues[5],
			"family", namedPathValues[7],
		)
		path, err := encoder.router.Get("/leo.example.route.path.NamedPath/NamedPathString").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		queries := url.Values{}
		queries["opt_string"] = append(queries["opt_string"], req.GetOptString())
		queries["wrap_string"] = append(queries["wrap_string"], req.GetWrapString().GetValue())
		target.RawQuery = queries.Encode()
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx.CopyHeader(r.Header, header)
		return r, nil
	}
}
func (encoder namedPathHttpClientRequestEncoder) NamedPathOptString(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*NamedPathRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodGet
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		var pairs []string
		namedPathParameter := req.GetOptString()
		namedPathValues := strings.Split(namedPathParameter, "/")
		if len(namedPathValues) != 8 {
			return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
		}
		pairs = append(pairs,
			"class", namedPathValues[1],
			"shelf", namedPathValues[3],
			"book", namedPathValues[5],
			"family", namedPathValues[7],
		)
		path, err := encoder.router.Get("/leo.example.route.path.NamedPath/NamedPathOptString").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		queries := url.Values{}
		queries["string"] = append(queries["string"], req.GetString_())
		queries["wrap_string"] = append(queries["wrap_string"], req.GetWrapString().GetValue())
		target.RawQuery = queries.Encode()
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx.CopyHeader(r.Header, header)
		return r, nil
	}
}
func (encoder namedPathHttpClientRequestEncoder) NamedPathWrapString(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*NamedPathRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodGet
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		var pairs []string
		namedPathParameter := req.GetWrapString().GetValue()
		namedPathValues := strings.Split(namedPathParameter, "/")
		if len(namedPathValues) != 8 {
			return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
		}
		pairs = append(pairs,
			"class", namedPathValues[1],
			"shelf", namedPathValues[3],
			"book", namedPathValues[5],
			"family", namedPathValues[7],
		)
		path, err := encoder.router.Get("/leo.example.route.path.NamedPath/NamedPathWrapString").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		queries := url.Values{}
		queries["string"] = append(queries["string"], req.GetString_())
		queries["opt_string"] = append(queries["opt_string"], req.GetOptString())
		target.RawQuery = queries.Encode()
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx.CopyHeader(r.Header, header)
		return r, nil
	}
}
func (encoder namedPathHttpClientRequestEncoder) EmbedNamedPathString(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*EmbedNamedPathRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodGet
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		var pairs []string
		namedPathParameter := req.GetEmbed().GetString_()
		namedPathValues := strings.Split(namedPathParameter, "/")
		if len(namedPathValues) != 8 {
			return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
		}
		pairs = append(pairs,
			"class", namedPathValues[1],
			"shelf", namedPathValues[3],
			"book", namedPathValues[5],
			"family", namedPathValues[7],
		)
		path, err := encoder.router.Get("/leo.example.route.path.NamedPath/EmbedNamedPathString").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx.CopyHeader(r.Header, header)
		return r, nil
	}
}
func (encoder namedPathHttpClientRequestEncoder) EmbedNamedPathOptString(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*EmbedNamedPathRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodGet
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		var pairs []string
		namedPathParameter := req.GetEmbed().GetOptString()
		namedPathValues := strings.Split(namedPathParameter, "/")
		if len(namedPathValues) != 8 {
			return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
		}
		pairs = append(pairs,
			"class", namedPathValues[1],
			"shelf", namedPathValues[3],
			"book", namedPathValues[5],
			"family", namedPathValues[7],
		)
		path, err := encoder.router.Get("/leo.example.route.path.NamedPath/EmbedNamedPathOptString").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx.CopyHeader(r.Header, header)
		return r, nil
	}
}
func (encoder namedPathHttpClientRequestEncoder) EmbedNamedPathWrapString(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*EmbedNamedPathRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodGet
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		var pairs []string
		namedPathParameter := req.GetEmbed().GetWrapString().GetValue()
		namedPathValues := strings.Split(namedPathParameter, "/")
		if len(namedPathValues) != 8 {
			return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
		}
		pairs = append(pairs,
			"class", namedPathValues[1],
			"shelf", namedPathValues[3],
			"book", namedPathValues[5],
			"family", namedPathValues[7],
		)
		path, err := encoder.router.Get("/leo.example.route.path.NamedPath/EmbedNamedPathWrapString").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx.CopyHeader(r.Header, header)
		return r, nil
	}
}

type namedPathHttpClientResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder namedPathHttpClientResponseDecoder) NamedPathString() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if r.StatusCode != http.StatusOK {
			return nil, coder.DecodeErrorFromResponse(ctx, r)
		}
		resp := &emptypb.Empty{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}
func (decoder namedPathHttpClientResponseDecoder) NamedPathOptString() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if r.StatusCode != http.StatusOK {
			return nil, coder.DecodeErrorFromResponse(ctx, r)
		}
		resp := &emptypb.Empty{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}
func (decoder namedPathHttpClientResponseDecoder) NamedPathWrapString() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if r.StatusCode != http.StatusOK {
			return nil, coder.DecodeErrorFromResponse(ctx, r)
		}
		resp := &emptypb.Empty{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}
func (decoder namedPathHttpClientResponseDecoder) EmbedNamedPathString() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if r.StatusCode != http.StatusOK {
			return nil, coder.DecodeErrorFromResponse(ctx, r)
		}
		resp := &emptypb.Empty{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}
func (decoder namedPathHttpClientResponseDecoder) EmbedNamedPathOptString() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if r.StatusCode != http.StatusOK {
			return nil, coder.DecodeErrorFromResponse(ctx, r)
		}
		resp := &emptypb.Empty{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}
func (decoder namedPathHttpClientResponseDecoder) EmbedNamedPathWrapString() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if r.StatusCode != http.StatusOK {
			return nil, coder.DecodeErrorFromResponse(ctx, r)
		}
		resp := &emptypb.Empty{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}

func appendMixPathHttpRoutes(router *mux.Router) *mux.Router {
	router.NewRoute().
		Name("/leo.example.route.path.MixPath/MixPath").
		Methods(http.MethodGet).
		Path("/v1/{string}/{opt_string}/{wrap_string}/classes/{class}/shelves/{shelf}/books/{book}/families/{family}")
	return router
}
func AppendMixPathHttpServerRoutes(router *mux.Router, svc MixPathService, opts ...httptransportx.ServerOption) *mux.Router {
	options := httptransportx.NewServerOptions(opts...)
	endpoints := &mixPathServerEndpoints{
		svc:         svc,
		middlewares: options.Middlewares(),
	}
	requestDecoder := mixPathHttpServerRequestDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	responseEncoder := mixPathHttpServerResponseEncoder{
		marshalOptions: options.MarshalOptions(),
	}
	transports := &mixPathHttpServerTransports{
		endpoints:       endpoints,
		requestDecoder:  requestDecoder,
		responseEncoder: responseEncoder,
	}
	router = appendMixPathHttpRoutes(router)
	router.Get("/leo.example.route.path.MixPath/MixPath").Handler(transports.MixPath())
	return router
}

func NewMixPathHttpClient(target string, opts ...httptransportx.ClientOption) MixPathService {
	options := httptransportx.NewClientOptions(opts...)
	requestEncoder := &mixPathHttpClientRequestEncoder{
		marshalOptions: options.MarshalOptions(),
		router:         appendMixPathHttpRoutes(mux.NewRouter()),
		scheme:         options.Scheme(),
	}
	responseDecoder := &mixPathHttpClientResponseDecoder{
		unmarshalOptions: options.UnmarshalOptions(),
	}
	transports := &mixPathHttpClientTransports{
		clientOptions:   options.ClientTransportOptions(),
		middlewares:     options.Middlewares(),
		requestEncoder:  requestEncoder,
		responseDecoder: responseDecoder,
	}
	factories := &mixPathFactories{
		transports: transports,
	}
	endpointer := &mixPathEndpointers{
		target:    target,
		builder:   options.Builder(),
		factories: factories,
		logger:    options.Logger(),
		options:   options.EndpointerOptions(),
	}
	balancers := &mixPathBalancers{
		factory:    options.BalancerFactory(),
		endpointer: endpointer,
	}
	endpoints := &mixPathClientEndpoints{
		balancers: balancers,
	}
	return &mixPathClientService{
		endpoints:     endpoints,
		transportName: httptransportx.HttpClient,
	}
}

type MixPathHttpServerTransports interface {
	MixPath() http.Handler
}

type MixPathHttpServerRequestDecoder interface {
	MixPath() http1.DecodeRequestFunc
}

type MixPathHttpServerResponseEncoder interface {
	MixPath() http1.EncodeResponseFunc
}

type MixPathHttpClientRequestEncoder interface {
	MixPath(instance string) http1.CreateRequestFunc
}

type MixPathHttpClientResponseDecoder interface {
	MixPath() http1.DecodeResponseFunc
}

type mixPathHttpServerTransports struct {
	endpoints       MixPathServerEndpoints
	requestDecoder  MixPathHttpServerRequestDecoder
	responseEncoder MixPathHttpServerResponseEncoder
}

func (t *mixPathHttpServerTransports) MixPath() http.Handler {
	return http1.NewServer(
		t.endpoints.MixPath(context.TODO()),
		t.requestDecoder.MixPath(),
		t.responseEncoder.MixPath(),
		http1.ServerBefore(httptransportx.EndpointInjector("/leo.example.route.path.MixPath/MixPath")),
		http1.ServerBefore(httptransportx.ServerTransportInjector),
		http1.ServerBefore(metadatax.HttpIncomingInjector),
		http1.ServerBefore(timeoutx.IncomingInjector),
		http1.ServerBefore(stainx.HttpIncomingInjector),
		http1.ServerFinalizer(timeoutx.CancelInvoker),
		http1.ServerErrorEncoder(coder.EncodeErrorToResponse),
	)
}

type mixPathHttpServerRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder mixPathHttpServerRequestDecoder) MixPath() http1.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (any, error) {
		req := &MixPathRequest{}
		vars := urlx.FormFromMap(mux.Vars(r))
		if req.Embed == nil {
			req.Embed = &NamedPathRequest{}
		}
		req.Embed.WrapString = wrapperspb.String(fmt.Sprintf("classes/%s/shelves/%s/books/%s/families/%s", vars.Get("class"), vars.Get("shelf"), vars.Get("book"), vars.Get("family")))
		var varErr error
		req.String_ = vars.Get("string")
		req.OptString = proto.String(vars.Get("opt_string"))
		req.WrapString = wrapperspb.String(vars.Get("wrap_string"))
		if varErr != nil {
			return nil, varErr
		}
		return req, nil
	}
}

type mixPathHttpServerResponseEncoder struct {
	marshalOptions protojson.MarshalOptions
}

func (encoder mixPathHttpServerResponseEncoder) MixPath() http1.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, obj any) error {
		resp := obj.(*emptypb.Empty)
		return coder.EncodeMessageToResponse(ctx, w, resp, encoder.marshalOptions)
	}
}

type mixPathHttpClientTransports struct {
	clientOptions   []http1.ClientOption
	middlewares     []endpoint.Middleware
	requestEncoder  MixPathHttpClientRequestEncoder
	responseDecoder MixPathHttpClientResponseDecoder
}

func (t *mixPathHttpClientTransports) MixPath(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	opts := []http1.ClientOption{
		http1.ClientBefore(metadatax.HttpOutgoingInjector),
		http1.ClientBefore(timeoutx.OutgoingInjector),
		http1.ClientBefore(stainx.HttpOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := http1.NewExplicitClient(
		t.requestEncoder.MixPath(instance),
		t.responseDecoder.MixPath(),
		opts...,
	)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), nil, nil
}

type mixPathHttpClientRequestEncoder struct {
	marshalOptions protojson.MarshalOptions
	router         *mux.Router
	scheme         string
}

func (encoder mixPathHttpClientRequestEncoder) MixPath(instance string) http1.CreateRequestFunc {
	return func(ctx context.Context, obj any) (*http.Request, error) {
		if obj == nil {
			return nil, errors.New("request is nil")
		}
		req, ok := obj.(*MixPathRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type, %T", obj)
		}
		_ = req
		method := http.MethodGet
		target := &url.URL{
			Scheme: encoder.scheme,
			Host:   instance,
		}
		header := http.Header{}
		var body bytes.Buffer
		var pairs []string
		namedPathParameter := req.GetEmbed().GetWrapString().GetValue()
		namedPathValues := strings.Split(namedPathParameter, "/")
		if len(namedPathValues) != 8 {
			return nil, fmt.Errorf("invalid named path parameter, %s", namedPathParameter)
		}
		pairs = append(pairs,
			"class", namedPathValues[1],
			"shelf", namedPathValues[3],
			"book", namedPathValues[5],
			"family", namedPathValues[7],
		)
		pairs = append(pairs,
			"string", req.GetString_(),
			"opt_string", req.GetOptString(),
			"wrap_string", req.GetWrapString().GetValue(),
		)
		path, err := encoder.router.Get("/leo.example.route.path.MixPath/MixPath").URLPath(pairs...)
		if err != nil {
			return nil, err
		}
		target.Path = path.Path
		r, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
		if err != nil {
			return nil, err
		}
		httpx.CopyHeader(r.Header, header)
		return r, nil
	}
}

type mixPathHttpClientResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder mixPathHttpClientResponseDecoder) MixPath() http1.DecodeResponseFunc {
	return func(ctx context.Context, r *http.Response) (any, error) {
		if r.StatusCode != http.StatusOK {
			return nil, coder.DecodeErrorFromResponse(ctx, r)
		}
		resp := &emptypb.Empty{}
		if err := coder.DecodeMessageFromResponse(ctx, r, resp, decoder.unmarshalOptions); err != nil {
			return nil, err
		}
		return resp, nil
	}
}
