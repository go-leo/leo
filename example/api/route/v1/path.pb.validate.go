// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: route/v1/path.proto

package route

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on BoolPathRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *BoolPathRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BoolPathRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BoolPathRequestMultiError, or nil if none found.
func (m *BoolPathRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BoolPathRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Bool

	if all {
		switch v := interface{}(m.GetWrapBool()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BoolPathRequestValidationError{
					field:  "WrapBool",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BoolPathRequestValidationError{
					field:  "WrapBool",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWrapBool()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BoolPathRequestValidationError{
				field:  "WrapBool",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.OptBool != nil {
		// no validation rules for OptBool
	}

	if len(errors) > 0 {
		return BoolPathRequestMultiError(errors)
	}

	return nil
}

// BoolPathRequestMultiError is an error wrapping multiple validation errors
// returned by BoolPathRequest.ValidateAll() if the designated constraints
// aren't met.
type BoolPathRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BoolPathRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BoolPathRequestMultiError) AllErrors() []error { return m }

// BoolPathRequestValidationError is the validation error returned by
// BoolPathRequest.Validate if the designated constraints aren't met.
type BoolPathRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BoolPathRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BoolPathRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BoolPathRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BoolPathRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BoolPathRequestValidationError) ErrorName() string { return "BoolPathRequestValidationError" }

// Error satisfies the builtin error interface
func (e BoolPathRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBoolPathRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BoolPathRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BoolPathRequestValidationError{}

// Validate checks the field values on Int32PathRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Int32PathRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Int32PathRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Int32PathRequestMultiError, or nil if none found.
func (m *Int32PathRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *Int32PathRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Int32

	// no validation rules for Sint32

	// no validation rules for Sfixed32

	if all {
		switch v := interface{}(m.GetWrapInt32()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Int32PathRequestValidationError{
					field:  "WrapInt32",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Int32PathRequestValidationError{
					field:  "WrapInt32",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWrapInt32()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Int32PathRequestValidationError{
				field:  "WrapInt32",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.OptInt32 != nil {
		// no validation rules for OptInt32
	}

	if m.OptSint32 != nil {
		// no validation rules for OptSint32
	}

	if m.OptSfixed32 != nil {
		// no validation rules for OptSfixed32
	}

	if len(errors) > 0 {
		return Int32PathRequestMultiError(errors)
	}

	return nil
}

// Int32PathRequestMultiError is an error wrapping multiple validation errors
// returned by Int32PathRequest.ValidateAll() if the designated constraints
// aren't met.
type Int32PathRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Int32PathRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Int32PathRequestMultiError) AllErrors() []error { return m }

// Int32PathRequestValidationError is the validation error returned by
// Int32PathRequest.Validate if the designated constraints aren't met.
type Int32PathRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Int32PathRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Int32PathRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Int32PathRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Int32PathRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Int32PathRequestValidationError) ErrorName() string { return "Int32PathRequestValidationError" }

// Error satisfies the builtin error interface
func (e Int32PathRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInt32PathRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Int32PathRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Int32PathRequestValidationError{}

// Validate checks the field values on Int64PathRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Int64PathRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Int64PathRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Int64PathRequestMultiError, or nil if none found.
func (m *Int64PathRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *Int64PathRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Int64

	// no validation rules for Sint64

	// no validation rules for Sfixed64

	if all {
		switch v := interface{}(m.GetWrapInt64()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Int64PathRequestValidationError{
					field:  "WrapInt64",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Int64PathRequestValidationError{
					field:  "WrapInt64",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWrapInt64()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Int64PathRequestValidationError{
				field:  "WrapInt64",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.OptInt64 != nil {
		// no validation rules for OptInt64
	}

	if m.OptSint64 != nil {
		// no validation rules for OptSint64
	}

	if m.OptSfixed64 != nil {
		// no validation rules for OptSfixed64
	}

	if len(errors) > 0 {
		return Int64PathRequestMultiError(errors)
	}

	return nil
}

// Int64PathRequestMultiError is an error wrapping multiple validation errors
// returned by Int64PathRequest.ValidateAll() if the designated constraints
// aren't met.
type Int64PathRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Int64PathRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Int64PathRequestMultiError) AllErrors() []error { return m }

// Int64PathRequestValidationError is the validation error returned by
// Int64PathRequest.Validate if the designated constraints aren't met.
type Int64PathRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Int64PathRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Int64PathRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Int64PathRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Int64PathRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Int64PathRequestValidationError) ErrorName() string { return "Int64PathRequestValidationError" }

// Error satisfies the builtin error interface
func (e Int64PathRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInt64PathRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Int64PathRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Int64PathRequestValidationError{}

// Validate checks the field values on Uint32PathRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Uint32PathRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Uint32PathRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Uint32PathRequestMultiError, or nil if none found.
func (m *Uint32PathRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *Uint32PathRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uint32

	// no validation rules for Fixed32

	if all {
		switch v := interface{}(m.GetWrapUint32()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Uint32PathRequestValidationError{
					field:  "WrapUint32",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Uint32PathRequestValidationError{
					field:  "WrapUint32",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWrapUint32()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Uint32PathRequestValidationError{
				field:  "WrapUint32",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.OptUint32 != nil {
		// no validation rules for OptUint32
	}

	if m.OptFixed32 != nil {
		// no validation rules for OptFixed32
	}

	if len(errors) > 0 {
		return Uint32PathRequestMultiError(errors)
	}

	return nil
}

// Uint32PathRequestMultiError is an error wrapping multiple validation errors
// returned by Uint32PathRequest.ValidateAll() if the designated constraints
// aren't met.
type Uint32PathRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Uint32PathRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Uint32PathRequestMultiError) AllErrors() []error { return m }

// Uint32PathRequestValidationError is the validation error returned by
// Uint32PathRequest.Validate if the designated constraints aren't met.
type Uint32PathRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Uint32PathRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Uint32PathRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Uint32PathRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Uint32PathRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Uint32PathRequestValidationError) ErrorName() string {
	return "Uint32PathRequestValidationError"
}

// Error satisfies the builtin error interface
func (e Uint32PathRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUint32PathRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Uint32PathRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Uint32PathRequestValidationError{}

// Validate checks the field values on Uint64PathRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Uint64PathRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Uint64PathRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Uint64PathRequestMultiError, or nil if none found.
func (m *Uint64PathRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *Uint64PathRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uint64

	// no validation rules for Fixed64

	if all {
		switch v := interface{}(m.GetWrapUint64()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Uint64PathRequestValidationError{
					field:  "WrapUint64",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Uint64PathRequestValidationError{
					field:  "WrapUint64",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWrapUint64()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Uint64PathRequestValidationError{
				field:  "WrapUint64",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.OptUint64 != nil {
		// no validation rules for OptUint64
	}

	if m.OptFixed64 != nil {
		// no validation rules for OptFixed64
	}

	if len(errors) > 0 {
		return Uint64PathRequestMultiError(errors)
	}

	return nil
}

// Uint64PathRequestMultiError is an error wrapping multiple validation errors
// returned by Uint64PathRequest.ValidateAll() if the designated constraints
// aren't met.
type Uint64PathRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Uint64PathRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Uint64PathRequestMultiError) AllErrors() []error { return m }

// Uint64PathRequestValidationError is the validation error returned by
// Uint64PathRequest.Validate if the designated constraints aren't met.
type Uint64PathRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Uint64PathRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Uint64PathRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Uint64PathRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Uint64PathRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Uint64PathRequestValidationError) ErrorName() string {
	return "Uint64PathRequestValidationError"
}

// Error satisfies the builtin error interface
func (e Uint64PathRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUint64PathRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Uint64PathRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Uint64PathRequestValidationError{}

// Validate checks the field values on FloatPathRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *FloatPathRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FloatPathRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FloatPathRequestMultiError, or nil if none found.
func (m *FloatPathRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FloatPathRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Float

	if all {
		switch v := interface{}(m.GetWrapFloat()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FloatPathRequestValidationError{
					field:  "WrapFloat",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FloatPathRequestValidationError{
					field:  "WrapFloat",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWrapFloat()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FloatPathRequestValidationError{
				field:  "WrapFloat",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.OptFloat != nil {
		// no validation rules for OptFloat
	}

	if len(errors) > 0 {
		return FloatPathRequestMultiError(errors)
	}

	return nil
}

// FloatPathRequestMultiError is an error wrapping multiple validation errors
// returned by FloatPathRequest.ValidateAll() if the designated constraints
// aren't met.
type FloatPathRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FloatPathRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FloatPathRequestMultiError) AllErrors() []error { return m }

// FloatPathRequestValidationError is the validation error returned by
// FloatPathRequest.Validate if the designated constraints aren't met.
type FloatPathRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FloatPathRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FloatPathRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FloatPathRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FloatPathRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FloatPathRequestValidationError) ErrorName() string { return "FloatPathRequestValidationError" }

// Error satisfies the builtin error interface
func (e FloatPathRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFloatPathRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FloatPathRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FloatPathRequestValidationError{}

// Validate checks the field values on DoublePathRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DoublePathRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DoublePathRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DoublePathRequestMultiError, or nil if none found.
func (m *DoublePathRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DoublePathRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Double

	if all {
		switch v := interface{}(m.GetWrapDouble()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DoublePathRequestValidationError{
					field:  "WrapDouble",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DoublePathRequestValidationError{
					field:  "WrapDouble",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWrapDouble()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DoublePathRequestValidationError{
				field:  "WrapDouble",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.OptDouble != nil {
		// no validation rules for OptDouble
	}

	if len(errors) > 0 {
		return DoublePathRequestMultiError(errors)
	}

	return nil
}

// DoublePathRequestMultiError is an error wrapping multiple validation errors
// returned by DoublePathRequest.ValidateAll() if the designated constraints
// aren't met.
type DoublePathRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DoublePathRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DoublePathRequestMultiError) AllErrors() []error { return m }

// DoublePathRequestValidationError is the validation error returned by
// DoublePathRequest.Validate if the designated constraints aren't met.
type DoublePathRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DoublePathRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DoublePathRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DoublePathRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DoublePathRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DoublePathRequestValidationError) ErrorName() string {
	return "DoublePathRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DoublePathRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDoublePathRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DoublePathRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DoublePathRequestValidationError{}

// Validate checks the field values on StringPathRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *StringPathRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StringPathRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StringPathRequestMultiError, or nil if none found.
func (m *StringPathRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StringPathRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for String_

	if all {
		switch v := interface{}(m.GetWrapString()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StringPathRequestValidationError{
					field:  "WrapString",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StringPathRequestValidationError{
					field:  "WrapString",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWrapString()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StringPathRequestValidationError{
				field:  "WrapString",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.OptString != nil {
		// no validation rules for OptString
	}

	if len(errors) > 0 {
		return StringPathRequestMultiError(errors)
	}

	return nil
}

// StringPathRequestMultiError is an error wrapping multiple validation errors
// returned by StringPathRequest.ValidateAll() if the designated constraints
// aren't met.
type StringPathRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StringPathRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StringPathRequestMultiError) AllErrors() []error { return m }

// StringPathRequestValidationError is the validation error returned by
// StringPathRequest.Validate if the designated constraints aren't met.
type StringPathRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringPathRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringPathRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringPathRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringPathRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringPathRequestValidationError) ErrorName() string {
	return "StringPathRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StringPathRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringPathRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringPathRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringPathRequestValidationError{}

// Validate checks the field values on EnumPathRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *EnumPathRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnumPathRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EnumPathRequestMultiError, or nil if none found.
func (m *EnumPathRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *EnumPathRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if m.OptStatus != nil {
		// no validation rules for OptStatus
	}

	if len(errors) > 0 {
		return EnumPathRequestMultiError(errors)
	}

	return nil
}

// EnumPathRequestMultiError is an error wrapping multiple validation errors
// returned by EnumPathRequest.ValidateAll() if the designated constraints
// aren't met.
type EnumPathRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnumPathRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnumPathRequestMultiError) AllErrors() []error { return m }

// EnumPathRequestValidationError is the validation error returned by
// EnumPathRequest.Validate if the designated constraints aren't met.
type EnumPathRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnumPathRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnumPathRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnumPathRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnumPathRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnumPathRequestValidationError) ErrorName() string { return "EnumPathRequestValidationError" }

// Error satisfies the builtin error interface
func (e EnumPathRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnumPathRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnumPathRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnumPathRequestValidationError{}

// Validate checks the field values on NamedPathRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *NamedPathRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NamedPathRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NamedPathRequestMultiError, or nil if none found.
func (m *NamedPathRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *NamedPathRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for String_

	if all {
		switch v := interface{}(m.GetWrapString()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NamedPathRequestValidationError{
					field:  "WrapString",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NamedPathRequestValidationError{
					field:  "WrapString",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWrapString()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NamedPathRequestValidationError{
				field:  "WrapString",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.OptString != nil {
		// no validation rules for OptString
	}

	if len(errors) > 0 {
		return NamedPathRequestMultiError(errors)
	}

	return nil
}

// NamedPathRequestMultiError is an error wrapping multiple validation errors
// returned by NamedPathRequest.ValidateAll() if the designated constraints
// aren't met.
type NamedPathRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamedPathRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamedPathRequestMultiError) AllErrors() []error { return m }

// NamedPathRequestValidationError is the validation error returned by
// NamedPathRequest.Validate if the designated constraints aren't met.
type NamedPathRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamedPathRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamedPathRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamedPathRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamedPathRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamedPathRequestValidationError) ErrorName() string { return "NamedPathRequestValidationError" }

// Error satisfies the builtin error interface
func (e NamedPathRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamedPathRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamedPathRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamedPathRequestValidationError{}

// Validate checks the field values on EmbedNamedPathRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EmbedNamedPathRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmbedNamedPathRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EmbedNamedPathRequestMultiError, or nil if none found.
func (m *EmbedNamedPathRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *EmbedNamedPathRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEmbed()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmbedNamedPathRequestValidationError{
					field:  "Embed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmbedNamedPathRequestValidationError{
					field:  "Embed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEmbed()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmbedNamedPathRequestValidationError{
				field:  "Embed",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EmbedNamedPathRequestMultiError(errors)
	}

	return nil
}

// EmbedNamedPathRequestMultiError is an error wrapping multiple validation
// errors returned by EmbedNamedPathRequest.ValidateAll() if the designated
// constraints aren't met.
type EmbedNamedPathRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmbedNamedPathRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmbedNamedPathRequestMultiError) AllErrors() []error { return m }

// EmbedNamedPathRequestValidationError is the validation error returned by
// EmbedNamedPathRequest.Validate if the designated constraints aren't met.
type EmbedNamedPathRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmbedNamedPathRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmbedNamedPathRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmbedNamedPathRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmbedNamedPathRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmbedNamedPathRequestValidationError) ErrorName() string {
	return "EmbedNamedPathRequestValidationError"
}

// Error satisfies the builtin error interface
func (e EmbedNamedPathRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmbedNamedPathRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmbedNamedPathRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmbedNamedPathRequestValidationError{}

// Validate checks the field values on MixPathRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MixPathRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MixPathRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MixPathRequestMultiError,
// or nil if none found.
func (m *MixPathRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MixPathRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for String_

	if all {
		switch v := interface{}(m.GetWrapString()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MixPathRequestValidationError{
					field:  "WrapString",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MixPathRequestValidationError{
					field:  "WrapString",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWrapString()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MixPathRequestValidationError{
				field:  "WrapString",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEmbed()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MixPathRequestValidationError{
					field:  "Embed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MixPathRequestValidationError{
					field:  "Embed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEmbed()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MixPathRequestValidationError{
				field:  "Embed",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.OptString != nil {
		// no validation rules for OptString
	}

	if len(errors) > 0 {
		return MixPathRequestMultiError(errors)
	}

	return nil
}

// MixPathRequestMultiError is an error wrapping multiple validation errors
// returned by MixPathRequest.ValidateAll() if the designated constraints
// aren't met.
type MixPathRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MixPathRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MixPathRequestMultiError) AllErrors() []error { return m }

// MixPathRequestValidationError is the validation error returned by
// MixPathRequest.Validate if the designated constraints aren't met.
type MixPathRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MixPathRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MixPathRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MixPathRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MixPathRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MixPathRequestValidationError) ErrorName() string { return "MixPathRequestValidationError" }

// Error satisfies the builtin error interface
func (e MixPathRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMixPathRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MixPathRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MixPathRequestValidationError{}
