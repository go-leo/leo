// Code generated by protoc-gen-go-leo. DO NOT EDIT.

package route

import (
	context "context"
	endpoint "github.com/go-kit/kit/endpoint"
	grpc "github.com/go-kit/kit/transport/grpc"
	endpointx "github.com/go-leo/leo/v3/endpointx"
	metadatax "github.com/go-leo/leo/v3/metadatax"
	stainx "github.com/go-leo/leo/v3/stainx"
	grpctransportx "github.com/go-leo/leo/v3/transportx/grpctransportx"
	grpc1 "google.golang.org/grpc"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	io "io"
)

func NewBoolPathGrpcServer(svc BoolPathService, opts ...grpctransportx.ServerOption) BoolPathServer {
	options := grpctransportx.NewServerOptions(opts...)
	endpoints := &boolPathServerEndpoints{
		svc:         svc,
		middlewares: options.Middlewares(),
	}
	transports := &boolPathGrpcServerTransports{
		endpoints: endpoints,
	}
	return &boolPathGrpcServer{
		boolPath: transports.BoolPath(),
	}
}

func NewBoolPathGrpcClient(target string, opts ...grpctransportx.ClientOption) BoolPathService {
	options := grpctransportx.NewClientOptions(opts...)
	transports := &boolPathGrpcClientTransports{
		dialOptions:   options.DialOptions(),
		clientOptions: options.ClientTransportOptions(),
		middlewares:   options.Middlewares(),
	}
	factories := &boolPathFactories{
		transports: transports,
	}
	endpointer := &boolPathEndpointers{
		target:    target,
		builder:   options.Builder(),
		factories: factories,
		logger:    options.Logger(),
		options:   options.EndpointerOptions(),
	}
	balancers := &boolPathBalancers{
		factory:    options.BalancerFactory(),
		endpointer: endpointer,
	}
	endpoints := &boolPathClientEndpoints{
		balancers: balancers,
	}
	return &boolPathClientService{
		endpoints:     endpoints,
		transportName: grpctransportx.GrpcClient,
	}
}

type boolPathGrpcServerTransports struct {
	endpoints BoolPathServerEndpoints
}

func (t *boolPathGrpcServerTransports) BoolPath() grpc.Handler {
	return grpc.NewServer(
		t.endpoints.BoolPath(context.TODO()),
		func(_ context.Context, v any) (any, error) { return v, nil },
		func(_ context.Context, v any) (any, error) { return v, nil },
		grpc.ServerBefore(grpctransportx.ServerEndpointInjector("/leo.example.route.path.BoolPath/BoolPath")),
		grpc.ServerBefore(grpctransportx.ServerTransportInjector),
		grpc.ServerBefore(metadatax.GrpcIncomingInjector),
		grpc.ServerBefore(stainx.GrpcIncomingInjector),
	)
}

type boolPathGrpcServer struct {
	boolPath grpc.Handler
}

func (s *boolPathGrpcServer) BoolPath(ctx context.Context, request *BoolPathRequest) (*emptypb.Empty, error) {
	ctx, rep, err := s.boolPath.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*emptypb.Empty), nil
}

func (s *boolPathGrpcServer) mustEmbedUnimplementedBoolPathServer() {}

type boolPathGrpcClientTransports struct {
	dialOptions   []grpc1.DialOption
	clientOptions []grpc.ClientOption
	middlewares   []endpoint.Middleware
}

func (t *boolPathGrpcClientTransports) BoolPath(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	conn, err := grpc1.NewClient(instance, t.dialOptions...)
	if err != nil {
		return nil, nil, err
	}
	opts := []grpc.ClientOption{
		grpc.ClientBefore(metadatax.GrpcOutgoingInjector),
		grpc.ClientBefore(stainx.GrpcOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := grpc.NewClient(
		conn,
		"leo.example.route.path.BoolPath",
		"BoolPath",
		func(_ context.Context, v any) (any, error) { return v, nil },
		func(_ context.Context, v any) (any, error) { return v, nil },
		emptypb.Empty{},
		opts...)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), conn, nil
}

func NewInt32PathGrpcServer(svc Int32PathService, opts ...grpctransportx.ServerOption) Int32PathServer {
	options := grpctransportx.NewServerOptions(opts...)
	endpoints := &int32PathServerEndpoints{
		svc:         svc,
		middlewares: options.Middlewares(),
	}
	transports := &int32PathGrpcServerTransports{
		endpoints: endpoints,
	}
	return &int32PathGrpcServer{
		int32Path: transports.Int32Path(),
	}
}

func NewInt32PathGrpcClient(target string, opts ...grpctransportx.ClientOption) Int32PathService {
	options := grpctransportx.NewClientOptions(opts...)
	transports := &int32PathGrpcClientTransports{
		dialOptions:   options.DialOptions(),
		clientOptions: options.ClientTransportOptions(),
		middlewares:   options.Middlewares(),
	}
	factories := &int32PathFactories{
		transports: transports,
	}
	endpointer := &int32PathEndpointers{
		target:    target,
		builder:   options.Builder(),
		factories: factories,
		logger:    options.Logger(),
		options:   options.EndpointerOptions(),
	}
	balancers := &int32PathBalancers{
		factory:    options.BalancerFactory(),
		endpointer: endpointer,
	}
	endpoints := &int32PathClientEndpoints{
		balancers: balancers,
	}
	return &int32PathClientService{
		endpoints:     endpoints,
		transportName: grpctransportx.GrpcClient,
	}
}

type int32PathGrpcServerTransports struct {
	endpoints Int32PathServerEndpoints
}

func (t *int32PathGrpcServerTransports) Int32Path() grpc.Handler {
	return grpc.NewServer(
		t.endpoints.Int32Path(context.TODO()),
		func(_ context.Context, v any) (any, error) { return v, nil },
		func(_ context.Context, v any) (any, error) { return v, nil },
		grpc.ServerBefore(grpctransportx.ServerEndpointInjector("/leo.example.route.path.Int32Path/Int32Path")),
		grpc.ServerBefore(grpctransportx.ServerTransportInjector),
		grpc.ServerBefore(metadatax.GrpcIncomingInjector),
		grpc.ServerBefore(stainx.GrpcIncomingInjector),
	)
}

type int32PathGrpcServer struct {
	int32Path grpc.Handler
}

func (s *int32PathGrpcServer) Int32Path(ctx context.Context, request *Int32PathRequest) (*emptypb.Empty, error) {
	ctx, rep, err := s.int32Path.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*emptypb.Empty), nil
}

func (s *int32PathGrpcServer) mustEmbedUnimplementedInt32PathServer() {}

type int32PathGrpcClientTransports struct {
	dialOptions   []grpc1.DialOption
	clientOptions []grpc.ClientOption
	middlewares   []endpoint.Middleware
}

func (t *int32PathGrpcClientTransports) Int32Path(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	conn, err := grpc1.NewClient(instance, t.dialOptions...)
	if err != nil {
		return nil, nil, err
	}
	opts := []grpc.ClientOption{
		grpc.ClientBefore(metadatax.GrpcOutgoingInjector),
		grpc.ClientBefore(stainx.GrpcOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := grpc.NewClient(
		conn,
		"leo.example.route.path.Int32Path",
		"Int32Path",
		func(_ context.Context, v any) (any, error) { return v, nil },
		func(_ context.Context, v any) (any, error) { return v, nil },
		emptypb.Empty{},
		opts...)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), conn, nil
}

func NewInt64PathGrpcServer(svc Int64PathService, opts ...grpctransportx.ServerOption) Int64PathServer {
	options := grpctransportx.NewServerOptions(opts...)
	endpoints := &int64PathServerEndpoints{
		svc:         svc,
		middlewares: options.Middlewares(),
	}
	transports := &int64PathGrpcServerTransports{
		endpoints: endpoints,
	}
	return &int64PathGrpcServer{
		int64Path: transports.Int64Path(),
	}
}

func NewInt64PathGrpcClient(target string, opts ...grpctransportx.ClientOption) Int64PathService {
	options := grpctransportx.NewClientOptions(opts...)
	transports := &int64PathGrpcClientTransports{
		dialOptions:   options.DialOptions(),
		clientOptions: options.ClientTransportOptions(),
		middlewares:   options.Middlewares(),
	}
	factories := &int64PathFactories{
		transports: transports,
	}
	endpointer := &int64PathEndpointers{
		target:    target,
		builder:   options.Builder(),
		factories: factories,
		logger:    options.Logger(),
		options:   options.EndpointerOptions(),
	}
	balancers := &int64PathBalancers{
		factory:    options.BalancerFactory(),
		endpointer: endpointer,
	}
	endpoints := &int64PathClientEndpoints{
		balancers: balancers,
	}
	return &int64PathClientService{
		endpoints:     endpoints,
		transportName: grpctransportx.GrpcClient,
	}
}

type int64PathGrpcServerTransports struct {
	endpoints Int64PathServerEndpoints
}

func (t *int64PathGrpcServerTransports) Int64Path() grpc.Handler {
	return grpc.NewServer(
		t.endpoints.Int64Path(context.TODO()),
		func(_ context.Context, v any) (any, error) { return v, nil },
		func(_ context.Context, v any) (any, error) { return v, nil },
		grpc.ServerBefore(grpctransportx.ServerEndpointInjector("/leo.example.route.path.Int64Path/Int64Path")),
		grpc.ServerBefore(grpctransportx.ServerTransportInjector),
		grpc.ServerBefore(metadatax.GrpcIncomingInjector),
		grpc.ServerBefore(stainx.GrpcIncomingInjector),
	)
}

type int64PathGrpcServer struct {
	int64Path grpc.Handler
}

func (s *int64PathGrpcServer) Int64Path(ctx context.Context, request *Int64PathRequest) (*emptypb.Empty, error) {
	ctx, rep, err := s.int64Path.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*emptypb.Empty), nil
}

func (s *int64PathGrpcServer) mustEmbedUnimplementedInt64PathServer() {}

type int64PathGrpcClientTransports struct {
	dialOptions   []grpc1.DialOption
	clientOptions []grpc.ClientOption
	middlewares   []endpoint.Middleware
}

func (t *int64PathGrpcClientTransports) Int64Path(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	conn, err := grpc1.NewClient(instance, t.dialOptions...)
	if err != nil {
		return nil, nil, err
	}
	opts := []grpc.ClientOption{
		grpc.ClientBefore(metadatax.GrpcOutgoingInjector),
		grpc.ClientBefore(stainx.GrpcOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := grpc.NewClient(
		conn,
		"leo.example.route.path.Int64Path",
		"Int64Path",
		func(_ context.Context, v any) (any, error) { return v, nil },
		func(_ context.Context, v any) (any, error) { return v, nil },
		emptypb.Empty{},
		opts...)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), conn, nil
}

func NewUint32PathGrpcServer(svc Uint32PathService, opts ...grpctransportx.ServerOption) Uint32PathServer {
	options := grpctransportx.NewServerOptions(opts...)
	endpoints := &uint32PathServerEndpoints{
		svc:         svc,
		middlewares: options.Middlewares(),
	}
	transports := &uint32PathGrpcServerTransports{
		endpoints: endpoints,
	}
	return &uint32PathGrpcServer{
		uint32Path: transports.Uint32Path(),
	}
}

func NewUint32PathGrpcClient(target string, opts ...grpctransportx.ClientOption) Uint32PathService {
	options := grpctransportx.NewClientOptions(opts...)
	transports := &uint32PathGrpcClientTransports{
		dialOptions:   options.DialOptions(),
		clientOptions: options.ClientTransportOptions(),
		middlewares:   options.Middlewares(),
	}
	factories := &uint32PathFactories{
		transports: transports,
	}
	endpointer := &uint32PathEndpointers{
		target:    target,
		builder:   options.Builder(),
		factories: factories,
		logger:    options.Logger(),
		options:   options.EndpointerOptions(),
	}
	balancers := &uint32PathBalancers{
		factory:    options.BalancerFactory(),
		endpointer: endpointer,
	}
	endpoints := &uint32PathClientEndpoints{
		balancers: balancers,
	}
	return &uint32PathClientService{
		endpoints:     endpoints,
		transportName: grpctransportx.GrpcClient,
	}
}

type uint32PathGrpcServerTransports struct {
	endpoints Uint32PathServerEndpoints
}

func (t *uint32PathGrpcServerTransports) Uint32Path() grpc.Handler {
	return grpc.NewServer(
		t.endpoints.Uint32Path(context.TODO()),
		func(_ context.Context, v any) (any, error) { return v, nil },
		func(_ context.Context, v any) (any, error) { return v, nil },
		grpc.ServerBefore(grpctransportx.ServerEndpointInjector("/leo.example.route.path.Uint32Path/Uint32Path")),
		grpc.ServerBefore(grpctransportx.ServerTransportInjector),
		grpc.ServerBefore(metadatax.GrpcIncomingInjector),
		grpc.ServerBefore(stainx.GrpcIncomingInjector),
	)
}

type uint32PathGrpcServer struct {
	uint32Path grpc.Handler
}

func (s *uint32PathGrpcServer) Uint32Path(ctx context.Context, request *Uint32PathRequest) (*emptypb.Empty, error) {
	ctx, rep, err := s.uint32Path.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*emptypb.Empty), nil
}

func (s *uint32PathGrpcServer) mustEmbedUnimplementedUint32PathServer() {}

type uint32PathGrpcClientTransports struct {
	dialOptions   []grpc1.DialOption
	clientOptions []grpc.ClientOption
	middlewares   []endpoint.Middleware
}

func (t *uint32PathGrpcClientTransports) Uint32Path(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	conn, err := grpc1.NewClient(instance, t.dialOptions...)
	if err != nil {
		return nil, nil, err
	}
	opts := []grpc.ClientOption{
		grpc.ClientBefore(metadatax.GrpcOutgoingInjector),
		grpc.ClientBefore(stainx.GrpcOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := grpc.NewClient(
		conn,
		"leo.example.route.path.Uint32Path",
		"Uint32Path",
		func(_ context.Context, v any) (any, error) { return v, nil },
		func(_ context.Context, v any) (any, error) { return v, nil },
		emptypb.Empty{},
		opts...)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), conn, nil
}

func NewUint64PathGrpcServer(svc Uint64PathService, opts ...grpctransportx.ServerOption) Uint64PathServer {
	options := grpctransportx.NewServerOptions(opts...)
	endpoints := &uint64PathServerEndpoints{
		svc:         svc,
		middlewares: options.Middlewares(),
	}
	transports := &uint64PathGrpcServerTransports{
		endpoints: endpoints,
	}
	return &uint64PathGrpcServer{
		uint64Path: transports.Uint64Path(),
	}
}

func NewUint64PathGrpcClient(target string, opts ...grpctransportx.ClientOption) Uint64PathService {
	options := grpctransportx.NewClientOptions(opts...)
	transports := &uint64PathGrpcClientTransports{
		dialOptions:   options.DialOptions(),
		clientOptions: options.ClientTransportOptions(),
		middlewares:   options.Middlewares(),
	}
	factories := &uint64PathFactories{
		transports: transports,
	}
	endpointer := &uint64PathEndpointers{
		target:    target,
		builder:   options.Builder(),
		factories: factories,
		logger:    options.Logger(),
		options:   options.EndpointerOptions(),
	}
	balancers := &uint64PathBalancers{
		factory:    options.BalancerFactory(),
		endpointer: endpointer,
	}
	endpoints := &uint64PathClientEndpoints{
		balancers: balancers,
	}
	return &uint64PathClientService{
		endpoints:     endpoints,
		transportName: grpctransportx.GrpcClient,
	}
}

type uint64PathGrpcServerTransports struct {
	endpoints Uint64PathServerEndpoints
}

func (t *uint64PathGrpcServerTransports) Uint64Path() grpc.Handler {
	return grpc.NewServer(
		t.endpoints.Uint64Path(context.TODO()),
		func(_ context.Context, v any) (any, error) { return v, nil },
		func(_ context.Context, v any) (any, error) { return v, nil },
		grpc.ServerBefore(grpctransportx.ServerEndpointInjector("/leo.example.route.path.Uint64Path/Uint64Path")),
		grpc.ServerBefore(grpctransportx.ServerTransportInjector),
		grpc.ServerBefore(metadatax.GrpcIncomingInjector),
		grpc.ServerBefore(stainx.GrpcIncomingInjector),
	)
}

type uint64PathGrpcServer struct {
	uint64Path grpc.Handler
}

func (s *uint64PathGrpcServer) Uint64Path(ctx context.Context, request *Uint64PathRequest) (*emptypb.Empty, error) {
	ctx, rep, err := s.uint64Path.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*emptypb.Empty), nil
}

func (s *uint64PathGrpcServer) mustEmbedUnimplementedUint64PathServer() {}

type uint64PathGrpcClientTransports struct {
	dialOptions   []grpc1.DialOption
	clientOptions []grpc.ClientOption
	middlewares   []endpoint.Middleware
}

func (t *uint64PathGrpcClientTransports) Uint64Path(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	conn, err := grpc1.NewClient(instance, t.dialOptions...)
	if err != nil {
		return nil, nil, err
	}
	opts := []grpc.ClientOption{
		grpc.ClientBefore(metadatax.GrpcOutgoingInjector),
		grpc.ClientBefore(stainx.GrpcOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := grpc.NewClient(
		conn,
		"leo.example.route.path.Uint64Path",
		"Uint64Path",
		func(_ context.Context, v any) (any, error) { return v, nil },
		func(_ context.Context, v any) (any, error) { return v, nil },
		emptypb.Empty{},
		opts...)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), conn, nil
}

func NewFloatPathGrpcServer(svc FloatPathService, opts ...grpctransportx.ServerOption) FloatPathServer {
	options := grpctransportx.NewServerOptions(opts...)
	endpoints := &floatPathServerEndpoints{
		svc:         svc,
		middlewares: options.Middlewares(),
	}
	transports := &floatPathGrpcServerTransports{
		endpoints: endpoints,
	}
	return &floatPathGrpcServer{
		floatPath: transports.FloatPath(),
	}
}

func NewFloatPathGrpcClient(target string, opts ...grpctransportx.ClientOption) FloatPathService {
	options := grpctransportx.NewClientOptions(opts...)
	transports := &floatPathGrpcClientTransports{
		dialOptions:   options.DialOptions(),
		clientOptions: options.ClientTransportOptions(),
		middlewares:   options.Middlewares(),
	}
	factories := &floatPathFactories{
		transports: transports,
	}
	endpointer := &floatPathEndpointers{
		target:    target,
		builder:   options.Builder(),
		factories: factories,
		logger:    options.Logger(),
		options:   options.EndpointerOptions(),
	}
	balancers := &floatPathBalancers{
		factory:    options.BalancerFactory(),
		endpointer: endpointer,
	}
	endpoints := &floatPathClientEndpoints{
		balancers: balancers,
	}
	return &floatPathClientService{
		endpoints:     endpoints,
		transportName: grpctransportx.GrpcClient,
	}
}

type floatPathGrpcServerTransports struct {
	endpoints FloatPathServerEndpoints
}

func (t *floatPathGrpcServerTransports) FloatPath() grpc.Handler {
	return grpc.NewServer(
		t.endpoints.FloatPath(context.TODO()),
		func(_ context.Context, v any) (any, error) { return v, nil },
		func(_ context.Context, v any) (any, error) { return v, nil },
		grpc.ServerBefore(grpctransportx.ServerEndpointInjector("/leo.example.route.path.FloatPath/FloatPath")),
		grpc.ServerBefore(grpctransportx.ServerTransportInjector),
		grpc.ServerBefore(metadatax.GrpcIncomingInjector),
		grpc.ServerBefore(stainx.GrpcIncomingInjector),
	)
}

type floatPathGrpcServer struct {
	floatPath grpc.Handler
}

func (s *floatPathGrpcServer) FloatPath(ctx context.Context, request *FloatPathRequest) (*emptypb.Empty, error) {
	ctx, rep, err := s.floatPath.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*emptypb.Empty), nil
}

func (s *floatPathGrpcServer) mustEmbedUnimplementedFloatPathServer() {}

type floatPathGrpcClientTransports struct {
	dialOptions   []grpc1.DialOption
	clientOptions []grpc.ClientOption
	middlewares   []endpoint.Middleware
}

func (t *floatPathGrpcClientTransports) FloatPath(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	conn, err := grpc1.NewClient(instance, t.dialOptions...)
	if err != nil {
		return nil, nil, err
	}
	opts := []grpc.ClientOption{
		grpc.ClientBefore(metadatax.GrpcOutgoingInjector),
		grpc.ClientBefore(stainx.GrpcOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := grpc.NewClient(
		conn,
		"leo.example.route.path.FloatPath",
		"FloatPath",
		func(_ context.Context, v any) (any, error) { return v, nil },
		func(_ context.Context, v any) (any, error) { return v, nil },
		emptypb.Empty{},
		opts...)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), conn, nil
}

func NewDoublePathGrpcServer(svc DoublePathService, opts ...grpctransportx.ServerOption) DoublePathServer {
	options := grpctransportx.NewServerOptions(opts...)
	endpoints := &doublePathServerEndpoints{
		svc:         svc,
		middlewares: options.Middlewares(),
	}
	transports := &doublePathGrpcServerTransports{
		endpoints: endpoints,
	}
	return &doublePathGrpcServer{
		doublePath: transports.DoublePath(),
	}
}

func NewDoublePathGrpcClient(target string, opts ...grpctransportx.ClientOption) DoublePathService {
	options := grpctransportx.NewClientOptions(opts...)
	transports := &doublePathGrpcClientTransports{
		dialOptions:   options.DialOptions(),
		clientOptions: options.ClientTransportOptions(),
		middlewares:   options.Middlewares(),
	}
	factories := &doublePathFactories{
		transports: transports,
	}
	endpointer := &doublePathEndpointers{
		target:    target,
		builder:   options.Builder(),
		factories: factories,
		logger:    options.Logger(),
		options:   options.EndpointerOptions(),
	}
	balancers := &doublePathBalancers{
		factory:    options.BalancerFactory(),
		endpointer: endpointer,
	}
	endpoints := &doublePathClientEndpoints{
		balancers: balancers,
	}
	return &doublePathClientService{
		endpoints:     endpoints,
		transportName: grpctransportx.GrpcClient,
	}
}

type doublePathGrpcServerTransports struct {
	endpoints DoublePathServerEndpoints
}

func (t *doublePathGrpcServerTransports) DoublePath() grpc.Handler {
	return grpc.NewServer(
		t.endpoints.DoublePath(context.TODO()),
		func(_ context.Context, v any) (any, error) { return v, nil },
		func(_ context.Context, v any) (any, error) { return v, nil },
		grpc.ServerBefore(grpctransportx.ServerEndpointInjector("/leo.example.route.path.DoublePath/DoublePath")),
		grpc.ServerBefore(grpctransportx.ServerTransportInjector),
		grpc.ServerBefore(metadatax.GrpcIncomingInjector),
		grpc.ServerBefore(stainx.GrpcIncomingInjector),
	)
}

type doublePathGrpcServer struct {
	doublePath grpc.Handler
}

func (s *doublePathGrpcServer) DoublePath(ctx context.Context, request *DoublePathRequest) (*emptypb.Empty, error) {
	ctx, rep, err := s.doublePath.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*emptypb.Empty), nil
}

func (s *doublePathGrpcServer) mustEmbedUnimplementedDoublePathServer() {}

type doublePathGrpcClientTransports struct {
	dialOptions   []grpc1.DialOption
	clientOptions []grpc.ClientOption
	middlewares   []endpoint.Middleware
}

func (t *doublePathGrpcClientTransports) DoublePath(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	conn, err := grpc1.NewClient(instance, t.dialOptions...)
	if err != nil {
		return nil, nil, err
	}
	opts := []grpc.ClientOption{
		grpc.ClientBefore(metadatax.GrpcOutgoingInjector),
		grpc.ClientBefore(stainx.GrpcOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := grpc.NewClient(
		conn,
		"leo.example.route.path.DoublePath",
		"DoublePath",
		func(_ context.Context, v any) (any, error) { return v, nil },
		func(_ context.Context, v any) (any, error) { return v, nil },
		emptypb.Empty{},
		opts...)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), conn, nil
}

func NewStringPathGrpcServer(svc StringPathService, opts ...grpctransportx.ServerOption) StringPathServer {
	options := grpctransportx.NewServerOptions(opts...)
	endpoints := &stringPathServerEndpoints{
		svc:         svc,
		middlewares: options.Middlewares(),
	}
	transports := &stringPathGrpcServerTransports{
		endpoints: endpoints,
	}
	return &stringPathGrpcServer{
		stringPath: transports.StringPath(),
	}
}

func NewStringPathGrpcClient(target string, opts ...grpctransportx.ClientOption) StringPathService {
	options := grpctransportx.NewClientOptions(opts...)
	transports := &stringPathGrpcClientTransports{
		dialOptions:   options.DialOptions(),
		clientOptions: options.ClientTransportOptions(),
		middlewares:   options.Middlewares(),
	}
	factories := &stringPathFactories{
		transports: transports,
	}
	endpointer := &stringPathEndpointers{
		target:    target,
		builder:   options.Builder(),
		factories: factories,
		logger:    options.Logger(),
		options:   options.EndpointerOptions(),
	}
	balancers := &stringPathBalancers{
		factory:    options.BalancerFactory(),
		endpointer: endpointer,
	}
	endpoints := &stringPathClientEndpoints{
		balancers: balancers,
	}
	return &stringPathClientService{
		endpoints:     endpoints,
		transportName: grpctransportx.GrpcClient,
	}
}

type stringPathGrpcServerTransports struct {
	endpoints StringPathServerEndpoints
}

func (t *stringPathGrpcServerTransports) StringPath() grpc.Handler {
	return grpc.NewServer(
		t.endpoints.StringPath(context.TODO()),
		func(_ context.Context, v any) (any, error) { return v, nil },
		func(_ context.Context, v any) (any, error) { return v, nil },
		grpc.ServerBefore(grpctransportx.ServerEndpointInjector("/leo.example.route.path.StringPath/StringPath")),
		grpc.ServerBefore(grpctransportx.ServerTransportInjector),
		grpc.ServerBefore(metadatax.GrpcIncomingInjector),
		grpc.ServerBefore(stainx.GrpcIncomingInjector),
	)
}

type stringPathGrpcServer struct {
	stringPath grpc.Handler
}

func (s *stringPathGrpcServer) StringPath(ctx context.Context, request *StringPathRequest) (*emptypb.Empty, error) {
	ctx, rep, err := s.stringPath.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*emptypb.Empty), nil
}

func (s *stringPathGrpcServer) mustEmbedUnimplementedStringPathServer() {}

type stringPathGrpcClientTransports struct {
	dialOptions   []grpc1.DialOption
	clientOptions []grpc.ClientOption
	middlewares   []endpoint.Middleware
}

func (t *stringPathGrpcClientTransports) StringPath(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	conn, err := grpc1.NewClient(instance, t.dialOptions...)
	if err != nil {
		return nil, nil, err
	}
	opts := []grpc.ClientOption{
		grpc.ClientBefore(metadatax.GrpcOutgoingInjector),
		grpc.ClientBefore(stainx.GrpcOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := grpc.NewClient(
		conn,
		"leo.example.route.path.StringPath",
		"StringPath",
		func(_ context.Context, v any) (any, error) { return v, nil },
		func(_ context.Context, v any) (any, error) { return v, nil },
		emptypb.Empty{},
		opts...)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), conn, nil
}

func NewEnumPathGrpcServer(svc EnumPathService, opts ...grpctransportx.ServerOption) EnumPathServer {
	options := grpctransportx.NewServerOptions(opts...)
	endpoints := &enumPathServerEndpoints{
		svc:         svc,
		middlewares: options.Middlewares(),
	}
	transports := &enumPathGrpcServerTransports{
		endpoints: endpoints,
	}
	return &enumPathGrpcServer{
		enumPath: transports.EnumPath(),
	}
}

func NewEnumPathGrpcClient(target string, opts ...grpctransportx.ClientOption) EnumPathService {
	options := grpctransportx.NewClientOptions(opts...)
	transports := &enumPathGrpcClientTransports{
		dialOptions:   options.DialOptions(),
		clientOptions: options.ClientTransportOptions(),
		middlewares:   options.Middlewares(),
	}
	factories := &enumPathFactories{
		transports: transports,
	}
	endpointer := &enumPathEndpointers{
		target:    target,
		builder:   options.Builder(),
		factories: factories,
		logger:    options.Logger(),
		options:   options.EndpointerOptions(),
	}
	balancers := &enumPathBalancers{
		factory:    options.BalancerFactory(),
		endpointer: endpointer,
	}
	endpoints := &enumPathClientEndpoints{
		balancers: balancers,
	}
	return &enumPathClientService{
		endpoints:     endpoints,
		transportName: grpctransportx.GrpcClient,
	}
}

type enumPathGrpcServerTransports struct {
	endpoints EnumPathServerEndpoints
}

func (t *enumPathGrpcServerTransports) EnumPath() grpc.Handler {
	return grpc.NewServer(
		t.endpoints.EnumPath(context.TODO()),
		func(_ context.Context, v any) (any, error) { return v, nil },
		func(_ context.Context, v any) (any, error) { return v, nil },
		grpc.ServerBefore(grpctransportx.ServerEndpointInjector("/leo.example.route.path.EnumPath/EnumPath")),
		grpc.ServerBefore(grpctransportx.ServerTransportInjector),
		grpc.ServerBefore(metadatax.GrpcIncomingInjector),
		grpc.ServerBefore(stainx.GrpcIncomingInjector),
	)
}

type enumPathGrpcServer struct {
	enumPath grpc.Handler
}

func (s *enumPathGrpcServer) EnumPath(ctx context.Context, request *EnumPathRequest) (*emptypb.Empty, error) {
	ctx, rep, err := s.enumPath.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*emptypb.Empty), nil
}

func (s *enumPathGrpcServer) mustEmbedUnimplementedEnumPathServer() {}

type enumPathGrpcClientTransports struct {
	dialOptions   []grpc1.DialOption
	clientOptions []grpc.ClientOption
	middlewares   []endpoint.Middleware
}

func (t *enumPathGrpcClientTransports) EnumPath(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	conn, err := grpc1.NewClient(instance, t.dialOptions...)
	if err != nil {
		return nil, nil, err
	}
	opts := []grpc.ClientOption{
		grpc.ClientBefore(metadatax.GrpcOutgoingInjector),
		grpc.ClientBefore(stainx.GrpcOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := grpc.NewClient(
		conn,
		"leo.example.route.path.EnumPath",
		"EnumPath",
		func(_ context.Context, v any) (any, error) { return v, nil },
		func(_ context.Context, v any) (any, error) { return v, nil },
		emptypb.Empty{},
		opts...)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), conn, nil
}

func NewNamedPathGrpcServer(svc NamedPathService, opts ...grpctransportx.ServerOption) NamedPathServer {
	options := grpctransportx.NewServerOptions(opts...)
	endpoints := &namedPathServerEndpoints{
		svc:         svc,
		middlewares: options.Middlewares(),
	}
	transports := &namedPathGrpcServerTransports{
		endpoints: endpoints,
	}
	return &namedPathGrpcServer{
		namedPathString:          transports.NamedPathString(),
		namedPathOptString:       transports.NamedPathOptString(),
		namedPathWrapString:      transports.NamedPathWrapString(),
		embedNamedPathString:     transports.EmbedNamedPathString(),
		embedNamedPathOptString:  transports.EmbedNamedPathOptString(),
		embedNamedPathWrapString: transports.EmbedNamedPathWrapString(),
	}
}

func NewNamedPathGrpcClient(target string, opts ...grpctransportx.ClientOption) NamedPathService {
	options := grpctransportx.NewClientOptions(opts...)
	transports := &namedPathGrpcClientTransports{
		dialOptions:   options.DialOptions(),
		clientOptions: options.ClientTransportOptions(),
		middlewares:   options.Middlewares(),
	}
	factories := &namedPathFactories{
		transports: transports,
	}
	endpointer := &namedPathEndpointers{
		target:    target,
		builder:   options.Builder(),
		factories: factories,
		logger:    options.Logger(),
		options:   options.EndpointerOptions(),
	}
	balancers := &namedPathBalancers{
		factory:    options.BalancerFactory(),
		endpointer: endpointer,
	}
	endpoints := &namedPathClientEndpoints{
		balancers: balancers,
	}
	return &namedPathClientService{
		endpoints:     endpoints,
		transportName: grpctransportx.GrpcClient,
	}
}

type namedPathGrpcServerTransports struct {
	endpoints NamedPathServerEndpoints
}

func (t *namedPathGrpcServerTransports) NamedPathString() grpc.Handler {
	return grpc.NewServer(
		t.endpoints.NamedPathString(context.TODO()),
		func(_ context.Context, v any) (any, error) { return v, nil },
		func(_ context.Context, v any) (any, error) { return v, nil },
		grpc.ServerBefore(grpctransportx.ServerEndpointInjector("/leo.example.route.path.NamedPath/NamedPathString")),
		grpc.ServerBefore(grpctransportx.ServerTransportInjector),
		grpc.ServerBefore(metadatax.GrpcIncomingInjector),
		grpc.ServerBefore(stainx.GrpcIncomingInjector),
	)
}

func (t *namedPathGrpcServerTransports) NamedPathOptString() grpc.Handler {
	return grpc.NewServer(
		t.endpoints.NamedPathOptString(context.TODO()),
		func(_ context.Context, v any) (any, error) { return v, nil },
		func(_ context.Context, v any) (any, error) { return v, nil },
		grpc.ServerBefore(grpctransportx.ServerEndpointInjector("/leo.example.route.path.NamedPath/NamedPathOptString")),
		grpc.ServerBefore(grpctransportx.ServerTransportInjector),
		grpc.ServerBefore(metadatax.GrpcIncomingInjector),
		grpc.ServerBefore(stainx.GrpcIncomingInjector),
	)
}

func (t *namedPathGrpcServerTransports) NamedPathWrapString() grpc.Handler {
	return grpc.NewServer(
		t.endpoints.NamedPathWrapString(context.TODO()),
		func(_ context.Context, v any) (any, error) { return v, nil },
		func(_ context.Context, v any) (any, error) { return v, nil },
		grpc.ServerBefore(grpctransportx.ServerEndpointInjector("/leo.example.route.path.NamedPath/NamedPathWrapString")),
		grpc.ServerBefore(grpctransportx.ServerTransportInjector),
		grpc.ServerBefore(metadatax.GrpcIncomingInjector),
		grpc.ServerBefore(stainx.GrpcIncomingInjector),
	)
}

func (t *namedPathGrpcServerTransports) EmbedNamedPathString() grpc.Handler {
	return grpc.NewServer(
		t.endpoints.EmbedNamedPathString(context.TODO()),
		func(_ context.Context, v any) (any, error) { return v, nil },
		func(_ context.Context, v any) (any, error) { return v, nil },
		grpc.ServerBefore(grpctransportx.ServerEndpointInjector("/leo.example.route.path.NamedPath/EmbedNamedPathString")),
		grpc.ServerBefore(grpctransportx.ServerTransportInjector),
		grpc.ServerBefore(metadatax.GrpcIncomingInjector),
		grpc.ServerBefore(stainx.GrpcIncomingInjector),
	)
}

func (t *namedPathGrpcServerTransports) EmbedNamedPathOptString() grpc.Handler {
	return grpc.NewServer(
		t.endpoints.EmbedNamedPathOptString(context.TODO()),
		func(_ context.Context, v any) (any, error) { return v, nil },
		func(_ context.Context, v any) (any, error) { return v, nil },
		grpc.ServerBefore(grpctransportx.ServerEndpointInjector("/leo.example.route.path.NamedPath/EmbedNamedPathOptString")),
		grpc.ServerBefore(grpctransportx.ServerTransportInjector),
		grpc.ServerBefore(metadatax.GrpcIncomingInjector),
		grpc.ServerBefore(stainx.GrpcIncomingInjector),
	)
}

func (t *namedPathGrpcServerTransports) EmbedNamedPathWrapString() grpc.Handler {
	return grpc.NewServer(
		t.endpoints.EmbedNamedPathWrapString(context.TODO()),
		func(_ context.Context, v any) (any, error) { return v, nil },
		func(_ context.Context, v any) (any, error) { return v, nil },
		grpc.ServerBefore(grpctransportx.ServerEndpointInjector("/leo.example.route.path.NamedPath/EmbedNamedPathWrapString")),
		grpc.ServerBefore(grpctransportx.ServerTransportInjector),
		grpc.ServerBefore(metadatax.GrpcIncomingInjector),
		grpc.ServerBefore(stainx.GrpcIncomingInjector),
	)
}

type namedPathGrpcServer struct {
	namedPathString          grpc.Handler
	namedPathOptString       grpc.Handler
	namedPathWrapString      grpc.Handler
	embedNamedPathString     grpc.Handler
	embedNamedPathOptString  grpc.Handler
	embedNamedPathWrapString grpc.Handler
}

func (s *namedPathGrpcServer) NamedPathString(ctx context.Context, request *NamedPathRequest) (*emptypb.Empty, error) {
	ctx, rep, err := s.namedPathString.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*emptypb.Empty), nil
}

func (s *namedPathGrpcServer) NamedPathOptString(ctx context.Context, request *NamedPathRequest) (*emptypb.Empty, error) {
	ctx, rep, err := s.namedPathOptString.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*emptypb.Empty), nil
}

func (s *namedPathGrpcServer) NamedPathWrapString(ctx context.Context, request *NamedPathRequest) (*emptypb.Empty, error) {
	ctx, rep, err := s.namedPathWrapString.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*emptypb.Empty), nil
}

func (s *namedPathGrpcServer) EmbedNamedPathString(ctx context.Context, request *EmbedNamedPathRequest) (*emptypb.Empty, error) {
	ctx, rep, err := s.embedNamedPathString.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*emptypb.Empty), nil
}

func (s *namedPathGrpcServer) EmbedNamedPathOptString(ctx context.Context, request *EmbedNamedPathRequest) (*emptypb.Empty, error) {
	ctx, rep, err := s.embedNamedPathOptString.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*emptypb.Empty), nil
}

func (s *namedPathGrpcServer) EmbedNamedPathWrapString(ctx context.Context, request *EmbedNamedPathRequest) (*emptypb.Empty, error) {
	ctx, rep, err := s.embedNamedPathWrapString.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*emptypb.Empty), nil
}

func (s *namedPathGrpcServer) mustEmbedUnimplementedNamedPathServer() {}

type namedPathGrpcClientTransports struct {
	dialOptions   []grpc1.DialOption
	clientOptions []grpc.ClientOption
	middlewares   []endpoint.Middleware
}

func (t *namedPathGrpcClientTransports) NamedPathString(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	conn, err := grpc1.NewClient(instance, t.dialOptions...)
	if err != nil {
		return nil, nil, err
	}
	opts := []grpc.ClientOption{
		grpc.ClientBefore(metadatax.GrpcOutgoingInjector),
		grpc.ClientBefore(stainx.GrpcOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := grpc.NewClient(
		conn,
		"leo.example.route.path.NamedPath",
		"NamedPathString",
		func(_ context.Context, v any) (any, error) { return v, nil },
		func(_ context.Context, v any) (any, error) { return v, nil },
		emptypb.Empty{},
		opts...)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), conn, nil
}

func (t *namedPathGrpcClientTransports) NamedPathOptString(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	conn, err := grpc1.NewClient(instance, t.dialOptions...)
	if err != nil {
		return nil, nil, err
	}
	opts := []grpc.ClientOption{
		grpc.ClientBefore(metadatax.GrpcOutgoingInjector),
		grpc.ClientBefore(stainx.GrpcOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := grpc.NewClient(
		conn,
		"leo.example.route.path.NamedPath",
		"NamedPathOptString",
		func(_ context.Context, v any) (any, error) { return v, nil },
		func(_ context.Context, v any) (any, error) { return v, nil },
		emptypb.Empty{},
		opts...)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), conn, nil
}

func (t *namedPathGrpcClientTransports) NamedPathWrapString(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	conn, err := grpc1.NewClient(instance, t.dialOptions...)
	if err != nil {
		return nil, nil, err
	}
	opts := []grpc.ClientOption{
		grpc.ClientBefore(metadatax.GrpcOutgoingInjector),
		grpc.ClientBefore(stainx.GrpcOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := grpc.NewClient(
		conn,
		"leo.example.route.path.NamedPath",
		"NamedPathWrapString",
		func(_ context.Context, v any) (any, error) { return v, nil },
		func(_ context.Context, v any) (any, error) { return v, nil },
		emptypb.Empty{},
		opts...)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), conn, nil
}

func (t *namedPathGrpcClientTransports) EmbedNamedPathString(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	conn, err := grpc1.NewClient(instance, t.dialOptions...)
	if err != nil {
		return nil, nil, err
	}
	opts := []grpc.ClientOption{
		grpc.ClientBefore(metadatax.GrpcOutgoingInjector),
		grpc.ClientBefore(stainx.GrpcOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := grpc.NewClient(
		conn,
		"leo.example.route.path.NamedPath",
		"EmbedNamedPathString",
		func(_ context.Context, v any) (any, error) { return v, nil },
		func(_ context.Context, v any) (any, error) { return v, nil },
		emptypb.Empty{},
		opts...)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), conn, nil
}

func (t *namedPathGrpcClientTransports) EmbedNamedPathOptString(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	conn, err := grpc1.NewClient(instance, t.dialOptions...)
	if err != nil {
		return nil, nil, err
	}
	opts := []grpc.ClientOption{
		grpc.ClientBefore(metadatax.GrpcOutgoingInjector),
		grpc.ClientBefore(stainx.GrpcOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := grpc.NewClient(
		conn,
		"leo.example.route.path.NamedPath",
		"EmbedNamedPathOptString",
		func(_ context.Context, v any) (any, error) { return v, nil },
		func(_ context.Context, v any) (any, error) { return v, nil },
		emptypb.Empty{},
		opts...)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), conn, nil
}

func (t *namedPathGrpcClientTransports) EmbedNamedPathWrapString(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	conn, err := grpc1.NewClient(instance, t.dialOptions...)
	if err != nil {
		return nil, nil, err
	}
	opts := []grpc.ClientOption{
		grpc.ClientBefore(metadatax.GrpcOutgoingInjector),
		grpc.ClientBefore(stainx.GrpcOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := grpc.NewClient(
		conn,
		"leo.example.route.path.NamedPath",
		"EmbedNamedPathWrapString",
		func(_ context.Context, v any) (any, error) { return v, nil },
		func(_ context.Context, v any) (any, error) { return v, nil },
		emptypb.Empty{},
		opts...)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), conn, nil
}

func NewMixPathGrpcServer(svc MixPathService, opts ...grpctransportx.ServerOption) MixPathServer {
	options := grpctransportx.NewServerOptions(opts...)
	endpoints := &mixPathServerEndpoints{
		svc:         svc,
		middlewares: options.Middlewares(),
	}
	transports := &mixPathGrpcServerTransports{
		endpoints: endpoints,
	}
	return &mixPathGrpcServer{
		mixPath: transports.MixPath(),
	}
}

func NewMixPathGrpcClient(target string, opts ...grpctransportx.ClientOption) MixPathService {
	options := grpctransportx.NewClientOptions(opts...)
	transports := &mixPathGrpcClientTransports{
		dialOptions:   options.DialOptions(),
		clientOptions: options.ClientTransportOptions(),
		middlewares:   options.Middlewares(),
	}
	factories := &mixPathFactories{
		transports: transports,
	}
	endpointer := &mixPathEndpointers{
		target:    target,
		builder:   options.Builder(),
		factories: factories,
		logger:    options.Logger(),
		options:   options.EndpointerOptions(),
	}
	balancers := &mixPathBalancers{
		factory:    options.BalancerFactory(),
		endpointer: endpointer,
	}
	endpoints := &mixPathClientEndpoints{
		balancers: balancers,
	}
	return &mixPathClientService{
		endpoints:     endpoints,
		transportName: grpctransportx.GrpcClient,
	}
}

type mixPathGrpcServerTransports struct {
	endpoints MixPathServerEndpoints
}

func (t *mixPathGrpcServerTransports) MixPath() grpc.Handler {
	return grpc.NewServer(
		t.endpoints.MixPath(context.TODO()),
		func(_ context.Context, v any) (any, error) { return v, nil },
		func(_ context.Context, v any) (any, error) { return v, nil },
		grpc.ServerBefore(grpctransportx.ServerEndpointInjector("/leo.example.route.path.MixPath/MixPath")),
		grpc.ServerBefore(grpctransportx.ServerTransportInjector),
		grpc.ServerBefore(metadatax.GrpcIncomingInjector),
		grpc.ServerBefore(stainx.GrpcIncomingInjector),
	)
}

type mixPathGrpcServer struct {
	mixPath grpc.Handler
}

func (s *mixPathGrpcServer) MixPath(ctx context.Context, request *MixPathRequest) (*emptypb.Empty, error) {
	ctx, rep, err := s.mixPath.ServeGRPC(ctx, request)
	if err != nil {
		return nil, err
	}
	_ = ctx
	return rep.(*emptypb.Empty), nil
}

func (s *mixPathGrpcServer) mustEmbedUnimplementedMixPathServer() {}

type mixPathGrpcClientTransports struct {
	dialOptions   []grpc1.DialOption
	clientOptions []grpc.ClientOption
	middlewares   []endpoint.Middleware
}

func (t *mixPathGrpcClientTransports) MixPath(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error) {
	conn, err := grpc1.NewClient(instance, t.dialOptions...)
	if err != nil {
		return nil, nil, err
	}
	opts := []grpc.ClientOption{
		grpc.ClientBefore(metadatax.GrpcOutgoingInjector),
		grpc.ClientBefore(stainx.GrpcOutgoingInjector),
	}
	opts = append(opts, t.clientOptions...)
	client := grpc.NewClient(
		conn,
		"leo.example.route.path.MixPath",
		"MixPath",
		func(_ context.Context, v any) (any, error) { return v, nil },
		func(_ context.Context, v any) (any, error) { return v, nil },
		emptypb.Empty{},
		opts...)
	return endpointx.Chain(client.Endpoint(), t.middlewares...), conn, nil
}
