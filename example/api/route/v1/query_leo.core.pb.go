// Code generated by protoc-gen-go-leo. DO NOT EDIT.

package route

import (
	context "context"
	endpoint "github.com/go-kit/kit/endpoint"
	sd "github.com/go-kit/kit/sd"
	lb "github.com/go-kit/kit/sd/lb"
	log "github.com/go-kit/log"
	lazyloadx "github.com/go-leo/gox/syncx/lazyloadx"
	endpointx "github.com/go-leo/leo/v3/endpointx"
	sdx "github.com/go-leo/leo/v3/sdx"
	lbx "github.com/go-leo/leo/v3/sdx/lbx"
	stainx "github.com/go-leo/leo/v3/stainx"
	transportx "github.com/go-leo/leo/v3/transportx"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	io "io"
)

// BoolQueryService is a service
type BoolQueryService interface {
	BoolQuery(ctx context.Context, request *BoolQueryRequest) (*emptypb.Empty, error)
}

// BoolQueryServerEndpoints is server endpoints
type BoolQueryServerEndpoints interface {
	BoolQuery(ctx context.Context) endpoint.Endpoint
}

// BoolQueryClientEndpoints is client endpoints
type BoolQueryClientEndpoints interface {
	BoolQuery(ctx context.Context) (endpoint.Endpoint, error)
}

// BoolQueryClientTransports is client transports
type BoolQueryClientTransports interface {
	BoolQuery(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error)
}

// BoolQueryFactories is client factories
type BoolQueryFactories interface {
	BoolQuery(ctx context.Context) sd.Factory
}

// BoolQueryEndpointers is client endpointers
type BoolQueryEndpointers interface {
	BoolQuery(ctx context.Context, color string) (sd.Endpointer, error)
}

// BoolQueryBalancers is client balancers
type BoolQueryBalancers interface {
	BoolQuery(ctx context.Context) (lb.Balancer, error)
}

// boolQueryServerEndpoints implements BoolQueryServerEndpoints
type boolQueryServerEndpoints struct {
	svc         BoolQueryService
	middlewares []endpoint.Middleware
}

func (e *boolQueryServerEndpoints) BoolQuery(context.Context) endpoint.Endpoint {
	component := func(ctx context.Context, request any) (any, error) {
		return e.svc.BoolQuery(ctx, request.(*BoolQueryRequest))
	}
	return endpointx.Chain(component, e.middlewares...)
}

// boolQueryFactories implements BoolQueryFactories
type boolQueryFactories struct {
	transports BoolQueryClientTransports
}

func (f *boolQueryFactories) BoolQuery(ctx context.Context) sd.Factory {
	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
		return f.transports.BoolQuery(ctx, instance)
	}
}

// boolQueryEndpointers implements BoolQueryEndpointers
type boolQueryEndpointers struct {
	target    string
	builder   sdx.Builder
	factories BoolQueryFactories
	logger    log.Logger
	options   []sd.EndpointerOption
}

func (e *boolQueryEndpointers) BoolQuery(ctx context.Context, color string) (sd.Endpointer, error) {
	return sdx.NewEndpointer(ctx, e.target, color, e.builder, e.factories.BoolQuery(ctx), e.logger, e.options...)
}

// boolQueryBalancers implements BoolQueryBalancers
type boolQueryBalancers struct {
	factory    lbx.BalancerFactory
	endpointer BoolQueryEndpointers
	boolQuery  lazyloadx.Group[lb.Balancer]
}

func (b *boolQueryBalancers) BoolQuery(ctx context.Context) (lb.Balancer, error) {
	color, _ := stainx.ColorExtractor(ctx)
	balancer, err, _ := b.boolQuery.LoadOrNew(color, lbx.NewBalancer(ctx, b.factory, b.endpointer.BoolQuery))
	return balancer, err
}
func newBoolQueryBalancers(factory lbx.BalancerFactory, endpointer BoolQueryEndpointers) BoolQueryBalancers {
	return &boolQueryBalancers{
		factory:    factory,
		endpointer: endpointer,
		boolQuery:  lazyloadx.Group[lb.Balancer]{},
	}
}

// boolQueryClientEndpoints implements BoolQueryClientEndpoints
type boolQueryClientEndpoints struct {
	balancers BoolQueryBalancers
}

func (e *boolQueryClientEndpoints) BoolQuery(ctx context.Context) (endpoint.Endpoint, error) {
	balancer, err := e.balancers.BoolQuery(ctx)
	if err != nil {
		return nil, err
	}
	return balancer.Endpoint()
}

// boolQueryClientService implements BoolQueryClientService
type boolQueryClientService struct {
	endpoints     BoolQueryClientEndpoints
	transportName string
}

func (c *boolQueryClientService) BoolQuery(ctx context.Context, request *BoolQueryRequest) (*emptypb.Empty, error) {
	ctx = endpointx.NameInjector(ctx, "/leo.example.route.query.BoolQuery/BoolQuery")
	ctx = transportx.NameInjector(ctx, c.transportName)
	endpoint, err := c.endpoints.BoolQuery(ctx)
	if err != nil {
		return nil, err
	}
	rep, err := endpoint(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

// Int32QueryService is a service
type Int32QueryService interface {
	Int32Query(ctx context.Context, request *Int32QueryRequest) (*emptypb.Empty, error)
}

// Int32QueryServerEndpoints is server endpoints
type Int32QueryServerEndpoints interface {
	Int32Query(ctx context.Context) endpoint.Endpoint
}

// Int32QueryClientEndpoints is client endpoints
type Int32QueryClientEndpoints interface {
	Int32Query(ctx context.Context) (endpoint.Endpoint, error)
}

// Int32QueryClientTransports is client transports
type Int32QueryClientTransports interface {
	Int32Query(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error)
}

// Int32QueryFactories is client factories
type Int32QueryFactories interface {
	Int32Query(ctx context.Context) sd.Factory
}

// Int32QueryEndpointers is client endpointers
type Int32QueryEndpointers interface {
	Int32Query(ctx context.Context, color string) (sd.Endpointer, error)
}

// Int32QueryBalancers is client balancers
type Int32QueryBalancers interface {
	Int32Query(ctx context.Context) (lb.Balancer, error)
}

// int32QueryServerEndpoints implements Int32QueryServerEndpoints
type int32QueryServerEndpoints struct {
	svc         Int32QueryService
	middlewares []endpoint.Middleware
}

func (e *int32QueryServerEndpoints) Int32Query(context.Context) endpoint.Endpoint {
	component := func(ctx context.Context, request any) (any, error) {
		return e.svc.Int32Query(ctx, request.(*Int32QueryRequest))
	}
	return endpointx.Chain(component, e.middlewares...)
}

// int32QueryFactories implements Int32QueryFactories
type int32QueryFactories struct {
	transports Int32QueryClientTransports
}

func (f *int32QueryFactories) Int32Query(ctx context.Context) sd.Factory {
	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
		return f.transports.Int32Query(ctx, instance)
	}
}

// int32QueryEndpointers implements Int32QueryEndpointers
type int32QueryEndpointers struct {
	target    string
	builder   sdx.Builder
	factories Int32QueryFactories
	logger    log.Logger
	options   []sd.EndpointerOption
}

func (e *int32QueryEndpointers) Int32Query(ctx context.Context, color string) (sd.Endpointer, error) {
	return sdx.NewEndpointer(ctx, e.target, color, e.builder, e.factories.Int32Query(ctx), e.logger, e.options...)
}

// int32QueryBalancers implements Int32QueryBalancers
type int32QueryBalancers struct {
	factory    lbx.BalancerFactory
	endpointer Int32QueryEndpointers
	int32Query lazyloadx.Group[lb.Balancer]
}

func (b *int32QueryBalancers) Int32Query(ctx context.Context) (lb.Balancer, error) {
	color, _ := stainx.ColorExtractor(ctx)
	balancer, err, _ := b.int32Query.LoadOrNew(color, lbx.NewBalancer(ctx, b.factory, b.endpointer.Int32Query))
	return balancer, err
}
func newInt32QueryBalancers(factory lbx.BalancerFactory, endpointer Int32QueryEndpointers) Int32QueryBalancers {
	return &int32QueryBalancers{
		factory:    factory,
		endpointer: endpointer,
		int32Query: lazyloadx.Group[lb.Balancer]{},
	}
}

// int32QueryClientEndpoints implements Int32QueryClientEndpoints
type int32QueryClientEndpoints struct {
	balancers Int32QueryBalancers
}

func (e *int32QueryClientEndpoints) Int32Query(ctx context.Context) (endpoint.Endpoint, error) {
	balancer, err := e.balancers.Int32Query(ctx)
	if err != nil {
		return nil, err
	}
	return balancer.Endpoint()
}

// int32QueryClientService implements Int32QueryClientService
type int32QueryClientService struct {
	endpoints     Int32QueryClientEndpoints
	transportName string
}

func (c *int32QueryClientService) Int32Query(ctx context.Context, request *Int32QueryRequest) (*emptypb.Empty, error) {
	ctx = endpointx.NameInjector(ctx, "/leo.example.route.query.Int32Query/Int32Query")
	ctx = transportx.NameInjector(ctx, c.transportName)
	endpoint, err := c.endpoints.Int32Query(ctx)
	if err != nil {
		return nil, err
	}
	rep, err := endpoint(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

// Int64QueryService is a service
type Int64QueryService interface {
	Int64Query(ctx context.Context, request *Int64QueryRequest) (*emptypb.Empty, error)
}

// Int64QueryServerEndpoints is server endpoints
type Int64QueryServerEndpoints interface {
	Int64Query(ctx context.Context) endpoint.Endpoint
}

// Int64QueryClientEndpoints is client endpoints
type Int64QueryClientEndpoints interface {
	Int64Query(ctx context.Context) (endpoint.Endpoint, error)
}

// Int64QueryClientTransports is client transports
type Int64QueryClientTransports interface {
	Int64Query(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error)
}

// Int64QueryFactories is client factories
type Int64QueryFactories interface {
	Int64Query(ctx context.Context) sd.Factory
}

// Int64QueryEndpointers is client endpointers
type Int64QueryEndpointers interface {
	Int64Query(ctx context.Context, color string) (sd.Endpointer, error)
}

// Int64QueryBalancers is client balancers
type Int64QueryBalancers interface {
	Int64Query(ctx context.Context) (lb.Balancer, error)
}

// int64QueryServerEndpoints implements Int64QueryServerEndpoints
type int64QueryServerEndpoints struct {
	svc         Int64QueryService
	middlewares []endpoint.Middleware
}

func (e *int64QueryServerEndpoints) Int64Query(context.Context) endpoint.Endpoint {
	component := func(ctx context.Context, request any) (any, error) {
		return e.svc.Int64Query(ctx, request.(*Int64QueryRequest))
	}
	return endpointx.Chain(component, e.middlewares...)
}

// int64QueryFactories implements Int64QueryFactories
type int64QueryFactories struct {
	transports Int64QueryClientTransports
}

func (f *int64QueryFactories) Int64Query(ctx context.Context) sd.Factory {
	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
		return f.transports.Int64Query(ctx, instance)
	}
}

// int64QueryEndpointers implements Int64QueryEndpointers
type int64QueryEndpointers struct {
	target    string
	builder   sdx.Builder
	factories Int64QueryFactories
	logger    log.Logger
	options   []sd.EndpointerOption
}

func (e *int64QueryEndpointers) Int64Query(ctx context.Context, color string) (sd.Endpointer, error) {
	return sdx.NewEndpointer(ctx, e.target, color, e.builder, e.factories.Int64Query(ctx), e.logger, e.options...)
}

// int64QueryBalancers implements Int64QueryBalancers
type int64QueryBalancers struct {
	factory    lbx.BalancerFactory
	endpointer Int64QueryEndpointers
	int64Query lazyloadx.Group[lb.Balancer]
}

func (b *int64QueryBalancers) Int64Query(ctx context.Context) (lb.Balancer, error) {
	color, _ := stainx.ColorExtractor(ctx)
	balancer, err, _ := b.int64Query.LoadOrNew(color, lbx.NewBalancer(ctx, b.factory, b.endpointer.Int64Query))
	return balancer, err
}
func newInt64QueryBalancers(factory lbx.BalancerFactory, endpointer Int64QueryEndpointers) Int64QueryBalancers {
	return &int64QueryBalancers{
		factory:    factory,
		endpointer: endpointer,
		int64Query: lazyloadx.Group[lb.Balancer]{},
	}
}

// int64QueryClientEndpoints implements Int64QueryClientEndpoints
type int64QueryClientEndpoints struct {
	balancers Int64QueryBalancers
}

func (e *int64QueryClientEndpoints) Int64Query(ctx context.Context) (endpoint.Endpoint, error) {
	balancer, err := e.balancers.Int64Query(ctx)
	if err != nil {
		return nil, err
	}
	return balancer.Endpoint()
}

// int64QueryClientService implements Int64QueryClientService
type int64QueryClientService struct {
	endpoints     Int64QueryClientEndpoints
	transportName string
}

func (c *int64QueryClientService) Int64Query(ctx context.Context, request *Int64QueryRequest) (*emptypb.Empty, error) {
	ctx = endpointx.NameInjector(ctx, "/leo.example.route.query.Int64Query/Int64Query")
	ctx = transportx.NameInjector(ctx, c.transportName)
	endpoint, err := c.endpoints.Int64Query(ctx)
	if err != nil {
		return nil, err
	}
	rep, err := endpoint(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

// Uint32QueryService is a service
type Uint32QueryService interface {
	Uint32Query(ctx context.Context, request *Uint32QueryRequest) (*emptypb.Empty, error)
}

// Uint32QueryServerEndpoints is server endpoints
type Uint32QueryServerEndpoints interface {
	Uint32Query(ctx context.Context) endpoint.Endpoint
}

// Uint32QueryClientEndpoints is client endpoints
type Uint32QueryClientEndpoints interface {
	Uint32Query(ctx context.Context) (endpoint.Endpoint, error)
}

// Uint32QueryClientTransports is client transports
type Uint32QueryClientTransports interface {
	Uint32Query(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error)
}

// Uint32QueryFactories is client factories
type Uint32QueryFactories interface {
	Uint32Query(ctx context.Context) sd.Factory
}

// Uint32QueryEndpointers is client endpointers
type Uint32QueryEndpointers interface {
	Uint32Query(ctx context.Context, color string) (sd.Endpointer, error)
}

// Uint32QueryBalancers is client balancers
type Uint32QueryBalancers interface {
	Uint32Query(ctx context.Context) (lb.Balancer, error)
}

// uint32QueryServerEndpoints implements Uint32QueryServerEndpoints
type uint32QueryServerEndpoints struct {
	svc         Uint32QueryService
	middlewares []endpoint.Middleware
}

func (e *uint32QueryServerEndpoints) Uint32Query(context.Context) endpoint.Endpoint {
	component := func(ctx context.Context, request any) (any, error) {
		return e.svc.Uint32Query(ctx, request.(*Uint32QueryRequest))
	}
	return endpointx.Chain(component, e.middlewares...)
}

// uint32QueryFactories implements Uint32QueryFactories
type uint32QueryFactories struct {
	transports Uint32QueryClientTransports
}

func (f *uint32QueryFactories) Uint32Query(ctx context.Context) sd.Factory {
	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
		return f.transports.Uint32Query(ctx, instance)
	}
}

// uint32QueryEndpointers implements Uint32QueryEndpointers
type uint32QueryEndpointers struct {
	target    string
	builder   sdx.Builder
	factories Uint32QueryFactories
	logger    log.Logger
	options   []sd.EndpointerOption
}

func (e *uint32QueryEndpointers) Uint32Query(ctx context.Context, color string) (sd.Endpointer, error) {
	return sdx.NewEndpointer(ctx, e.target, color, e.builder, e.factories.Uint32Query(ctx), e.logger, e.options...)
}

// uint32QueryBalancers implements Uint32QueryBalancers
type uint32QueryBalancers struct {
	factory     lbx.BalancerFactory
	endpointer  Uint32QueryEndpointers
	uint32Query lazyloadx.Group[lb.Balancer]
}

func (b *uint32QueryBalancers) Uint32Query(ctx context.Context) (lb.Balancer, error) {
	color, _ := stainx.ColorExtractor(ctx)
	balancer, err, _ := b.uint32Query.LoadOrNew(color, lbx.NewBalancer(ctx, b.factory, b.endpointer.Uint32Query))
	return balancer, err
}
func newUint32QueryBalancers(factory lbx.BalancerFactory, endpointer Uint32QueryEndpointers) Uint32QueryBalancers {
	return &uint32QueryBalancers{
		factory:     factory,
		endpointer:  endpointer,
		uint32Query: lazyloadx.Group[lb.Balancer]{},
	}
}

// uint32QueryClientEndpoints implements Uint32QueryClientEndpoints
type uint32QueryClientEndpoints struct {
	balancers Uint32QueryBalancers
}

func (e *uint32QueryClientEndpoints) Uint32Query(ctx context.Context) (endpoint.Endpoint, error) {
	balancer, err := e.balancers.Uint32Query(ctx)
	if err != nil {
		return nil, err
	}
	return balancer.Endpoint()
}

// uint32QueryClientService implements Uint32QueryClientService
type uint32QueryClientService struct {
	endpoints     Uint32QueryClientEndpoints
	transportName string
}

func (c *uint32QueryClientService) Uint32Query(ctx context.Context, request *Uint32QueryRequest) (*emptypb.Empty, error) {
	ctx = endpointx.NameInjector(ctx, "/leo.example.route.query.Uint32Query/Uint32Query")
	ctx = transportx.NameInjector(ctx, c.transportName)
	endpoint, err := c.endpoints.Uint32Query(ctx)
	if err != nil {
		return nil, err
	}
	rep, err := endpoint(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

// Uint64QueryService is a service
type Uint64QueryService interface {
	Uint64Query(ctx context.Context, request *Uint64QueryRequest) (*emptypb.Empty, error)
}

// Uint64QueryServerEndpoints is server endpoints
type Uint64QueryServerEndpoints interface {
	Uint64Query(ctx context.Context) endpoint.Endpoint
}

// Uint64QueryClientEndpoints is client endpoints
type Uint64QueryClientEndpoints interface {
	Uint64Query(ctx context.Context) (endpoint.Endpoint, error)
}

// Uint64QueryClientTransports is client transports
type Uint64QueryClientTransports interface {
	Uint64Query(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error)
}

// Uint64QueryFactories is client factories
type Uint64QueryFactories interface {
	Uint64Query(ctx context.Context) sd.Factory
}

// Uint64QueryEndpointers is client endpointers
type Uint64QueryEndpointers interface {
	Uint64Query(ctx context.Context, color string) (sd.Endpointer, error)
}

// Uint64QueryBalancers is client balancers
type Uint64QueryBalancers interface {
	Uint64Query(ctx context.Context) (lb.Balancer, error)
}

// uint64QueryServerEndpoints implements Uint64QueryServerEndpoints
type uint64QueryServerEndpoints struct {
	svc         Uint64QueryService
	middlewares []endpoint.Middleware
}

func (e *uint64QueryServerEndpoints) Uint64Query(context.Context) endpoint.Endpoint {
	component := func(ctx context.Context, request any) (any, error) {
		return e.svc.Uint64Query(ctx, request.(*Uint64QueryRequest))
	}
	return endpointx.Chain(component, e.middlewares...)
}

// uint64QueryFactories implements Uint64QueryFactories
type uint64QueryFactories struct {
	transports Uint64QueryClientTransports
}

func (f *uint64QueryFactories) Uint64Query(ctx context.Context) sd.Factory {
	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
		return f.transports.Uint64Query(ctx, instance)
	}
}

// uint64QueryEndpointers implements Uint64QueryEndpointers
type uint64QueryEndpointers struct {
	target    string
	builder   sdx.Builder
	factories Uint64QueryFactories
	logger    log.Logger
	options   []sd.EndpointerOption
}

func (e *uint64QueryEndpointers) Uint64Query(ctx context.Context, color string) (sd.Endpointer, error) {
	return sdx.NewEndpointer(ctx, e.target, color, e.builder, e.factories.Uint64Query(ctx), e.logger, e.options...)
}

// uint64QueryBalancers implements Uint64QueryBalancers
type uint64QueryBalancers struct {
	factory     lbx.BalancerFactory
	endpointer  Uint64QueryEndpointers
	uint64Query lazyloadx.Group[lb.Balancer]
}

func (b *uint64QueryBalancers) Uint64Query(ctx context.Context) (lb.Balancer, error) {
	color, _ := stainx.ColorExtractor(ctx)
	balancer, err, _ := b.uint64Query.LoadOrNew(color, lbx.NewBalancer(ctx, b.factory, b.endpointer.Uint64Query))
	return balancer, err
}
func newUint64QueryBalancers(factory lbx.BalancerFactory, endpointer Uint64QueryEndpointers) Uint64QueryBalancers {
	return &uint64QueryBalancers{
		factory:     factory,
		endpointer:  endpointer,
		uint64Query: lazyloadx.Group[lb.Balancer]{},
	}
}

// uint64QueryClientEndpoints implements Uint64QueryClientEndpoints
type uint64QueryClientEndpoints struct {
	balancers Uint64QueryBalancers
}

func (e *uint64QueryClientEndpoints) Uint64Query(ctx context.Context) (endpoint.Endpoint, error) {
	balancer, err := e.balancers.Uint64Query(ctx)
	if err != nil {
		return nil, err
	}
	return balancer.Endpoint()
}

// uint64QueryClientService implements Uint64QueryClientService
type uint64QueryClientService struct {
	endpoints     Uint64QueryClientEndpoints
	transportName string
}

func (c *uint64QueryClientService) Uint64Query(ctx context.Context, request *Uint64QueryRequest) (*emptypb.Empty, error) {
	ctx = endpointx.NameInjector(ctx, "/leo.example.route.query.Uint64Query/Uint64Query")
	ctx = transportx.NameInjector(ctx, c.transportName)
	endpoint, err := c.endpoints.Uint64Query(ctx)
	if err != nil {
		return nil, err
	}
	rep, err := endpoint(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

// FloatQueryService is a service
type FloatQueryService interface {
	FloatQuery(ctx context.Context, request *FloatQueryRequest) (*emptypb.Empty, error)
}

// FloatQueryServerEndpoints is server endpoints
type FloatQueryServerEndpoints interface {
	FloatQuery(ctx context.Context) endpoint.Endpoint
}

// FloatQueryClientEndpoints is client endpoints
type FloatQueryClientEndpoints interface {
	FloatQuery(ctx context.Context) (endpoint.Endpoint, error)
}

// FloatQueryClientTransports is client transports
type FloatQueryClientTransports interface {
	FloatQuery(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error)
}

// FloatQueryFactories is client factories
type FloatQueryFactories interface {
	FloatQuery(ctx context.Context) sd.Factory
}

// FloatQueryEndpointers is client endpointers
type FloatQueryEndpointers interface {
	FloatQuery(ctx context.Context, color string) (sd.Endpointer, error)
}

// FloatQueryBalancers is client balancers
type FloatQueryBalancers interface {
	FloatQuery(ctx context.Context) (lb.Balancer, error)
}

// floatQueryServerEndpoints implements FloatQueryServerEndpoints
type floatQueryServerEndpoints struct {
	svc         FloatQueryService
	middlewares []endpoint.Middleware
}

func (e *floatQueryServerEndpoints) FloatQuery(context.Context) endpoint.Endpoint {
	component := func(ctx context.Context, request any) (any, error) {
		return e.svc.FloatQuery(ctx, request.(*FloatQueryRequest))
	}
	return endpointx.Chain(component, e.middlewares...)
}

// floatQueryFactories implements FloatQueryFactories
type floatQueryFactories struct {
	transports FloatQueryClientTransports
}

func (f *floatQueryFactories) FloatQuery(ctx context.Context) sd.Factory {
	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
		return f.transports.FloatQuery(ctx, instance)
	}
}

// floatQueryEndpointers implements FloatQueryEndpointers
type floatQueryEndpointers struct {
	target    string
	builder   sdx.Builder
	factories FloatQueryFactories
	logger    log.Logger
	options   []sd.EndpointerOption
}

func (e *floatQueryEndpointers) FloatQuery(ctx context.Context, color string) (sd.Endpointer, error) {
	return sdx.NewEndpointer(ctx, e.target, color, e.builder, e.factories.FloatQuery(ctx), e.logger, e.options...)
}

// floatQueryBalancers implements FloatQueryBalancers
type floatQueryBalancers struct {
	factory    lbx.BalancerFactory
	endpointer FloatQueryEndpointers
	floatQuery lazyloadx.Group[lb.Balancer]
}

func (b *floatQueryBalancers) FloatQuery(ctx context.Context) (lb.Balancer, error) {
	color, _ := stainx.ColorExtractor(ctx)
	balancer, err, _ := b.floatQuery.LoadOrNew(color, lbx.NewBalancer(ctx, b.factory, b.endpointer.FloatQuery))
	return balancer, err
}
func newFloatQueryBalancers(factory lbx.BalancerFactory, endpointer FloatQueryEndpointers) FloatQueryBalancers {
	return &floatQueryBalancers{
		factory:    factory,
		endpointer: endpointer,
		floatQuery: lazyloadx.Group[lb.Balancer]{},
	}
}

// floatQueryClientEndpoints implements FloatQueryClientEndpoints
type floatQueryClientEndpoints struct {
	balancers FloatQueryBalancers
}

func (e *floatQueryClientEndpoints) FloatQuery(ctx context.Context) (endpoint.Endpoint, error) {
	balancer, err := e.balancers.FloatQuery(ctx)
	if err != nil {
		return nil, err
	}
	return balancer.Endpoint()
}

// floatQueryClientService implements FloatQueryClientService
type floatQueryClientService struct {
	endpoints     FloatQueryClientEndpoints
	transportName string
}

func (c *floatQueryClientService) FloatQuery(ctx context.Context, request *FloatQueryRequest) (*emptypb.Empty, error) {
	ctx = endpointx.NameInjector(ctx, "/leo.example.route.query.FloatQuery/FloatQuery")
	ctx = transportx.NameInjector(ctx, c.transportName)
	endpoint, err := c.endpoints.FloatQuery(ctx)
	if err != nil {
		return nil, err
	}
	rep, err := endpoint(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

// DoubleQueryService is a service
type DoubleQueryService interface {
	DoubleQuery(ctx context.Context, request *DoubleQueryRequest) (*emptypb.Empty, error)
}

// DoubleQueryServerEndpoints is server endpoints
type DoubleQueryServerEndpoints interface {
	DoubleQuery(ctx context.Context) endpoint.Endpoint
}

// DoubleQueryClientEndpoints is client endpoints
type DoubleQueryClientEndpoints interface {
	DoubleQuery(ctx context.Context) (endpoint.Endpoint, error)
}

// DoubleQueryClientTransports is client transports
type DoubleQueryClientTransports interface {
	DoubleQuery(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error)
}

// DoubleQueryFactories is client factories
type DoubleQueryFactories interface {
	DoubleQuery(ctx context.Context) sd.Factory
}

// DoubleQueryEndpointers is client endpointers
type DoubleQueryEndpointers interface {
	DoubleQuery(ctx context.Context, color string) (sd.Endpointer, error)
}

// DoubleQueryBalancers is client balancers
type DoubleQueryBalancers interface {
	DoubleQuery(ctx context.Context) (lb.Balancer, error)
}

// doubleQueryServerEndpoints implements DoubleQueryServerEndpoints
type doubleQueryServerEndpoints struct {
	svc         DoubleQueryService
	middlewares []endpoint.Middleware
}

func (e *doubleQueryServerEndpoints) DoubleQuery(context.Context) endpoint.Endpoint {
	component := func(ctx context.Context, request any) (any, error) {
		return e.svc.DoubleQuery(ctx, request.(*DoubleQueryRequest))
	}
	return endpointx.Chain(component, e.middlewares...)
}

// doubleQueryFactories implements DoubleQueryFactories
type doubleQueryFactories struct {
	transports DoubleQueryClientTransports
}

func (f *doubleQueryFactories) DoubleQuery(ctx context.Context) sd.Factory {
	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
		return f.transports.DoubleQuery(ctx, instance)
	}
}

// doubleQueryEndpointers implements DoubleQueryEndpointers
type doubleQueryEndpointers struct {
	target    string
	builder   sdx.Builder
	factories DoubleQueryFactories
	logger    log.Logger
	options   []sd.EndpointerOption
}

func (e *doubleQueryEndpointers) DoubleQuery(ctx context.Context, color string) (sd.Endpointer, error) {
	return sdx.NewEndpointer(ctx, e.target, color, e.builder, e.factories.DoubleQuery(ctx), e.logger, e.options...)
}

// doubleQueryBalancers implements DoubleQueryBalancers
type doubleQueryBalancers struct {
	factory     lbx.BalancerFactory
	endpointer  DoubleQueryEndpointers
	doubleQuery lazyloadx.Group[lb.Balancer]
}

func (b *doubleQueryBalancers) DoubleQuery(ctx context.Context) (lb.Balancer, error) {
	color, _ := stainx.ColorExtractor(ctx)
	balancer, err, _ := b.doubleQuery.LoadOrNew(color, lbx.NewBalancer(ctx, b.factory, b.endpointer.DoubleQuery))
	return balancer, err
}
func newDoubleQueryBalancers(factory lbx.BalancerFactory, endpointer DoubleQueryEndpointers) DoubleQueryBalancers {
	return &doubleQueryBalancers{
		factory:     factory,
		endpointer:  endpointer,
		doubleQuery: lazyloadx.Group[lb.Balancer]{},
	}
}

// doubleQueryClientEndpoints implements DoubleQueryClientEndpoints
type doubleQueryClientEndpoints struct {
	balancers DoubleQueryBalancers
}

func (e *doubleQueryClientEndpoints) DoubleQuery(ctx context.Context) (endpoint.Endpoint, error) {
	balancer, err := e.balancers.DoubleQuery(ctx)
	if err != nil {
		return nil, err
	}
	return balancer.Endpoint()
}

// doubleQueryClientService implements DoubleQueryClientService
type doubleQueryClientService struct {
	endpoints     DoubleQueryClientEndpoints
	transportName string
}

func (c *doubleQueryClientService) DoubleQuery(ctx context.Context, request *DoubleQueryRequest) (*emptypb.Empty, error) {
	ctx = endpointx.NameInjector(ctx, "/leo.example.route.query.DoubleQuery/DoubleQuery")
	ctx = transportx.NameInjector(ctx, c.transportName)
	endpoint, err := c.endpoints.DoubleQuery(ctx)
	if err != nil {
		return nil, err
	}
	rep, err := endpoint(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

// StringQueryService is a service
type StringQueryService interface {
	StringQuery(ctx context.Context, request *StringQueryRequest) (*emptypb.Empty, error)
}

// StringQueryServerEndpoints is server endpoints
type StringQueryServerEndpoints interface {
	StringQuery(ctx context.Context) endpoint.Endpoint
}

// StringQueryClientEndpoints is client endpoints
type StringQueryClientEndpoints interface {
	StringQuery(ctx context.Context) (endpoint.Endpoint, error)
}

// StringQueryClientTransports is client transports
type StringQueryClientTransports interface {
	StringQuery(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error)
}

// StringQueryFactories is client factories
type StringQueryFactories interface {
	StringQuery(ctx context.Context) sd.Factory
}

// StringQueryEndpointers is client endpointers
type StringQueryEndpointers interface {
	StringQuery(ctx context.Context, color string) (sd.Endpointer, error)
}

// StringQueryBalancers is client balancers
type StringQueryBalancers interface {
	StringQuery(ctx context.Context) (lb.Balancer, error)
}

// stringQueryServerEndpoints implements StringQueryServerEndpoints
type stringQueryServerEndpoints struct {
	svc         StringQueryService
	middlewares []endpoint.Middleware
}

func (e *stringQueryServerEndpoints) StringQuery(context.Context) endpoint.Endpoint {
	component := func(ctx context.Context, request any) (any, error) {
		return e.svc.StringQuery(ctx, request.(*StringQueryRequest))
	}
	return endpointx.Chain(component, e.middlewares...)
}

// stringQueryFactories implements StringQueryFactories
type stringQueryFactories struct {
	transports StringQueryClientTransports
}

func (f *stringQueryFactories) StringQuery(ctx context.Context) sd.Factory {
	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
		return f.transports.StringQuery(ctx, instance)
	}
}

// stringQueryEndpointers implements StringQueryEndpointers
type stringQueryEndpointers struct {
	target    string
	builder   sdx.Builder
	factories StringQueryFactories
	logger    log.Logger
	options   []sd.EndpointerOption
}

func (e *stringQueryEndpointers) StringQuery(ctx context.Context, color string) (sd.Endpointer, error) {
	return sdx.NewEndpointer(ctx, e.target, color, e.builder, e.factories.StringQuery(ctx), e.logger, e.options...)
}

// stringQueryBalancers implements StringQueryBalancers
type stringQueryBalancers struct {
	factory     lbx.BalancerFactory
	endpointer  StringQueryEndpointers
	stringQuery lazyloadx.Group[lb.Balancer]
}

func (b *stringQueryBalancers) StringQuery(ctx context.Context) (lb.Balancer, error) {
	color, _ := stainx.ColorExtractor(ctx)
	balancer, err, _ := b.stringQuery.LoadOrNew(color, lbx.NewBalancer(ctx, b.factory, b.endpointer.StringQuery))
	return balancer, err
}
func newStringQueryBalancers(factory lbx.BalancerFactory, endpointer StringQueryEndpointers) StringQueryBalancers {
	return &stringQueryBalancers{
		factory:     factory,
		endpointer:  endpointer,
		stringQuery: lazyloadx.Group[lb.Balancer]{},
	}
}

// stringQueryClientEndpoints implements StringQueryClientEndpoints
type stringQueryClientEndpoints struct {
	balancers StringQueryBalancers
}

func (e *stringQueryClientEndpoints) StringQuery(ctx context.Context) (endpoint.Endpoint, error) {
	balancer, err := e.balancers.StringQuery(ctx)
	if err != nil {
		return nil, err
	}
	return balancer.Endpoint()
}

// stringQueryClientService implements StringQueryClientService
type stringQueryClientService struct {
	endpoints     StringQueryClientEndpoints
	transportName string
}

func (c *stringQueryClientService) StringQuery(ctx context.Context, request *StringQueryRequest) (*emptypb.Empty, error) {
	ctx = endpointx.NameInjector(ctx, "/leo.example.route.query.StringQuery/StringQuery")
	ctx = transportx.NameInjector(ctx, c.transportName)
	endpoint, err := c.endpoints.StringQuery(ctx)
	if err != nil {
		return nil, err
	}
	rep, err := endpoint(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}

// EnumQueryService is a service
type EnumQueryService interface {
	EnumQuery(ctx context.Context, request *EnumQueryRequest) (*emptypb.Empty, error)
}

// EnumQueryServerEndpoints is server endpoints
type EnumQueryServerEndpoints interface {
	EnumQuery(ctx context.Context) endpoint.Endpoint
}

// EnumQueryClientEndpoints is client endpoints
type EnumQueryClientEndpoints interface {
	EnumQuery(ctx context.Context) (endpoint.Endpoint, error)
}

// EnumQueryClientTransports is client transports
type EnumQueryClientTransports interface {
	EnumQuery(ctx context.Context, instance string) (endpoint.Endpoint, io.Closer, error)
}

// EnumQueryFactories is client factories
type EnumQueryFactories interface {
	EnumQuery(ctx context.Context) sd.Factory
}

// EnumQueryEndpointers is client endpointers
type EnumQueryEndpointers interface {
	EnumQuery(ctx context.Context, color string) (sd.Endpointer, error)
}

// EnumQueryBalancers is client balancers
type EnumQueryBalancers interface {
	EnumQuery(ctx context.Context) (lb.Balancer, error)
}

// enumQueryServerEndpoints implements EnumQueryServerEndpoints
type enumQueryServerEndpoints struct {
	svc         EnumQueryService
	middlewares []endpoint.Middleware
}

func (e *enumQueryServerEndpoints) EnumQuery(context.Context) endpoint.Endpoint {
	component := func(ctx context.Context, request any) (any, error) {
		return e.svc.EnumQuery(ctx, request.(*EnumQueryRequest))
	}
	return endpointx.Chain(component, e.middlewares...)
}

// enumQueryFactories implements EnumQueryFactories
type enumQueryFactories struct {
	transports EnumQueryClientTransports
}

func (f *enumQueryFactories) EnumQuery(ctx context.Context) sd.Factory {
	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
		return f.transports.EnumQuery(ctx, instance)
	}
}

// enumQueryEndpointers implements EnumQueryEndpointers
type enumQueryEndpointers struct {
	target    string
	builder   sdx.Builder
	factories EnumQueryFactories
	logger    log.Logger
	options   []sd.EndpointerOption
}

func (e *enumQueryEndpointers) EnumQuery(ctx context.Context, color string) (sd.Endpointer, error) {
	return sdx.NewEndpointer(ctx, e.target, color, e.builder, e.factories.EnumQuery(ctx), e.logger, e.options...)
}

// enumQueryBalancers implements EnumQueryBalancers
type enumQueryBalancers struct {
	factory    lbx.BalancerFactory
	endpointer EnumQueryEndpointers
	enumQuery  lazyloadx.Group[lb.Balancer]
}

func (b *enumQueryBalancers) EnumQuery(ctx context.Context) (lb.Balancer, error) {
	color, _ := stainx.ColorExtractor(ctx)
	balancer, err, _ := b.enumQuery.LoadOrNew(color, lbx.NewBalancer(ctx, b.factory, b.endpointer.EnumQuery))
	return balancer, err
}
func newEnumQueryBalancers(factory lbx.BalancerFactory, endpointer EnumQueryEndpointers) EnumQueryBalancers {
	return &enumQueryBalancers{
		factory:    factory,
		endpointer: endpointer,
		enumQuery:  lazyloadx.Group[lb.Balancer]{},
	}
}

// enumQueryClientEndpoints implements EnumQueryClientEndpoints
type enumQueryClientEndpoints struct {
	balancers EnumQueryBalancers
}

func (e *enumQueryClientEndpoints) EnumQuery(ctx context.Context) (endpoint.Endpoint, error) {
	balancer, err := e.balancers.EnumQuery(ctx)
	if err != nil {
		return nil, err
	}
	return balancer.Endpoint()
}

// enumQueryClientService implements EnumQueryClientService
type enumQueryClientService struct {
	endpoints     EnumQueryClientEndpoints
	transportName string
}

func (c *enumQueryClientService) EnumQuery(ctx context.Context, request *EnumQueryRequest) (*emptypb.Empty, error) {
	ctx = endpointx.NameInjector(ctx, "/leo.example.route.query.EnumQuery/EnumQuery")
	ctx = transportx.NameInjector(ctx, c.transportName)
	endpoint, err := c.endpoints.EnumQuery(ctx)
	if err != nil {
		return nil, err
	}
	rep, err := endpoint(ctx, request)
	if err != nil {
		return nil, err
	}
	return rep.(*emptypb.Empty), nil
}
