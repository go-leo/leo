// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v5.29.3
// source: route/v1/query.proto

package route

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	BoolQuery_BoolQuery_FullMethodName = "/leo.example.route.query.BoolQuery/BoolQuery"
)

// BoolQueryClient is the client API for BoolQuery service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BoolQueryClient interface {
	BoolQuery(ctx context.Context, in *BoolQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type boolQueryClient struct {
	cc grpc.ClientConnInterface
}

func NewBoolQueryClient(cc grpc.ClientConnInterface) BoolQueryClient {
	return &boolQueryClient{cc}
}

func (c *boolQueryClient) BoolQuery(ctx context.Context, in *BoolQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, BoolQuery_BoolQuery_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BoolQueryServer is the server API for BoolQuery service.
// All implementations must embed UnimplementedBoolQueryServer
// for forward compatibility
type BoolQueryServer interface {
	BoolQuery(context.Context, *BoolQueryRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedBoolQueryServer()
}

// UnimplementedBoolQueryServer must be embedded to have forward compatible implementations.
type UnimplementedBoolQueryServer struct {
}

func (UnimplementedBoolQueryServer) BoolQuery(context.Context, *BoolQueryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoolQuery not implemented")
}
func (UnimplementedBoolQueryServer) mustEmbedUnimplementedBoolQueryServer() {}

// UnsafeBoolQueryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BoolQueryServer will
// result in compilation errors.
type UnsafeBoolQueryServer interface {
	mustEmbedUnimplementedBoolQueryServer()
}

func RegisterBoolQueryServer(s grpc.ServiceRegistrar, srv BoolQueryServer) {
	s.RegisterService(&BoolQuery_ServiceDesc, srv)
}

func _BoolQuery_BoolQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoolQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoolQueryServer).BoolQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BoolQuery_BoolQuery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoolQueryServer).BoolQuery(ctx, req.(*BoolQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BoolQuery_ServiceDesc is the grpc.ServiceDesc for BoolQuery service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BoolQuery_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "leo.example.route.query.BoolQuery",
	HandlerType: (*BoolQueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BoolQuery",
			Handler:    _BoolQuery_BoolQuery_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "route/v1/query.proto",
}

const (
	Int32Query_Int32Query_FullMethodName = "/leo.example.route.query.Int32Query/Int32Query"
)

// Int32QueryClient is the client API for Int32Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Int32QueryClient interface {
	Int32Query(ctx context.Context, in *Int32QueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type int32QueryClient struct {
	cc grpc.ClientConnInterface
}

func NewInt32QueryClient(cc grpc.ClientConnInterface) Int32QueryClient {
	return &int32QueryClient{cc}
}

func (c *int32QueryClient) Int32Query(ctx context.Context, in *Int32QueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Int32Query_Int32Query_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Int32QueryServer is the server API for Int32Query service.
// All implementations must embed UnimplementedInt32QueryServer
// for forward compatibility
type Int32QueryServer interface {
	Int32Query(context.Context, *Int32QueryRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedInt32QueryServer()
}

// UnimplementedInt32QueryServer must be embedded to have forward compatible implementations.
type UnimplementedInt32QueryServer struct {
}

func (UnimplementedInt32QueryServer) Int32Query(context.Context, *Int32QueryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Int32Query not implemented")
}
func (UnimplementedInt32QueryServer) mustEmbedUnimplementedInt32QueryServer() {}

// UnsafeInt32QueryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Int32QueryServer will
// result in compilation errors.
type UnsafeInt32QueryServer interface {
	mustEmbedUnimplementedInt32QueryServer()
}

func RegisterInt32QueryServer(s grpc.ServiceRegistrar, srv Int32QueryServer) {
	s.RegisterService(&Int32Query_ServiceDesc, srv)
}

func _Int32Query_Int32Query_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Int32QueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Int32QueryServer).Int32Query(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Int32Query_Int32Query_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Int32QueryServer).Int32Query(ctx, req.(*Int32QueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Int32Query_ServiceDesc is the grpc.ServiceDesc for Int32Query service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Int32Query_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "leo.example.route.query.Int32Query",
	HandlerType: (*Int32QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Int32Query",
			Handler:    _Int32Query_Int32Query_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "route/v1/query.proto",
}

const (
	Int64Query_Int64Query_FullMethodName = "/leo.example.route.query.Int64Query/Int64Query"
)

// Int64QueryClient is the client API for Int64Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Int64QueryClient interface {
	Int64Query(ctx context.Context, in *Int64QueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type int64QueryClient struct {
	cc grpc.ClientConnInterface
}

func NewInt64QueryClient(cc grpc.ClientConnInterface) Int64QueryClient {
	return &int64QueryClient{cc}
}

func (c *int64QueryClient) Int64Query(ctx context.Context, in *Int64QueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Int64Query_Int64Query_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Int64QueryServer is the server API for Int64Query service.
// All implementations must embed UnimplementedInt64QueryServer
// for forward compatibility
type Int64QueryServer interface {
	Int64Query(context.Context, *Int64QueryRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedInt64QueryServer()
}

// UnimplementedInt64QueryServer must be embedded to have forward compatible implementations.
type UnimplementedInt64QueryServer struct {
}

func (UnimplementedInt64QueryServer) Int64Query(context.Context, *Int64QueryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Int64Query not implemented")
}
func (UnimplementedInt64QueryServer) mustEmbedUnimplementedInt64QueryServer() {}

// UnsafeInt64QueryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Int64QueryServer will
// result in compilation errors.
type UnsafeInt64QueryServer interface {
	mustEmbedUnimplementedInt64QueryServer()
}

func RegisterInt64QueryServer(s grpc.ServiceRegistrar, srv Int64QueryServer) {
	s.RegisterService(&Int64Query_ServiceDesc, srv)
}

func _Int64Query_Int64Query_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Int64QueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Int64QueryServer).Int64Query(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Int64Query_Int64Query_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Int64QueryServer).Int64Query(ctx, req.(*Int64QueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Int64Query_ServiceDesc is the grpc.ServiceDesc for Int64Query service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Int64Query_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "leo.example.route.query.Int64Query",
	HandlerType: (*Int64QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Int64Query",
			Handler:    _Int64Query_Int64Query_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "route/v1/query.proto",
}

const (
	Uint32Query_Uint32Query_FullMethodName = "/leo.example.route.query.Uint32Query/Uint32Query"
)

// Uint32QueryClient is the client API for Uint32Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Uint32QueryClient interface {
	Uint32Query(ctx context.Context, in *Uint32QueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type uint32QueryClient struct {
	cc grpc.ClientConnInterface
}

func NewUint32QueryClient(cc grpc.ClientConnInterface) Uint32QueryClient {
	return &uint32QueryClient{cc}
}

func (c *uint32QueryClient) Uint32Query(ctx context.Context, in *Uint32QueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Uint32Query_Uint32Query_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Uint32QueryServer is the server API for Uint32Query service.
// All implementations must embed UnimplementedUint32QueryServer
// for forward compatibility
type Uint32QueryServer interface {
	Uint32Query(context.Context, *Uint32QueryRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedUint32QueryServer()
}

// UnimplementedUint32QueryServer must be embedded to have forward compatible implementations.
type UnimplementedUint32QueryServer struct {
}

func (UnimplementedUint32QueryServer) Uint32Query(context.Context, *Uint32QueryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Uint32Query not implemented")
}
func (UnimplementedUint32QueryServer) mustEmbedUnimplementedUint32QueryServer() {}

// UnsafeUint32QueryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Uint32QueryServer will
// result in compilation errors.
type UnsafeUint32QueryServer interface {
	mustEmbedUnimplementedUint32QueryServer()
}

func RegisterUint32QueryServer(s grpc.ServiceRegistrar, srv Uint32QueryServer) {
	s.RegisterService(&Uint32Query_ServiceDesc, srv)
}

func _Uint32Query_Uint32Query_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Uint32QueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Uint32QueryServer).Uint32Query(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Uint32Query_Uint32Query_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Uint32QueryServer).Uint32Query(ctx, req.(*Uint32QueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Uint32Query_ServiceDesc is the grpc.ServiceDesc for Uint32Query service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Uint32Query_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "leo.example.route.query.Uint32Query",
	HandlerType: (*Uint32QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Uint32Query",
			Handler:    _Uint32Query_Uint32Query_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "route/v1/query.proto",
}

const (
	Uint64Query_Uint64Query_FullMethodName = "/leo.example.route.query.Uint64Query/Uint64Query"
)

// Uint64QueryClient is the client API for Uint64Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Uint64QueryClient interface {
	Uint64Query(ctx context.Context, in *Uint64QueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type uint64QueryClient struct {
	cc grpc.ClientConnInterface
}

func NewUint64QueryClient(cc grpc.ClientConnInterface) Uint64QueryClient {
	return &uint64QueryClient{cc}
}

func (c *uint64QueryClient) Uint64Query(ctx context.Context, in *Uint64QueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Uint64Query_Uint64Query_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Uint64QueryServer is the server API for Uint64Query service.
// All implementations must embed UnimplementedUint64QueryServer
// for forward compatibility
type Uint64QueryServer interface {
	Uint64Query(context.Context, *Uint64QueryRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedUint64QueryServer()
}

// UnimplementedUint64QueryServer must be embedded to have forward compatible implementations.
type UnimplementedUint64QueryServer struct {
}

func (UnimplementedUint64QueryServer) Uint64Query(context.Context, *Uint64QueryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Uint64Query not implemented")
}
func (UnimplementedUint64QueryServer) mustEmbedUnimplementedUint64QueryServer() {}

// UnsafeUint64QueryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Uint64QueryServer will
// result in compilation errors.
type UnsafeUint64QueryServer interface {
	mustEmbedUnimplementedUint64QueryServer()
}

func RegisterUint64QueryServer(s grpc.ServiceRegistrar, srv Uint64QueryServer) {
	s.RegisterService(&Uint64Query_ServiceDesc, srv)
}

func _Uint64Query_Uint64Query_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Uint64QueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Uint64QueryServer).Uint64Query(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Uint64Query_Uint64Query_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Uint64QueryServer).Uint64Query(ctx, req.(*Uint64QueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Uint64Query_ServiceDesc is the grpc.ServiceDesc for Uint64Query service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Uint64Query_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "leo.example.route.query.Uint64Query",
	HandlerType: (*Uint64QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Uint64Query",
			Handler:    _Uint64Query_Uint64Query_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "route/v1/query.proto",
}

const (
	FloatQuery_FloatQuery_FullMethodName = "/leo.example.route.query.FloatQuery/FloatQuery"
)

// FloatQueryClient is the client API for FloatQuery service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FloatQueryClient interface {
	FloatQuery(ctx context.Context, in *FloatQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type floatQueryClient struct {
	cc grpc.ClientConnInterface
}

func NewFloatQueryClient(cc grpc.ClientConnInterface) FloatQueryClient {
	return &floatQueryClient{cc}
}

func (c *floatQueryClient) FloatQuery(ctx context.Context, in *FloatQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FloatQuery_FloatQuery_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FloatQueryServer is the server API for FloatQuery service.
// All implementations must embed UnimplementedFloatQueryServer
// for forward compatibility
type FloatQueryServer interface {
	FloatQuery(context.Context, *FloatQueryRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedFloatQueryServer()
}

// UnimplementedFloatQueryServer must be embedded to have forward compatible implementations.
type UnimplementedFloatQueryServer struct {
}

func (UnimplementedFloatQueryServer) FloatQuery(context.Context, *FloatQueryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FloatQuery not implemented")
}
func (UnimplementedFloatQueryServer) mustEmbedUnimplementedFloatQueryServer() {}

// UnsafeFloatQueryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FloatQueryServer will
// result in compilation errors.
type UnsafeFloatQueryServer interface {
	mustEmbedUnimplementedFloatQueryServer()
}

func RegisterFloatQueryServer(s grpc.ServiceRegistrar, srv FloatQueryServer) {
	s.RegisterService(&FloatQuery_ServiceDesc, srv)
}

func _FloatQuery_FloatQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FloatQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FloatQueryServer).FloatQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FloatQuery_FloatQuery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FloatQueryServer).FloatQuery(ctx, req.(*FloatQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FloatQuery_ServiceDesc is the grpc.ServiceDesc for FloatQuery service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FloatQuery_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "leo.example.route.query.FloatQuery",
	HandlerType: (*FloatQueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FloatQuery",
			Handler:    _FloatQuery_FloatQuery_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "route/v1/query.proto",
}

const (
	DoubleQuery_DoubleQuery_FullMethodName = "/leo.example.route.query.DoubleQuery/DoubleQuery"
)

// DoubleQueryClient is the client API for DoubleQuery service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DoubleQueryClient interface {
	DoubleQuery(ctx context.Context, in *DoubleQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type doubleQueryClient struct {
	cc grpc.ClientConnInterface
}

func NewDoubleQueryClient(cc grpc.ClientConnInterface) DoubleQueryClient {
	return &doubleQueryClient{cc}
}

func (c *doubleQueryClient) DoubleQuery(ctx context.Context, in *DoubleQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, DoubleQuery_DoubleQuery_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DoubleQueryServer is the server API for DoubleQuery service.
// All implementations must embed UnimplementedDoubleQueryServer
// for forward compatibility
type DoubleQueryServer interface {
	DoubleQuery(context.Context, *DoubleQueryRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedDoubleQueryServer()
}

// UnimplementedDoubleQueryServer must be embedded to have forward compatible implementations.
type UnimplementedDoubleQueryServer struct {
}

func (UnimplementedDoubleQueryServer) DoubleQuery(context.Context, *DoubleQueryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DoubleQuery not implemented")
}
func (UnimplementedDoubleQueryServer) mustEmbedUnimplementedDoubleQueryServer() {}

// UnsafeDoubleQueryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DoubleQueryServer will
// result in compilation errors.
type UnsafeDoubleQueryServer interface {
	mustEmbedUnimplementedDoubleQueryServer()
}

func RegisterDoubleQueryServer(s grpc.ServiceRegistrar, srv DoubleQueryServer) {
	s.RegisterService(&DoubleQuery_ServiceDesc, srv)
}

func _DoubleQuery_DoubleQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DoubleQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DoubleQueryServer).DoubleQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DoubleQuery_DoubleQuery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DoubleQueryServer).DoubleQuery(ctx, req.(*DoubleQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DoubleQuery_ServiceDesc is the grpc.ServiceDesc for DoubleQuery service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DoubleQuery_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "leo.example.route.query.DoubleQuery",
	HandlerType: (*DoubleQueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DoubleQuery",
			Handler:    _DoubleQuery_DoubleQuery_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "route/v1/query.proto",
}

const (
	StringQuery_StringQuery_FullMethodName = "/leo.example.route.query.StringQuery/StringQuery"
)

// StringQueryClient is the client API for StringQuery service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StringQueryClient interface {
	StringQuery(ctx context.Context, in *StringQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type stringQueryClient struct {
	cc grpc.ClientConnInterface
}

func NewStringQueryClient(cc grpc.ClientConnInterface) StringQueryClient {
	return &stringQueryClient{cc}
}

func (c *stringQueryClient) StringQuery(ctx context.Context, in *StringQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, StringQuery_StringQuery_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StringQueryServer is the server API for StringQuery service.
// All implementations must embed UnimplementedStringQueryServer
// for forward compatibility
type StringQueryServer interface {
	StringQuery(context.Context, *StringQueryRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedStringQueryServer()
}

// UnimplementedStringQueryServer must be embedded to have forward compatible implementations.
type UnimplementedStringQueryServer struct {
}

func (UnimplementedStringQueryServer) StringQuery(context.Context, *StringQueryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StringQuery not implemented")
}
func (UnimplementedStringQueryServer) mustEmbedUnimplementedStringQueryServer() {}

// UnsafeStringQueryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StringQueryServer will
// result in compilation errors.
type UnsafeStringQueryServer interface {
	mustEmbedUnimplementedStringQueryServer()
}

func RegisterStringQueryServer(s grpc.ServiceRegistrar, srv StringQueryServer) {
	s.RegisterService(&StringQuery_ServiceDesc, srv)
}

func _StringQuery_StringQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StringQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StringQueryServer).StringQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StringQuery_StringQuery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StringQueryServer).StringQuery(ctx, req.(*StringQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// StringQuery_ServiceDesc is the grpc.ServiceDesc for StringQuery service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StringQuery_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "leo.example.route.query.StringQuery",
	HandlerType: (*StringQueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StringQuery",
			Handler:    _StringQuery_StringQuery_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "route/v1/query.proto",
}

const (
	EnumQuery_EnumQuery_FullMethodName = "/leo.example.route.query.EnumQuery/EnumQuery"
)

// EnumQueryClient is the client API for EnumQuery service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EnumQueryClient interface {
	EnumQuery(ctx context.Context, in *EnumQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type enumQueryClient struct {
	cc grpc.ClientConnInterface
}

func NewEnumQueryClient(cc grpc.ClientConnInterface) EnumQueryClient {
	return &enumQueryClient{cc}
}

func (c *enumQueryClient) EnumQuery(ctx context.Context, in *EnumQueryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, EnumQuery_EnumQuery_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EnumQueryServer is the server API for EnumQuery service.
// All implementations must embed UnimplementedEnumQueryServer
// for forward compatibility
type EnumQueryServer interface {
	EnumQuery(context.Context, *EnumQueryRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedEnumQueryServer()
}

// UnimplementedEnumQueryServer must be embedded to have forward compatible implementations.
type UnimplementedEnumQueryServer struct {
}

func (UnimplementedEnumQueryServer) EnumQuery(context.Context, *EnumQueryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnumQuery not implemented")
}
func (UnimplementedEnumQueryServer) mustEmbedUnimplementedEnumQueryServer() {}

// UnsafeEnumQueryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EnumQueryServer will
// result in compilation errors.
type UnsafeEnumQueryServer interface {
	mustEmbedUnimplementedEnumQueryServer()
}

func RegisterEnumQueryServer(s grpc.ServiceRegistrar, srv EnumQueryServer) {
	s.RegisterService(&EnumQuery_ServiceDesc, srv)
}

func _EnumQuery_EnumQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnumQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnumQueryServer).EnumQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnumQuery_EnumQuery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnumQueryServer).EnumQuery(ctx, req.(*EnumQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EnumQuery_ServiceDesc is the grpc.ServiceDesc for EnumQuery service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EnumQuery_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "leo.example.route.query.EnumQuery",
	HandlerType: (*EnumQueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "EnumQuery",
			Handler:    _EnumQuery_EnumQuery_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "route/v1/query.proto",
}
