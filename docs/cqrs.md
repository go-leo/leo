# CQRS

CQRS是一个架构模式，它将应用程序分解为两个不同的路径：命令和查询。

## 命令侧

每个可以触发服务器上的副作用的操作都必须通过CQRS“命令侧”。
![command side](images/command_side.jpg)

## 查询侧

每个可以触发服务器上的查询操作都必须通过CQRS“查询侧”。
![query side](images/query_side.jpg)

# Leo CQRS 定义

1. 通过`protobuf`定义服务
2. 一个 `rpc method` 是命令还是查询，可以通过 `Output Message` 决定
    * 如果 `Output Message`没有一个参数，则是认为是命令
    * 如果 `Output Message`有至少一个参数(普通参数或者oneof参数)，则是认为是查询。

# 案例

```protobuf
syntax = "proto3";
package leo.example.cqrs;

option go_package = "github.com/go-leo/leo/v3/example/api/cqrs/v1;cqrs";

import "google/api/annotations.proto";
import "google/protobuf/empty.proto";

service Cqrs {
  // Command 是命令
  rpc Command (CommandRequest) returns (CommandReply) {
    option (google.api.http) = {
      post: "/v1/cqrs/command"
      body: "*"
    };
  }

  // CommandEmpty 是命令
  rpc CommandEmpty (CommandRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      post: "/v1/cqrs/command"
      body: "*"
    };
  }

  // Query 是查询
  rpc Query (QueryRequest) returns (QueryReply) {
    option (google.api.http) = {
      post: "/v1/cqrs/query"
      body: "*"
    };
  }

  // QueryOneOf 是查询
  rpc QueryOneOf (QueryRequest) returns (QueryOneOfReply) {
    option (google.api.http) = {
      post: "/v1/cqrs/query-oneof"
      body: "*"
    };
  }
}

message QueryRequest {
  string name = 1;
}

message QueryReply {
  string message = 1;
}

message CommandRequest {
  string name = 1;
}

message CommandReply {}

message QueryOneOfRequest {
  string name = 1;
}

message QueryOneOfReply {
  oneof data {
    string name = 1;
    string id = 2;
  }
}
```

## 代码生成

```
protoc \
		--proto_path=. \
		--proto_path=../../proto/ \
		--proto_path=../../third_party \
		--go_out=. \
		--go_opt=paths=source_relative \
		--go-grpc_out=. \
        --go-grpc_opt=paths=source_relative \
		--go-leo_out=. \
		--go-leo_opt=paths=source_relative \
		cqrs.proto 
```

```go
// Code generated by protoc-gen-go-leo. DO NOT EDIT.

package cqrs

import (
	context "context"
	cqrs "github.com/go-leo/leo/v3/cqrs"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

func NewCqrsCqrsService[
CommandCommandType CommandCommand,
CommandEmptyCommandType CommandEmptyCommand,
QueryQueryType QueryQuery, QueryResultType QueryResult,
QueryOneOfQueryType QueryOneOfQuery, QueryOneOfResultType QueryOneOfResult,
](
	commandHandler cqrs.CommandHandler[CommandCommandType],
	commandEmptyHandler cqrs.CommandHandler[CommandEmptyCommandType],
	queryHandler cqrs.QueryHandler[QueryQueryType, QueryResultType],
	queryOneOfHandler cqrs.QueryHandler[QueryOneOfQueryType, QueryOneOfResultType],
) (CqrsService, error) {
	var bus cqrs.SampleBus
	if err := bus.RegisterCommand(commandHandler); err != nil {
		return nil, err
	}
	if err := bus.RegisterCommand(commandEmptyHandler); err != nil {
		return nil, err
	}
	if err := bus.RegisterQuery(queryHandler); err != nil {
		return nil, err
	}
	if err := bus.RegisterQuery(queryOneOfHandler); err != nil {
		return nil, err
	}
	return &cqrsCqrsService[
		CommandCommandType,
		CommandEmptyCommandType,
		QueryQueryType, QueryResultType,
		QueryOneOfQueryType, QueryOneOfResultType,
	]{bus: &bus}, nil
}

type cqrsCqrsService[
CommandCommandType CommandCommand,
CommandEmptyCommandType CommandEmptyCommand,
QueryQueryType QueryQuery, QueryResultType QueryResult,
QueryOneOfQueryType QueryOneOfQuery, QueryOneOfResultType QueryOneOfResult,
] struct {
	bus cqrs.Bus
}

func (svc *cqrsCqrsService[
	CommandCommandType,
	CommandEmptyCommandType,
	QueryQueryType, QueryResultType,
	QueryOneOfQueryType, QueryOneOfResultType,
]) Command(ctx context.Context, request *CommandRequest) (*CommandReply, error) {
	var command CommandCommandType
	cmd, ctx, err := command.From(ctx, request)
	if err != nil {
		return nil, err
	}
	if err := svc.bus.Exec(ctx, cmd); err != nil {
		return nil, err
	}
	return new(CommandReply), nil
}

func (svc *cqrsCqrsService[
	CommandCommandType,
	CommandEmptyCommandType,
	QueryQueryType, QueryResultType,
	QueryOneOfQueryType, QueryOneOfResultType,
]) CommandEmpty(ctx context.Context, request *CommandRequest) (*emptypb.Empty, error) {
	var command CommandEmptyCommandType
	cmd, ctx, err := command.From(ctx, request)
	if err != nil {
		return nil, err
	}
	if err := svc.bus.Exec(ctx, cmd); err != nil {
		return nil, err
	}
	return new(emptypb.Empty), nil
}

func (svc *cqrsCqrsService[
	CommandCommandType,
	CommandEmptyCommandType,
	QueryQueryType, QueryResultType,
	QueryOneOfQueryType, QueryOneOfResultType,
]) Query(ctx context.Context, request *QueryRequest) (*QueryReply, error) {
	var query QueryQueryType
	q, ctx, err := query.From(ctx, request)
	if err != nil {
		return nil, err
	}
	r, err := svc.bus.Query(ctx, q)
	if err != nil {
		return nil, err
	}
	return r.(QueryResultType).To(ctx)
}

func (svc *cqrsCqrsService[
	CommandCommandType,
	CommandEmptyCommandType,
	QueryQueryType, QueryResultType,
	QueryOneOfQueryType, QueryOneOfResultType,
]) QueryOneOf(ctx context.Context, request *QueryRequest) (*QueryOneOfReply, error) {
	var query QueryOneOfQueryType
	q, ctx, err := query.From(ctx, request)
	if err != nil {
		return nil, err
	}
	r, err := svc.bus.Query(ctx, q)
	if err != nil {
		return nil, err
	}
	return r.(QueryOneOfResultType).To(ctx)
}

type (
	CommandCommand interface {
		isCommandCommand_Kind()
		From(context.Context, *CommandRequest) (CommandCommand, context.Context, error)
	}
	UnimplementedCommandCommand struct{}

	CommandEmptyCommand interface {
		isCommandEmptyCommand_Kind()
		From(context.Context, *CommandRequest) (CommandEmptyCommand, context.Context, error)
	}
	UnimplementedCommandEmptyCommand struct{}
)

type (
	QueryQuery interface {
		isQueryQuery_Kind()
		From(context.Context, *QueryRequest) (QueryQuery, context.Context, error)
	}
	QueryResult interface {
		isQueryResult_Kind()
		To(context.Context) (*QueryReply, error)
	}
	UnimplementedQueryQuery  struct{}
	UnimplementedQueryResult struct{}

	QueryOneOfQuery interface {
		isQueryOneOfQuery_Kind()
		From(context.Context, *QueryRequest) (QueryOneOfQuery, context.Context, error)
	}
	QueryOneOfResult interface {
		isQueryOneOfResult_Kind()
		To(context.Context) (*QueryOneOfReply, error)
	}
	UnimplementedQueryOneOfQuery  struct{}
	UnimplementedQueryOneOfResult struct{}
)

func (UnimplementedCommandCommand) isCommandCommand_Kind() {}
func (UnimplementedCommandCommand) From(context.Context, *CommandRequest) (CommandCommand, context.Context, error) {
	panic("implement me")
	return nil, nil, nil
}
func (UnimplementedCommandEmptyCommand) isCommandEmptyCommand_Kind() {}
func (UnimplementedCommandEmptyCommand) From(context.Context, *CommandRequest) (CommandEmptyCommand, context.Context, error) {
	panic("implement me")
	return nil, nil, nil
}
func (UnimplementedQueryQuery) isQueryQuery_Kind() {}
func (UnimplementedQueryQuery) From(context.Context, *QueryRequest) (QueryQuery, context.Context, error) {
	panic("implement me")
	return nil, nil, nil
}
func (UnimplementedQueryResult) isQueryResult_Kind() {}
func (UnimplementedQueryResult) To(context.Context) (*QueryReply, error) {
	panic("implement me")
	return nil, nil
}

func (UnimplementedQueryOneOfQuery) isQueryOneOfQuery_Kind() {}
func (UnimplementedQueryOneOfQuery) From(context.Context, *QueryRequest) (QueryOneOfQuery, context.Context, error) {
	panic("implement me")
	return nil, nil, nil
}
func (UnimplementedQueryOneOfResult) isQueryOneOfResult_Kind() {}
func (UnimplementedQueryOneOfResult) To(context.Context) (*QueryOneOfReply, error) {
	panic("implement me")
	return nil, nil
}
```

注意：

1. NewXXXCqrsService 函数创建一个 XXXService 实例，可以用于grpc 和 http 服务。
2. NewCqrsCqrsService 函数是个泛型函数，参数是 `cqrs.CommandHandler` 或者 `cqrs.QueryHandler`
3. 泛型参数需满足  `XXXCommand`、`XXXQuery`和`XXXResult` 接口，由于`isXXX_Kind()` 是未导出方法，所有需要再结构体内嵌`UnimplementedXXXQuery`
4. 用法如下

## CQRS Handler 代码
Command Handler 示例
```go
package handler

import (
	context "context"
	"fmt"
	cqrs "github.com/go-leo/leo/v3/cqrs"
	v1 "github.com/go-leo/leo/v3/example/api/cqrs/v1"
)

var _ CommandHandler = (*commandHandler)(nil)

type CommandHandler cqrs.CommandHandler[CommandCommand]

type CommandCommand struct {
	v1.UnimplementedCommandCommand
	Name string
}

func (CommandCommand) From(ctx context.Context, req *v1.CommandRequest) (v1.CommandCommand, context.Context, error) {
	return CommandCommand{Name:req.GetName()}, ctx, nil
}

func NewCommandHandler() CommandHandler {
	return &commandHandler{}
}

type commandHandler struct {
}

func (h *commandHandler) Handle(ctx context.Context, cmd CommandCommand) error {
	fmt.Println("commandHandler:", cmd.Name)
	return nil
}
```
注意：
1. `type CommandHandler cqrs.CommandHandler[CommandCommand]` 是一个命令Handler接口定义
2. `CommandCommand` 是一个命令，内嵌`v1.UnimplementedCommandCommand`, 用来实现 `v1.CommandCommand`, `Name` 是命令参数
3. `commandHandler` 实现了 `CommandHandler` 接口，命令处理逻辑写在`Handle`方法里


Query Handler 示例
```go
package handler

import (
	context "context"
	cqrs "github.com/go-leo/leo/v3/cqrs"
	v1 "github.com/go-leo/leo/v3/example/api/cqrs/v1"
)

var _ QueryHandler = (*queryHandler)(nil)

type QueryHandler cqrs.QueryHandler[QueryQuery, QueryResult]

type QueryQuery struct {
	v1.UnimplementedQueryQuery
	Name string
}

func (QueryQuery) From(ctx context.Context, req *v1.QueryRequest) (v1.QueryQuery, context.Context, error) {
	return QueryQuery{Name: req.GetName()}, ctx, nil
}

type QueryResult struct {
	v1.UnimplementedQueryResult
	Message string
}

func (r QueryResult) To(ctx context.Context) (*v1.QueryReply, error) {
	return &v1.QueryReply{Message: r.Message}, nil
}

func NewQueryHandler() QueryHandler {
	return &queryHandler{}
}

type queryHandler struct {
}

func (h *queryHandler) Handle(ctx context.Context, q QueryQuery) (QueryResult, error) {
	return QueryResult{Message: "hello " + q.Name}, nil
}
```
注意：
1. `type QueryHandler cqrs.QueryHandler[QueryQuery, QueryResult]` 是一个查询Handler接口定义
2. `QueryQuery` 是一个查询，内嵌`v1.UnimplementedQueryQuery`, 用来实现 `v1.QueryQuery`, `Message` 是查询参数
3. `QueryResult` 是一个查询结果，内嵌`v1.UnimplementedQueryResult`, 用来实现 `v1.QueryResult`, `Message` 是查询结果参数
4. `queryHandler` 实现了 `QueryHandler` 接口，查询处理逻辑写在`Handle`方法里

# gRPC使用示例
```go
package main

import (
   "context"
   "github.com/go-leo/leo/v3"
   "github.com/go-leo/leo/v3/example/api/cqrs/v1"
   "github.com/go-leo/leo/v3/example/cqrs/handler"
   "github.com/go-leo/leo/v3/serverx/grpcserverx"
   "log"
)

func main() {
   cqrsService, err := cqrs.NewCqrsCqrsService(
      handler.NewCommandHandler(),
      handler.NewCommandEmptyHandler(),
      handler.NewQueryHandler(),
      handler.NewQueryOneOfHandler(),
   )
   if err != nil {
      panic(err)
   }
   grpcSrv := grpcserverx.NewServer(grpcserverx.Port(50051))
   cqrs.RegisterCqrsServer(grpcSrv, cqrs.NewCqrsGrpcServer(cqrsService))
   if err := leo.NewApp(leo.Runner(grpcSrv)).Run(context.Background()); err != nil {
      log.Fatalf("failed to serve: %v", err)
   }
}
```

# http 使用示例
```go
package main

import (
   "context"
   "github.com/go-leo/leo/v3"
   "github.com/go-leo/leo/v3/example/api/cqrs/v1"
   "github.com/go-leo/leo/v3/example/cqrs/handler"
   "github.com/go-leo/leo/v3/serverx/httpserverx"
   "github.com/gorilla/mux"
   "log"
)

func main() {
   cqrsService, err := cqrs.NewCqrsCqrsService(handler.NewCommandHandler(), handler.NewCommandEmptyHandler(), handler.NewQueryHandler(), handler.NewQueryOneOfHandler())
   if err != nil {
      panic(err)
   }
   httpSrv := httpserverx.NewServer(
      cqrs.AppendCqrsHttpServerRoutes(mux.NewRouter(), cqrsService),
      httpserverx.Port(60051),
   )
   if err := leo.NewApp(leo.Runner(httpSrv)).Run(context.Background()); err != nil {
      log.Fatalf("failed to serve: %v", err)
   }
}
```

详细代码见[cqrs](../example/cqrs)
